---
layout: post
category: 学习之路
title:  "Swift学习" 
---

1.数组、字典

```
var array = [String]();
var array = Array(repeating:0,count:5);  -> [0,0,0,0,0]

数组构建方法  []    var array: [String]!

数组可以直接相加 直接加数组 
var anotherThreeDoubles = Array(repeating: "2.5", count: 2)
var sixDoubles = anotherThreeDoubles + anotherThreeDoubles
// sixDoubles类型是 [String], 包含元素:["2.5", "2.5", "2.5", "2.5"]
sixDoubles = sixDoubles + ["2.5"]

但是数组中只能存储同一类型的数据

数组常用方法

insert(_:at:): 在某个位置插入元素  不能超出数组大小
remove(at:): 移除某个位置的元素
removeLast(): 移除最后一个元素
enumerated(): 该方法返回一个包含索引和对应位置的值的元祖(tuple)数组(Example)。
```

2.数组的遍历

```
// 遍历数组
for i in 0..<array.count {
    print(array[i])
}
// forin 方式
for item in array {
    print(item)
}
// 设置遍历的区间
for item in array[0..<2] {
    print(item)
}
// enumerated 遍历
for en in array2.enumerated() {
    print(en)
    // 下标
    print(en.offset)
    // 值
    print(en.element)
}
// 下标和数值同时遍历   元祖
for (n,s) in array2.enumerated() {
     print(n , "==", s);
}
// 反序遍历
for s in array2.reversed() {
    print(s)
} 
// 遍历下标和数值 反序
for (xxx,ooo) in array2.enumerated().reversed() {
    print(xxx ,"====" ,ooo)
}
```

3.字典创建方法

```
字典构建方法  [:]    var dic: [String : String]!

var dict : [String : String] = [:] 表示空字典
 
var dict : Dictionary<String,String> = Dictionary.init();

var airports : Dictionary<String, String> = ["TYP":"Tokyo", "DUB":"Boublin"]

var airports2 = ["TYP":"Tokyo", "DUB":"Boublin"]

var empty_dic = Dictionary<String, String>()

```







4.swift 和 oc 交互 

```
swift 和 OC 混用会有两个新文件 

1、工程名-Swift.h 是 用于 oc 调用 swift 、是swift代码在工程中自动更新出的oc格式代码
 不可见，但是可以跳转进入，所有swift代码生成的类属性 都会在这个文件中转义一份oc的样式 

2、工程名-Bridging-Header.h 是用于 swift 调用 oc 的头文件，所有需要引入swift的OC都需要先在这个文件引入。

```



5.swift 进入oc  oc 进入swift  swift 有命名空间  名字会有区别

```
swift的类名 转成 oc 自带了格式，并非直接名字。所以通过class去寻找指定类需要转className

在swift根据类名找xib也需要注意命名空间，一般式工程名.类名

//获取xib
  class func nib() -> UINib {
      let className = NSStringFromClass(self)
      let postfix = className.components(separatedBy: ".").last
      return UINib(nibName: postfix!, bundle: nil)
  }

//获取对应className
- (Class)swiftClassFromString:(NSString *)className {

  	NSString *appName = 
  	[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"];
	NSString *classStringName = 
	[NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className];
  	return NSClassFromString(classStringName);

}
```



http://stackoverflow.com/questions/24030814/swift-language-nsclassfromstring

http://www.cnblogs.com/godlovexq/p/5293027.html



6. swift3.0 新特性

```
@noescape   变成默认属性

@escaping 逃逸闭包

逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行

@autoclosure 自动闭包

(1)默认非逃逸

(2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。

(3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。

(4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。

(5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。

(6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明: @autoclosure @escaping 旧版本：@autoclosure(escaping)

```

7. swift 枚举

```
swift 枚举 
    var result = Planet.One;
    result = .Two;
    switch result {
      case .One:
       print("执行One");
      case .Two:
       print("执行Two");
      default:
       print("执行Default");
    }

元祖 枚举

    enum Barcode {
      case UPCA(Int,Int,Int)

      case QRCode(String)
    }
    
    var code = Barcode.UPCA(1, 8, 8);
    
    switch code {
    
      case .UPCA(let num1,let num2,let num3):

       print("(num1)");

      case .QRCode(let strOne):

       print("(strOne)");

      default:

      print("111");

    }
    
    enum Expression {
    
    case add(Int)
    
    case plus(Int)
    
    }
    
    var method = Expression.add(5);
    
    switch method {
    
    case .add(let num):
    
    print("(num)");
    
    default:
    
    print("xxx");
    
    }
```

8.swift  闭包懒加载按钮 不能先给target  

9.swift lazy属性

    //定义一个闭包
    lazy var html: () -> String = {
       if let text = self.text {
            return "11111";
        } else {
            return "2222";
        }
    }
    //定义一个字符串
    lazy var second:String = {
        if let text = self.text {
            return "11111";
        } else {
            return "2222";
        }
    }()  //不要忘记最后的小括号，只有加了小括号，必包才会在掉用的时候立刻执行。
    	//要类型声明lazy var second:String，这样Xcode会进行类型检查。
    
    
    懒加载初始化的定义
    
    懒加载初始化只进入一次  并且在需要的时候才调用
    
    在Objective C中， 懒加载初始化是这样写的
    
        @property (strong,nonatomic) CAShapeLayer * shapelayer;
       
        -(CAShapeLayer *)shapelayer{   
        
           if (!_shapelayer) {       
    
              _shapelayer = [CAShapeLayer layer];    
           }    
           return _shapelayer;
        }
    
    那么何为 懒加载初始化呢？ 
    
    从OC的代码中不难看出， 懒加载初始化，就是在变量第一次使用的时候才进行初始化。
    
    Swift中，有两种方式来 懒加载初始化。 
    
    第一种，简单表达式
    
    lazy var first = NSArray(objects: "1","2")
    
    第二种，闭包
    
    lazy var second:String = {return "second" }()
    
    
    
    懒加载初始化的使用场景
    
    1、属性本身依赖于外部因素才能初始化 
    
    completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀
    
    class Demo{    
    
    var url:NSString    
    
    lazy var completeURL:NSString = {       
       [unowned self] in       //防止闭包循环
       if self.url.hasPrefix("http://"){           
         return self.url        
      }else{            
         return "http://".stringByAppendingString(self.url)        
      }        
    }()    
    
    init(url:NSString){       
     self.url = url    
    }}
    
    2、属性需要复杂计算，消耗大量CPU
    
    lazy var second:Int = {       
    	var sum = 0        
    	for i in 1...100000{ sum += i}        
    	return sum        
    }()
    
    3、属性不确定是否会使用到
    
    官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化。
    
    4、定制化的初始化 
    
    有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护
    
    lazy var dataArray:NSMutableArray = {
      var array = NSMutableArray()        
      for  i in 1...100{
        array.addObject(NSNumber(integer: i))        
      }        
      return array        
    }()
    
10.Use Legacy Swift Language Version  错误    

在project  和target 吧 SWIFT_VERSION   Use Legacy Swift Language Version   这个属性改成NO就可以了



11. 自定义表达式

```
infix  prefix  postfix 自定义表达式  实现 swift3.0  

比如定义一个  ** 表达式  

infix operator **   //这句话只能定义在文件，类的外面，其余类可以针对这个定义 做不同实现

//下面这里 实现是类似 ?? 方法 ，扩展optional    实现这么一个方法   static 方法

extension Optional {

	static func ** <T>(optional : T? , defaultValue : @autoclosure () -> T) -> T {}

}

```









weak 和 unowned

“用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 "无效的" 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。”



swift 打印内存地址



swift 代码补全

http://www.jianshu.com/p/bbbfc524ca93



注释



    // MARK: - 操作
    // TODO: - 记得做
    // FIXME: - 提醒


闭包内部防止循环引用









NS_DESIGNATED_INITIALIZER   指定某个OC方法为 designated initializer  因为swift  继承oc类出来 实现init方法外必须要实现一个designated init方法 



宏和 const static 的区别 多用static





swift 不能调用oc 类方法



swift delegate 代理调用 不再使用resonse响应去校验方法是否存在

直接optional去调用就可以  

  self.delegate?.GXQActionSheetClickAtIndex(index: type!, viewController: self)



OC 宏的使用







swift 枚举和oc枚举

OC

typedef NS_ENUM  推荐使用

typedef enum



swift



enum XXX {

case <#case#>

}



如果需要在oc中使用swift定义的枚举 需要加上 @objc前缀  如果是swift定义的协议 也是一样的



swift 自定义运算符

新的运算符声明需在全局域使用operator关键字声明，可以声明为前置，中置或后置的。





当之前定义过的运算符 可以直接重载成其他参数类型 



```
func += <K,V>( left:inout [K:V], right:[K:V] ) {
    right.forEach { (key, value) in
        left.updateValue(value, forKey: key)
    }
}
func + <K,V>(left: [K:V], right:[K:V]) -> [K:V] {
    var result = left
    result += right
    return result
}
```



swift写法

```

- (NSString *)cellIdentify{
    return @{@(HomeItemTypeAssetsHead).stringValue:@"AssetsHeadTableViewCell",
             @(HomeItemTypeRedPacket).stringValue:@"NewUserRedPacketTableViewCell",
             @(HomeItemTypeIntroduce).stringValue:@"IntroduceTableViewCell",
             @(HomeItemTypeProduct).stringValue:@"GXQRecommendProductCell",
             @(HomeItemTypeNotice).stringValue:@"HomeNoticeTableViewCell",
             @(HomeItemTypeAssetsCell).stringValue:@"HomeAssetsTableViewCell",
             @(HomeItemTypeXueBi).stringValue:@"HomeXuebiTableViewCell",
             @(HomeItemTypeCarousel).stringValue:@"HomeCarouselTableViewCell"}
    [@(self.type).stringValue];
}
```



函数式

```
var newEvens = [Int]()
for i in 1...10 {
  if i % 2 == 0 {
         newEvens.append(i)
    } 
}
print(newEvens) // [2, 4, 6, 8, 10]

可以写成

var evens = Array(1...10).filter { $0 % 2 == 0 } 
print(evens) 
// [2, 4, 6, 8, 10]

```



swift 绑定xib的时候 不能直接用className 去查找对应nib  因为swift存在域名 前面有工程名的前缀

swift viewController xib初始化的时候要实现init（）里面super.init（根据xib名字去初始化）



        topImageView.mas_makeConstraints {
            $0?.top.leading().bottom().equalTo()(self)
            $0?.width.equalTo()(self.bgImageView.mas_width)?.multipliedBy()(0.0)
        }
        
        1.msonry可以校验宽度，比如占父类百分之多少宽度
        2.swift $0? 参数
        3.msonry可以校验宽度会引发的问题
        4.make.leading.equalTo(leftView.mas_trailing);  mas_right 和 mas_trailing 不是同一个东西，一套不能和另一套混用
柯里化


参考文献

[Swift3.0中文文档（非最新）](http://www.cocoachina.com/industry/20140613/8818.html)

[Swift3.0官方文档](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)