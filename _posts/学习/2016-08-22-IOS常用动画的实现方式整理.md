---
layout: post
category: 学习之路
title:  "IOS常用动画的实现方式整理" 
---

## 一、CoreAnimation（核心动画）

### 1.核心动画介绍

#### 1.什么是核心动画

Core Animation可以用在 Mac OS X 和 iOS平台. Core Animation的动画执行过程是在后台操作的.不会阻塞主线程. 要注意的是, Core Animation是直接作用在CALayer上的.并非UIView。

动画操作过程：

1、创建一个CAAnimation对象

2、设置一些动画的相关属性

3、给CALayer添加动画（addAnimation:forKey: 方法）

4、移除CALayer中得动画（removeAnimationForKey: 方法）

总体来说核心动画的优点有：

1、性能强大，使用硬件加速，可以同时向多个图层添加不同的动画效果

2、接口易用，只需要少量的代码就可以实现复杂的动画效果。

3、运行在后台线程中，在动画过程中可以响应交互事件（UIView动画默认动画过程中不响应交互事件）。（ CALayer不响应用户事件？）

4.只有在发生改变的时候才重绘内容，消除了动画的帧速率上的运行代码，提高应用性能

#### 2.核心动画类

![png](https://xilankong.github.io/resource/animtion_tree.png)

CAAnimation是所有动画对象的父类，实现CAMediaTiming协议，负责控制动画的时间、速度和时间曲线等等，是一个抽象类，不能直接使用。

CAPropertyAnimation ：是CAAnimation的子类，它支持动画地显示图层的keyPath，不直接使用。

综上，核心动画类中可以直接使用的类有：

1. CABasicAnimation  基础动画

2. CAKeyframeAnimation  关键帧动画

3. CATransition 转场动画

4. CAAnimationGroup 组动画

5. CASpringAnimation 弹性动画 （iOS9.0之后新增CASpringAnimation类，它实现弹簧效果的动画，是CABasicAnimation的子类。）

#### 1）CAAnimation

##### 属性：

1. duration：动画的持续时间，默认为0.25秒

2. repeatCount：动画的重复次数

3. repeatDuration：动画的重复时间

4. removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode属性为kCAFillModeForwards

5. fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后

6. beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间

7. timingFunction：速度控制函数，控制动画运行的节奏

   枚举参数：

   ```
   kCAMediaTimingFunctionLinear  时间曲线函数，匀速
   kCAMediaTimingFunctionEaseIn  时间曲线函数，由慢到特别快
   kCAMediaTimingFunctionEaseOut  时间曲线函数，由快到慢
   kCAMediaTimingFunctionEaseInEaseOut  时间曲线函数，由慢到快
   kCAMediaTimingFunctionDefault   系统默认
   ```

8. delegate：动画代理，一般设置隐式代理，该代理是NSObject的分类，需要遵守协议CAAnimationDelegate

   （1）`- (void)animationDidStart:(CAAnimation *)anim;`核心动画开始时执行
   （2）`- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;`核心动画执行结束后调用

#### 2）CAPropertyAnimation

##### 属性：

1.keyPath参数：通过指定CALayer的一个属性名做为keyPath里的参数(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。
比如：

CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"position.y"];

#### 一些常用的animationWithKeyPath值的总结

| 值                       | 说明                  | 使用形式                                     |
| ----------------------- | ------------------- | ---------------------------------------- |
| transform.scale         | 比例转化                | @(0.8)                                   |
| transform.scale.x       | 宽的比例                | @(0.8)                                   |
| transform.scale.y       | 高的比例                | @(0.8)                                   |
| transform.rotation.x    | 围绕x轴旋转              | @(M_PI)                                  |
| transform.rotation.y    | 围绕y轴旋转              | @(M_PI)                                  |
| transform.rotation.z    | 围绕z轴旋转              | @(M_PI)                                  |
| cornerRadius            | 圆角的设置               | @(50)                                    |
| backgroundColor         | 背景颜色的变化             | (id)[UIColor purpleColor].CGColor        |
| bounds                  | 大小，中心不变             | [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; |
| position                | 位置(中心点的改变)          | [NSValue valueWithCGPoint:CGPointMake(300, 300)]; |
| contents                | 内容，比如UIImageView的图片 | imageAnima.toValue = (id)[UIImage imageNamed:@"to"].CGImage; |
| opacity                 | 透明度                 | @(0.7)                                   |
| contentsRect.size.width | 横向拉伸缩放              | @(0.4)最好是0~1之间的                          |

CGAffineTransform

#### 3）CABasicAnimation

##### 属性：

**1.fromValue** : keyPath相应属性的初始值
**2.toValue** : keyPath相应属性的结束值，到某个固定的值（类似transform的make含义）
注意：随着动画的进行,在长度为duration的持续时间内,keyPath相应属性的值从fromValue渐渐地变为toValue.
如果fillMode = kCAFillModeForwards和removedOnComletion = NO;那么在动画执行完毕后,图层会保持显示动画执行后的状态,但实质上,图层的属性值还是动画执行前的初始值,并没有真正被改变.比如: CALayer的postion初始值为(0,0),CABasicAnimation的fromValue为(10,10),toValue为 (100,100),虽然动画执行完毕后图层保持在(100,100) 这个位置,实质上图层的position还是为(0,0);
**3.byValue**：不断进行累加的数值（byvalue 值加上fromValue => tovalue）
例子：

```
CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
animation.byValue = @(M_PI * 2);
```

#### 4)  CAKeyframeAnimation

**属性**

**1.values**：NSArray对象，里面的元素称为”关键帧”（NSValue类型），动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧（ NSValue）
例子：

```
//设置动画属性

NSValue *p1 = [NSValue valueWithCGPoint:CGPointMake(50, 150)];
NSValue *p2 = [NSValue valueWithCGPoint:CGPointMake(250, 150)];
NSValue *p3 = [NSValue valueWithCGPoint:CGPointMake(50, 550)];
NSValue *p4 = [NSValue valueWithCGPoint:CGPointMake(250, 550)];
animKey.values = @[p1, p2, p3, p4];
```

**2.keyTimes**：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧，当keyTimes没有设置的时候,各个关键帧的时间是平分的

**3.path**：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动，path只对CALayer的anchorPoint和position起作用，如果设置了path，那么values将被忽略。
例子：

```
UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 100, 250, 100)];
animKey.path = path.CGPath;
```

**4.rotationMode**：旋转模式

（1）默认nil

（2）设置为kCAAnimationRotateAuto 或 kCAAnimationRotateAutoReverse 会随着旋转的角度做 ”自转“
animKey.rotationMode = kCAAnimationRotateAuto; 

#### 5)  CAAnimationGroup

**1.animations**：动画组，用来保存一组动画对象的NSArray。默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。
例子：

```
// 2. 向组动画中添加各种子动画
// 2.1 旋转

CABasicAnimation *anim1 = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
// anim1.toValue = @(M_PI * 2 * 500);
anim1.byValue = @(M_PI * 2 * 1000);

// 2.2 缩放

CABasicAnimation *anim2 = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
anim2.toValue = @(0.1);

// 2.3 改变位置, 修改position

CAKeyframeAnimation *anim3 = [CAKeyframeAnimation animationWithKeyPath:@"position"];
anim3.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 100, 250, 100)].CGPath;

// 把子动画添加到组动画中
anim.animations = @[anim1, anim2, anim3];
```



#### 6)  CATransition

**1.type**：设置动画过渡的类型

```
kCATransitionFade 交叉淡化过渡

kCATransitionMoveIn 新视图移到旧视图上面

kCATransitionPush 新视图把旧视图推出去

kCATransitionReveal 将旧视图移开,显示下面的新视图
```

下面类型包装成字符串赋值  转场动画过渡效果

**2.subtype**：设置动画过渡方向

```
kCATransitionFromRight

kCATransitionFromLeft

kCATransitionFromTop

kCATransitionFromBottom
```

**3.startProgress**：动画起点(在整体动画的百分比)

**4.endProgress**：动画终点(在整体动画的百分比)
例子：

```
(IBAction)didRecognizeSwipeGesture:(UISwipeGestureRecognizer *)sender {

  // 1. 创建一个转场动画对象
  CATransition *anim = [[CATransition alloc] init];
  // 设置转场动画的类型
  anim.type = @"suckEffect";
  // 设置转场动画时间
  anim.duration = 1.5;
  anim.delegate = self;
  // 判断方向
  if (sender.direction == UISwipeGestureRecognizerDirectionLeft) {
      // 设置转场动画的子类型
      anim.subtype = kCATransitionFromRight;
      // NSLog(@"left");
      self.index++;
  } else {
      // 设置转场动画的子类型
      anim.subtype = kCATransitionFromLeft;
      // NSLog(@"right");
      self.index--;
  }

  // 判断是否越界
  if (self.index > 4) {
      self.index = 0;
  }

  if (self.index < 0) {
      self.index = 4;
  }

  // 拼接图片名称
  NSString *imgName = [NSString stringWithFormat:@"%d", self.index + 1];
  // 切换图片
  self.imgViewIcon.image = [UIImage imageNamed:imgName];
  // 把转场动画添加到对应的控件上
   [self.imgViewIcon.layer addAnimation:anim forKey:@"anim1"];
}
```



### 2.CALayer图形绘制

#### 1.CALayer

CALayer是NSObject的子类而非UIResponder的子类，因此图层本身无法响应用户操作事件却拥有着事件响应链相似的判断方法，所以CALayer需要包装成一个UIView容器来完成这一功能。

每一个UIView自身存在一个CALayer来显示内容。在后者的属性中我们可以看到存在着多个和UIView界面属性对应的变量，因此我们在修改UIView的界面属性的时候其实是修改了这个UIView对应的layer的属性。

CALayer拥有和UIView一样的树状层级关系，也有类似UIView添加子视图的addSublayer这些类似的方法。CALayer可以独立于UIView之外显示在屏幕上，但我们需要重写事件方法来完成对它的响应操作。

[为什么有了UIView还要CALayer](http://www.cocoachina.com/ios/20150828/13257.html)

**CALayer常用属性**：

**1.position和anchorPoint**

anchorPoint是一个x和y值取值范围内在0~1之间CGPoint类型，它决定了当图层发生几何仿射变换时基于的坐标原点。默认情况下为0.5, 0.5，由anchorPoint和frame经过计算获得图层的position这个值。

**2.mask和maskToBounds**

maskToBounds值为true时表示超出图层范围外的所有子图层都不会进行渲染，当我们设置UIView的clipsToBounds时实际上就是在修改maskToBounds这个属性。mask这个属性表示一个遮罩图层，在这个遮罩之外的内容不予渲染显示。

**3.cornerRadius、borderWidth和borderColor**

borderWidth和borderColor设置了图层的边缘线条的颜色以及宽度，正常情况下这两个属性在layer的层次上不怎么使用。后者cornerRadius设置圆角半径，这个半径会影响边缘线条的形状。

**4.shadowColor、shadowOpacity、shadowOffset和shadowRadius**

这四个属性结合起来可以制作阴影效果。shadowOpacity默认情况下值为0，这意味着即便你设置了其他三个属性，只要不修改这个值，你的阴影效果就是透明的。其次，不要纠结shadowOffset这个决定阴影效果位置偏移的属性为什么会是CGSize而不是CGPoint。

#### 2.图形绘制（基础属性、基础方法的使用介绍、使用场景、实例） 

CALayer的图形绘制有两种方法：

1.通过图层代理方法drawLayer:inContext进行图形绘制的。

2.使用drawInContext:方法，通过创建图层CALayer来进行自定义图层绘制。

需要注意的是调用这两种方法以后，必须调用setNeedsDisplay方法，否则无法显示内容。setNeedsDisplay方法的作用是移除旧的图层内容（contents），设置新的图层内容。

##### CALayer常用绘制：



##### 贝塞尔曲线：







 CALayer(和各种子类http://blog.csdn.net/iunion/article/details/26221213)  

CGContextRef  UIBezierPathhttp://www.cnblogs.com/small-octopus/p/4874600.html   

3.显示动画和隐式动画

### 3.Swift 写核心动画









http://ios.jobbole.com/85685/

## 二、UIViewAnimation

### 1.UIViewAnimation介绍





### 2.核心动画类





### 3.Swift 写UIViewAnimation





2.特效动画

## 三、长循动画

### 1.粒子动画



## 四、其他动画

### 1.控制器转场动画

##### 原理:UIViewControllerAnimatedTransitioning （过渡协调器） 

iOS7以后UIViewControllerAnimatedTransitioning或者UIViewControllerContextTransitioning这些协议已经可以比较方便的自定义ViewController之间的动画了，比如修改UINavigationController的动画，下面举个例子来看一看如何做一个自定义的NavigationController的Push和Pop非交互动画。

1.首先 我们定义一个类 TransitionOneManager 基于NSObject 实现 UIViewControllerAnimatedTransitioning 协议。

2.实现下面两个协议方法

```
//定义转场动画时间
- (NSTimeInterval)transitionDuration:(nullable id<UIViewControllerContextTransitioning>)transitionContext
//定义转场动画效果
- (void)animateTransition:(id<UIViewControllerContextTransitioning>)transitionContext 
```

3.定义两个控制器 分别是 ONE 和 TWO  ONE push 到TWO

在TWO中  实现 UINavigationControllerDelegate 实现下面方法

```
//这里返回的就是navigationController push 要使用的动画效果
- (id<UIViewControllerAnimatedTransitioning>)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC
{
  //在这里把 TransitionOneManager 实现的动画效果返回回去
}
```

4.在ONE 中 把 navigationController 的代理挂到TWO控制器上面，因为我们需要使用TWO中实现的push效果

```
self.navigationController.delegate = vc;
[self.navigationController pushViewController:vc animated:YES];
```

### 2.动力学

UIDynamic是苹果在iOS7之后添加的一套动力学框架，运用它我们可以极其方便地模拟现实生活中的运动，比如重力，碰撞等等。它是通过添加行为的方式让动力学元素参与运动的。

iOS7.0中提供的动力学行为包括：

UIGravityBehavior：重力行为
UICollisionBehavior：碰撞行为
UIAttachmentBehavior：附着行为
UISnapBehavior：吸附行为
UIPushBehavior：推行为
UIDynamicItemBehavior：动力学元素行为

UIDynamic的使用还是相对简单

1.首先我们创建一个小方块 boxView 并把它放在self.view的上面部分。（只有遵循了UIDynamicItem协议的对象才能参与仿真模拟，而UIView正遵循了此协议，因此所有视图控件都能参与仿真运动）

2.然后定义一个 UIDynamicAnimator 物理仿真器（凡是要参与运动的对象必须添加到此容器中）

```
_animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view]; //refrerence表示 self.view内都算仿真器范围
```

3.再添加一个重力行为 到仿真器,并且 这个行为作用对象是我们之前定义的boxView

```
[[UIGravityBehavior alloc] initWithItems:@[ boxView ]];
[_animator addBehavior:_gravity];
```

4.然后启动app，可以发现 放在self.view上半部分的boxView受重力行为影响，往下掉落。但是会掉出self.view范围。

5.为了不掉出self.view 范围 我们还需要给boxView添加一个别的行为：碰撞行为，接触到仿真器边界或者其他self.view中得容器会产生碰撞效果。

```
_collision = [[UICollisionBehavior alloc] initWithItems:@[ _behaviorView, _behaviorViewTwo ]];
_collision.translatesReferenceBoundsIntoBoundary = YES; //边界检测
[_animator addBehavior:_collision];
```

6.这样小方块就不会掉出仿真器范围了，同理，其他行为的使用方式和上面一样，一定要添加到仿真器才能生效。

http://ios.jobbole.com/89983/  

### 3.Facebook POP 动画框架

核心动画类中可以直接使用的类有：

POPSpringAnimation  有弹性效果的动画类 
POPBasicAnimation 基本动画类
POPDecayAnimation 衰减动画类
POPCustomAnimation 可以自定义动画的类

http://blog.csdn.net/zhang_red/article/details/48314043

http://www.cocoachina.com/industry/20140704/9034.html



## 五、常见问题

1、 如果当动画正在执行的时候, 将程序退出到后台, 那么当程序再次进入前台的时候就不执行了。

**原因**: 因为再次进入前台后动画已经被删除了。

**解决**: anim.removedOnCompletion = NO;

2、代理造成的循环引用问题 

**原因**：由于CAAnimation的delegate使用的strong类型，所以在全局变量如下设置时会产生循环引用的情况

self.animation.delegate = self;  //可通过复用dealloc方法来验证

**解决**：使用NSProxy解决，在一个对象中对self 弱引用处理  然后通过类方法把 弱引用处理过的self对象转给delegate  （YYWeakProxy）

3、.cornerRadius 属于layer层的参数，无法通过UIView animation来动画变更

```
    CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"cornerRadius"];
    basicAnimation.duration = 0.2;
    [self.animationView.layer setCornerRadius:20.0f];
    [self.animationView.layer addAnimation:basicAnimation forKey:@"cornerRadius"];
```

4、CGAffineTransformMakeRotation 使用的时候  如果直接frame变更 会导致形变 使用center的变更来变更位置就不会。

5、当UIView remove出父容器  UIView 会自动销毁  layer动画也是  但我们处理layer销毁的时候最好还是主动去remove掉动画



6、如何主动停止动画（UIView 动画  / 核心动画    通用）

removeAllAnimations 或者移除某个动画  

暂停/恢复：

```
if (self.imageViewOne.layer.speed == 0.0) {
  CFTimeInterval pausedTime = [self.imageViewOne.layer timeOffset];
  self.imageViewOne.layer.speed = 1.0;
  self.imageViewOne.layer.timeOffset = 0.0;
  self.imageViewOne.layer.beginTime = 0.0;
  CFTimeInterval timeSincePause = [self.imageViewOne.layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;
  self.imageViewOne.layer.beginTime = timeSincePause;
}else{

CFTimeInterval pausedTime = [self.imageViewOne.layer convertTime:CACurrentMediaTime() fromLayer:nil];
self.imageViewOne.layer.speed = 0.0;
self.imageViewOne.layer.timeOffset = pausedTime;
}
```

在一个动画过程中插入其他动画  阻塞？

7、在给UIView添加绘图delegate的时候的报错

不能再将某个UIView设置为CALayer的delegate，因为UIView对象已经是它内部根层的delegate，再次设置为其他层的delegate就会出问题。

ShapeLayer 设置代理也会出错

动画总结

http://www.ithao123.cn/content-2377425.html

http://www.cocoachina.com/ios/20141022/10005.html

https://www.objccn.io/issue-12-1/