---
layout: post
category: 学习之路
title:  "IOS 自动化布局" 
---



## 1.XIB AutoLayout

一个简单的例子  :   在XIB中 设置一个自己根据内容变化的竖向scrollview 

步骤：

1、在scrollview中添加一个contentView，edges equalTo scrollview

2、设置 contentView 的 width equal scrollview

3、在contentView里面添加需要展示的内容，保证可以根据内容推算出总高度。

比如：添加三个label，每个label左右0边距于contentView ，第一个距离顶部0 最后一个距离底下0 中间各自

margin 0 。

这种情况下contentView高度被推算，scrollView的contentSize也会自动推断。



## 2.代码 AutoLayout

代码写约束



Q1.让UIView跟着内部的UILabel自适应拉伸

例如 ： 让一个UIView 居于左上角 根据文字内容自动拉伸 

设置UIView的左边和上面约束 equal 

设置右边居于右屏幕边缘 greater than  margin

设置UIView的高度 greater than 最小高度

内部UILabel 设置 edges  equal 就可以了





## 3.Masonry 使用

使用 Masonry 设置一个自己根据内容变化的竖向scrollview 

1、在scrollview 中添加一个contentView，edges equalTo scrollview

2、设置 contentView 的 width equalTo scrollview

3、在contentView里面添加需要展示的内容并且上下各自equal ,左右 margin contentView 0

4、在添加完成最后一个后，把 contentView 的 bottom margin 更新到依赖最后一个view的 bottom

```
  1、
  [contentView makeConstraints:^(MASConstraintMaker *make) {
        make.edges.equalTo(self.scrollView);
        make.width.equalTo(self.scrollView);
    }];
   2、
      [contentView makeConstraints:^(MASConstraintMaker *make) {
        make.bottom.equalTo(lastView.bottom);
    }];
```





## 4.UIView更新机制

1、UIView的setNeedsDisplay和setNeedsLayout方法

首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到  UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，
 就可以  处理子视图中的一些数据。

综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便处理数据。

layoutSubviews在以下情况下会被调用：

1、init初始化不会触发layoutSubviews。
2、addSubview会触发layoutSubviews。
3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。
4、滚动一个UIScrollView会触发layoutSubviews。
5、旋转Screen会触发父UIView上的layoutSubviews事件。
6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。
7、直接调用setLayoutSubviews。

drawRect在以下情况下会被调用：

 1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).

2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。
3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。
4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。
以上1,2推荐；而3,4不提倡

drawRect方法使用注意点：

1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。
2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法
3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕



## 5.UITableView 碰上自动布局

UITableViewCell 如何 在不计算的情况下自适应高度,需要测试attributeString等耗时操作的影响

    第一步  给tableView设置估值高度 不要设置rowHeight  rowHeight返回方法也不要
    self.tableView.rowHeight = UITableViewAutomaticDimension;
    self.tableView.estimatedRowHeight = 200;
    
    第二步
    
     JDGGoldDetailCell *cell = [JDGGoldDetailCell cellWithTableView:tableView];
     //MARK:自动计算行高最关键的一步  cell一定要重新布局
     [cell layoutIfNeeded];
    
    第三步
    
    cell的layoutSubViews中更新cell内容 
    - (void)layoutSubviews {
        [super layoutSubviews];
    
        [self.imgview mas_makeConstraints:^(MASConstraintMaker *make) {
            make.centerY.mas_equalTo(self.contentView.mas_centerY);
            make.left.mas_equalTo(self.contentView.mas_left).offset(34);
            make.width.height.mas_equalTo(60);
        }];
        
        [self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.contentView.mas_top).offset(15);
            make.left.mas_equalTo(self.imgview.mas_right).offset(24);
            make.right.mas_equalTo(self.contentView.mas_right).offset(-20);
        }];
        
        [self.detailLabel mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.titleLabel.mas_bottom).offset(13);
            make.left.mas_equalTo(self.imgview.mas_right).offset(24);
            make.right.mas_equalTo(self.contentView.mas_right).offset(-25);
            
            //MARK:自动计算行高第四步---根据大家反映,更新后的代码
            make.bottom.mas_equalTo(self.contentView.mas_bottom).offset(-10);
        }];
        
    }
    




## warning !

1、IOS 自动化布局 masonry autolayout  等 尽量别混用

2、多看看masonry 官方 demo