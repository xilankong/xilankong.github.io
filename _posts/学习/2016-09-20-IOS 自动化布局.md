---
layout: post
category: 学习之路
title:  "IOS 自动化布局" 
---



## 1.XIB AutoLayout

一个简单的例子  :   在XIB中 设置一个自己根据内容变化的竖向scrollview 

步骤：

1、在scrollview中添加一个contentView，edges equalTo scrollview

2、设置 contentView 的 width equal scrollview

3、在contentView里面添加需要展示的内容，保证可以根据内容推算出总高度。

比如：

添加三个label，每个label左右依赖contentView ，第一个距离依赖顶部, 最后一个依赖底部 中间各自间距 0。

这种情况下contentView高度被推算，scrollView的contentSize也会自动推算。



## 2.代码 AutoLayout

代码写约束 : 让UIView跟着内部的UILabel自适应拉伸

例如 ：

让一个UIView 居于左上角 根据文字内容自动拉伸 

设置UIView的左边和上面约束 equal 

设置右边居于右屏幕边缘 greater than  margin

设置UIView的高度 greater than 最小高度

内部UILabel 设置 edges  equal 就可以了



## 3.Masonry 使用

使用 Masonry 设置一个自己根据内容变化的竖向scrollview 

1、在scrollview 中添加一个contentView，edges equalTo scrollview

2、设置 contentView 的 width equalTo scrollview

3、在contentView里面添加需要展示的内容并且上下各自equal ,左右 margin contentView 0

4、在添加完成最后一个后，把 contentView 的 bottom margin 更新到依赖最后一个view的 bottom

```
  1、
  [contentView makeConstraints:^(MASConstraintMaker *make) {
        make.edges.equalTo(self.scrollView);
        make.width.equalTo(self.scrollView);
    }];
   2、
      [contentView makeConstraints:^(MASConstraintMaker *make) {
        make.bottom.equalTo(lastView.bottom);
    }];
```





## 4.UIView更新机制

1、UIView的setNeedsDisplay和setNeedsLayout方法

首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到  UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，
 就可以  处理子视图中的一些数据。

综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便处理数据。

layoutSubviews在以下情况下会被调用：

1、init初始化不会触发layoutSubviews。
2、addSubview会触发layoutSubviews。
3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。
4、滚动一个UIScrollView会触发layoutSubviews。
5、旋转Screen会触发父UIView上的layoutSubviews事件。
6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。
7、直接调用setLayoutSubviews。

drawRect在以下情况下会被调用：

 1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).

2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。
3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。
4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。
以上1,2推荐；而3,4不提倡

drawRect方法使用注意点：

1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。
2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法
3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕



## 5.UITableView 碰上自动布局

UITableViewCell 如何 在不计算的情况下自适应高度,需要测试attributeString等耗时操作的影响

    第一步  给tableView设置估值高度 不要设置rowHeight  rowHeight返回方法也不要
    self.tableView.rowHeight = UITableViewAutomaticDimension;
    self.tableView.estimatedRowHeight = 200;
    
    第二步
    
     JDGGoldDetailCell *cell = [JDGGoldDetailCell cellWithTableView:tableView];
     //MARK:自动计算行高最关键的一步  cell一定要重新布局
     [cell layoutIfNeeded];
    
    第三步
    
    cell的layoutSubViews中更新cell内容 
    - (void)layoutSubviews {
        [super layoutSubviews];
    
        [self.imgview mas_makeConstraints:^(MASConstraintMaker *make) {
            make.centerY.mas_equalTo(self.contentView.mas_centerY);
            make.left.mas_equalTo(self.contentView.mas_left).offset(34);
            make.width.height.mas_equalTo(60);
        }];
        
        [self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.contentView.mas_top).offset(15);
            make.left.mas_equalTo(self.imgview.mas_right).offset(24);
            make.right.mas_equalTo(self.contentView.mas_right).offset(-20);
        }];
        
        [self.detailLabel mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.titleLabel.mas_bottom).offset(13);
            make.left.mas_equalTo(self.imgview.mas_right).offset(24);
            make.right.mas_equalTo(self.contentView.mas_right).offset(-25);
            
            //MARK:自动计算行高第四步---根据大家反映,更新后的代码
            make.bottom.mas_equalTo(self.contentView.mas_bottom).offset(-10);
        }];
        
    }



## 6.自动布局中的约束优先级

UIView 有两个类别的content优先级

Content Hugging Priority 确定view有多大的优先级阻止自己变大。 默认 250 （例如保证UIButton不会因为屏幕边距变大而拉伸按钮）

Content Compression Resistance Priority 确定有多大的优先级阻止自己变小。 默认 750（例如保证UILabel不会被挤压导致显示不全）优先级越大 越不会被压缩

说这个之前先了解一些信息：

这两个属性对有intrinsic content size的控件（例如button，label）非常重要。通俗的讲，具有intrinsic content size的控件自己知道（可以计算）自己的大小，例如一个label，当你设置text，font之后，其大小是可以计算到的。

```
UIView中关于Content Hugging 和 Content Compression Resistance的方法

- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

```


默认优先级情况下从左到右，从上到下优先。 默认情况下两边的label的Content Hugging和Content Compression优先级都是一样的。

**Q1 : 当一个View 高度需要根据内容来扩张，那么内部label 和 view的优先级怎么判断 有什么不同吗？**

**A1 : 没有, 根据优先级来。**

**测试出现的情况：**

1.当xib的View中加了两个默认的Label 并自动计算高度适配，再通过代码在底下继续加上Label 的时候 label需要更改收缩优先级来保证他完整显示。(依然未解)

2.但是直接在xib中加入多个label，并设定好约束，label会正常扩张，父view也会正常扩张。

3.在 2 的基础上 再在底下通过代码添加的label 设定好masonry约束 同样能正常显示，正常扩张

4.一个View中 由上到下分别是 label、label、view（里面有一个label） 的布局，自动布局也可以正常扩张

5.hidden 并不会影响约束



## warning !

1、IOS 自动化布局 masonry autolayout  等 尽量别混用

2、多看看masonry 官方 demo

3、masonry 的约束优先级的作用  和content优先级有什么区别