1.数组创建方法

```
可以通过以下方式设置空数组，必须让array知道自己的类型
var array = [String](); 
var array: [String] = []
或者不赋值，但是要声明类型
var array: [String]!

var array = Array(repeating:0,count:5);  -> [0,0,0,0,0]
数组可以直接相加 直接加数组 
var anotherThreeDoubles = Array(repeating: "2.5", count: 2)
var sixDoubles = anotherThreeDoubles + anotherThreeDoubles
// sixDoubles类型是 [String], 包含元素:["2.5", "2.5", "2.5", "2.5"]
sixDoubles = sixDoubles + ["2.5"]


array = array + ["111","222","333"]
array[0...1] = ["444","555"];
print(array)
结果: ["444", "555", "333"]
array = array + ["111","222","333"]
array[0...2] = ["444","555"]; // 0...2 size 为3 ，后面数组size为 2
print(array)
结果: ["444", "555"]  //并不会出现两边因为数组size不一样产生错误，以更小size为准

但是数组中只能存储同一类型的数据

数组常用方法
insert(_:at:): 在某个位置插入元素  不能超出数组大小
remove(at:): 移除某个位置的元素
removeLast(): 移除最后一个元素
enumerated(): 该方法返回一个包含索引和对应位置的值的元祖(tuple)数组(Example)。

for item in array {
    print("----\(item)")
}
或者   \\如果需要元祖的方式获取index 加 item 就需要使用下面这种方式
for (index,item) in array.enumerated() {
    print("\(index)----\(item)")
}
```

2.数组的遍历

```
// 遍历数组
for i in 0..<array.count {
    print(array[i])
}
// forin 方式
for item in array {
    print(item)
}
// 设置遍历的区间
for item in array[0..<2] {
    print(item)
}
// enumerated 遍历
for en in array2.enumerated() {
    print(en)
    // 下标
    print(en.offset)
    // 值
    print(en.element)
}
// 下标和数值同时遍历   元祖
for (n,s) in array2.enumerated() {
     print(n , "==", s);
}
// 反序遍历
for s in array2.reversed() {
    print(s)
} 
// 遍历下标和数值 反序
for (xxx,ooo) in array2.enumerated().reversed() {
    print(xxx ,"====" ,ooo)
}
```

3.字典创建方法

```
字典构建方法  [:]    var dic: [String : String]!

var dict : [String : String] = [:] 表示空字典
 
var dict : Dictionary<String,String> = Dictionary.init();

var airports : Dictionary<String, String> = ["TYP":"Tokyo", "DUB":"Boublin"]

var airports2 = ["TYP":"Tokyo", "DUB":"Boublin"]

var empty_dic = Dictionary<String, String>()
```







4.swift 和 oc 交互 

```
swift 和 OC 混用会有两个新文件 

1、工程名-Swift.h 是 用于 oc 调用 swift 、是swift代码在工程中自动更新出的oc格式代码
 不可见，但是可以跳转进入，所有swift代码生成的类属性 都会在这个文件中转义一份oc的样式 

2、工程名-Bridging-Header.h 是用于 swift 调用 oc 的头文件，所有需要引入swift的OC都需要先在这个文件引入。

```



5.swift 进入oc  oc 进入swift  swift 有命名空间  名字会有区别

```
swift的类名 转成 oc 自带了格式，并非直接名字。所以通过class去寻找指定类需要转className

在swift根据类名找xib也需要注意命名空间，一般式工程名.类名

//获取xib
  class func nib() -> UINib {
      let className = NSStringFromClass(self)
      let postfix = className.components(separatedBy: ".").last
      return UINib(nibName: postfix!, bundle: nil)
  }

//获取对应className
- (Class)swiftClassFromString:(NSString *)className {

  	NSString *appName = 
  	[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"];
	NSString *classStringName = 
	[NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className];
  	return NSClassFromString(classStringName);

}
```



http://stackoverflow.com/questions/24030814/swift-language-nsclassfromstring

http://www.cnblogs.com/godlovexq/p/5293027.html



6. swift3.0 新特性

```
@noescape   变成默认属性

@escaping 逃逸闭包

逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行

@autoclosure 自动闭包

(1)默认非逃逸

(2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。

(3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。

(4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。

(5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。

(6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明: @autoclosure @escaping 旧版本：@autoclosure(escaping)

声明函数时，在参数前面用inout修饰，在函数内部实现改变外部参数,方法调用的时候参数需要 &  (&在形参中表示“引用”实参)

var str = "789789"
getOne(&str)
print(str)

func getOne(_ b:inout String){
    b = "123456"
}
结果：123456
```

8.swift  闭包懒加载按钮 不能先给target  

9.swift lazy属性

    //定义一个闭包
    lazy var html: () -> String = {
       if let text = self.text {
            return "11111";
        } else {
            return "2222";
        }
    }
    //定义一个字符串
    lazy var second:String = {
        if let text = self.text {
            return "11111";
        } else {
            return "2222";
        }
    }()  //不要忘记最后的小括号，只有加了小括号，必包才会在掉用的时候立刻执行。
    	//要类型声明lazy var second:String，这样Xcode会进行类型检查。

​    


     懒加载初始化的定义
     懒加载初始化只进入一次  并且在需要的时候才调用
     在Objective C中， 懒加载初始化是这样写的
     @property (strong,nonatomic) CAShapeLayer * shapelayer;
      -(CAShapeLayer *)shapelayer{   
      if (!_shapelayer) {       
       		_shapelayer = [CAShapeLayer layer];    
       }    
           return _shapelayer;
        }
    
    那么何为 懒加载初始化呢？ 
    
    从OC的代码中不难看出， 懒加载初始化，就是在变量第一次使用的时候才进行初始化。
    
    Swift中，有两种方式来 懒加载初始化。 
    
    第一种，简单表达式
    
    lazy var first = NSArray(objects: "1","2")
    
    第二种，闭包
    
    lazy var second:String = {return "second" }()
    
    懒加载初始化的使用场景
    
    1、属性本身依赖于外部因素才能初始化 
    completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀
    class Demo{    
    var url:NSString   
    lazy var completeURL:NSString = {       
       [unowned self] in       //防止闭包循环
       if self.url.hasPrefix("http://"){           
         return self.url        
      }else{            
         return "http://".stringByAppendingString(self.url)        
      }        
    }()    
    
    init(url:NSString){       
     self.url = url    
    }}
    
    2、属性需要复杂计算，消耗大量CPU
    
    lazy var second:Int = {       
    	var sum = 0        
    	for i in 1...100000{ sum += i}        
    	return sum        
    }()
    
    3、属性不确定是否会使用到
    
    官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化。
    
    4、定制化的初始化 
    
    有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护
    
    lazy var dataArray:NSMutableArray = {
      var array = NSMutableArray()        
      for  i in 1...100{
        array.addObject(NSNumber(integer: i))        
      }        
      return array        
    }()



10.Use Legacy Swift Language Version  错误    

在project  和target 吧 SWIFT_VERSION   Use Legacy Swift Language Version   这个属性改成NO就可以了



11. 自定义表达式

```
infix  prefix  postfix 自定义表达式  实现 swift3.0  

比如定义一个  ** 表达式  

infix operator **   //这句话只能定义在文件，类的外面，其余类可以针对这个定义 做不同实现

//下面这里 实现是类似 ?? 方法 ，扩展optional    实现这么一个方法   static 方法

extension Optional {

	static func ** <T>(optional : T? , defaultValue : @autoclosure () -> T) -> T {}

}
```

12.weak 和 unowned 闭包内部防止循环引用

“用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 "无效的" 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。”

swift 打印内存地址

```
print(Unmanaged<AnyObject>.passUnretained(spacetwo as AnyObject).toOpaque())
```

swift 等号判断

```
var a: NSString = "abc", b = a, c: NSString = "abc"  
  
println(a == b) //true  
println(a == c) //true  
println(a === b) //true  
println(a === c) //false ＝＝＝ 运算符可以判断是否对同一对象的引用   比较内存地址
```



swift 代码补全

http://www.jianshu.com/p/bbbfc524ca93



13.注释

    // MARK: - 操作
    // TODO: - 记得做
    // FIXME: - 提醒



14.

NS_DESIGNATED_INITIALIZER   指定某个OC方法为 designated initializer  因为swift  继承oc类出来 实现init方法外必须要实现一个designated init方法 

15.

宏和 const static 的区别 多用static



16.

swift 不能调用oc 类方法

17.

swift delegate 代理调用 不再使用resonse响应去校验方法是否存在

直接optional去调用就可以  

  self.delegate?.GXQActionSheetClickAtIndex(index: type!, viewController: self)

**18.swift 枚举 和 oc枚举**

```
swift 枚举 
    var result = Planet.One;
    result = .two;
    switch result {
      case .one:
       print("执行One");
      case .two:
       print("执行Two");
      default:
       print("执行Default");
    }

元祖 枚举
 enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
    
    //元祖的方式可以把枚举作为一个计算类了，可带参数进switch的方便 
    //例如二维码和条码的大类，我们有N个不同的码，可能是二维码 也可能是条码
    //但是每个二维码又不一样的情况 我们就需要按大类判断。
    //没有元祖之前我们处理这个问题就是定义两个继承类 分别代表二维码和条码，都有一个枚举属性，通过这个属性来区分判断。？？？？？
    var productBarcode = Barcode.upc(8, 85909, 51226, 3)
    productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
    
    switch productBarcode {
    case .upc(let numberSystem, let manufacturer, let product, let check):
        print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
    case .qrCode(let productCode):
        print("QR code: \(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."
    
```

**OC枚举方式 :**

typedef NS_ENUM  推荐使用

typedef enum

**swift枚举方式 :**

```
@objc enum FPCheckResult: NSInteger{
    case success         //成功
    case sailed          //失败
    case passcodeNotSet //未设置手机密码
    case touchidNotSet  //未设置指纹
    case touchidNotAvailable //不支持指纹
}大驼峰命名名称 小驼峰命名成员

swift 定义的枚举在OC中使用 会自动把枚举名字添加到前面做前缀  比如FP_SUCCESS 适配在OC中是 FPCheckResultSuccess

不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的FPCheckResult例子中，Success，Failed，PasscodeNotSet和TouchidNotSet不是隐式得等于0，1，2和3。相反的，这些不同的枚举成员在FPCheckResult的一种显示定义中拥有各自不同的值。

oc 定义的枚举  大驼峰命名规则
注意：OC中定义的枚举在OC中可以不需要通过枚举名字获取，但在swift中需要用枚举.方法获取，所以把枚举名字写在枚举变量前面做前缀， swift解析的时候会自动去掉前缀。既方便oc又方便swift。
typedef NS_ENUM(NSInteger, FundType) {
    FundTypeMonetary   = 1,//公募货币基金
    FundTypeBond       = 2,//公募债基基金
};

多个成员值可以出现在同一行上，用逗号隔开：
enum Planet { 
    case mercury, venus, earth, mars, jupiter, saturn, uranus, nepturn 
} 

var directionToHead = CompassPoint.west 

一旦一个熟悉 被定义成一个枚举后，如上，或者switch 指定等。 就可以直接用点方法给属性设置其他枚举成员。



下面的枚举是对之前Planet这个枚举的一个细化，利用原始整型值来表示每个 planet 在太阳系中的顺序：
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
自动递增意味着Planet.venus的原始值是2，依次类推。
 
使用枚举成员的rawValue属性可以访问该枚举成员的原始值：
let earthsOrder = Planet.earth.rawValue 
// earthsOrder is 3 

通过rawValue去获取对应枚举成员
let possiblePlanet =Planet(rawValue: 7)
// possiblePlanet is of type Planet? and equals Planet.Uranus 
```

如果需要在oc中使用swift定义的枚举 需要加上 @objc前缀  如果是swift定义的协议 也是一样的

19.

swift 自定义运算符

新的运算符声明需在全局域使用operator关键字声明，可以声明为前置，中置或后置的。

当之前定义过的运算符 可以直接重载成其他参数类型 

```
func += <K,V>( left:inout [K:V], right:[K:V] ) {
    right.forEach { (key, value) in
        left.updateValue(value, forKey: key)
    }
}
func + <K,V>(left: [K:V], right:[K:V]) -> [K:V] {
    var result = left
    result += right
    return result
}
```

20.

swift写法

```

- (NSString *)cellIdentify{
    return @{@(HomeItemTypeAssetsHead).stringValue:@"AssetsHeadTableViewCell",
             @(HomeItemTypeRedPacket).stringValue:@"NewUserRedPacketTableViewCell",
             @(HomeItemTypeIntroduce).stringValue:@"IntroduceTableViewCell",
             @(HomeItemTypeProduct).stringValue:@"GXQRecommendProductCell",
             @(HomeItemTypeNotice).stringValue:@"HomeNoticeTableViewCell",
             @(HomeItemTypeAssetsCell).stringValue:@"HomeAssetsTableViewCell",
             @(HomeItemTypeXueBi).stringValue:@"HomeXuebiTableViewCell",
             @(HomeItemTypeCarousel).stringValue:@"HomeCarouselTableViewCell"}
    [@(self.type).stringValue];
}
```

21.

函数式

```
var newEvens = [Int]()
for i in 1...10 {
  if i % 2 == 0 {
         newEvens.append(i)
    } 
}
print(newEvens) // [2, 4, 6, 8, 10]

可以写成

var evens = Array(1...10).filter { $0 % 2 == 0 } 
print(evens) 
// [2, 4, 6, 8, 10]

```

22.

swift 绑定xib的时候 不能直接用className 去查找对应nib  因为swift存在域名 前面有工程名的前缀

swift viewController xib初始化的时候要实现init（）里面super.init（根据xib名字去初始化）

23.

        topImageView.mas_makeConstraints {
            $0?.top.leading().bottom().equalTo()(self)
            $0?.width.equalTo()(self.bgImageView.mas_width)?.multipliedBy()(0.0)
        }
        
        1.msonry可以校验宽度，比如占父类百分之多少宽度
        2.swift $0? 参数
        3.msonry可以校验宽度会引发的问题
        4.make.leading.equalTo(leftView.mas_trailing);  mas_right 和 mas_trailing 不是同一个东西，一套不能和另一套混用
柯里化

24.

swift 异常捕获

25.

swift强类型  float 和 int 不能相减



26. swift命名规则

```
对类、结构体、枚举和协议等类型命名，应该采用大驼峰法，如SplitViewController。

文件名，采用大驼峰法，如BlockOperation.swift。

扩展文件，有的时候扩展是定义在一个独立的文件中的，它的命名是“原始类型名+扩展名”作为扩展文件名，如NSOperation+Operations.swift。

变量和属性，采用应该采用小驼峰法，如studentNumber。

常量，采用大驼峰法，如MaxStudentNumber。

枚举成员，与常量类似，采用大驼峰法，如ExecutionFailed。

函数和方法，采用应该采用小驼峰法，如balanceAccount、isButtonPressed等。
```

27.

```
var nameOne: String?
nameOne = "one"
if let name = nameOne {
    print(name)
}
如果变量的可选值是 nil ，条件会判断为 false ，并且大括号中的代码会被跳过。如果不是nil，会将值赋给let后面的常量，这样代码块中就可以使用这个值了。

```

28.switch

```
使用switch 支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。
运行 switch 中匹配到的子句之后，程序会退出switch语句，并不会继续向下运行，所以不需要在每个子句结尾写break。

let age = 15
switch age {
case 0...10:
    print("000")
case let x:
    print(x)
default:
    print("111")
}

一定要有必执行项 （default，let x 这种）不然编译错误：switch must be exhaustive

fallthrough:【紧跟的后一个】case条件不能定义常量和变量
fallthrough 后面项不能是let x


```

29.for循环

```
for num in 0...3 {
    print(interestingNumbers[num])
}
和
for num in 0..<3 {
    print(interestingNumbers[num])
}
的区别 ... 指0到3之间包括下界(1，2，3，4) , ..< 不包括下界(0，1，2)
        
        
```

30.泛型

```
extension Array {
//Element 这个地方使用Element的原因是array中默认元素类型是Element
    public func my_map<T>(_ element: (Element) -> T) -> [T] {
        var array_new = Array<T>()
        for item in self {
            let item_new = element(item)
           array_new.append(item_new)
        }
        return array_new
    }
}

限制泛型类型，例如所有的泛型参数都要实现 NameSpaceProtocol 协议，如下两种写法
func getTwo<T>(_ E : T) where T : NameSpaceProtocol{
}
func getTwo<T : NameSpaceProtocol>(_ E : T){
}


```

31.类

```
子类的定义通过 : 后面紧跟父类名称的方式。
当然不是每个类都需要标准的根类，所以可以忽略父类。


关于初始化的继承
规则 1
如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。

规则 2
如果子类提供了所有父类指定构造器的实现--不管是通过规则1继承过来的，还是通过自定义实现的--它将自动继承所有父类的便利构造器。因为便利构造器都是基于指定构造器的
```

32.结构体

```
使用方法和类差不多

struct NameSpaceTwo {
    var length: Int
    var height: Int
    
    func countTwo() -> Int {
        return height + length
    }
}

和类的区别
 struct 是 Value Type 而 class 是 Reference Type ， Value Type是值类型，reference type 是引用类型
 
在每次做 assignment 的時候，value type 都会复制一份完整相同的內容給另一個变量，而 class 則是把内容对应的内存地址給变量。

let spacetwo = NameSpaceTwo(protocolParam: "8888", length: 5, height: 5)
let spacethree = spacetwo

print(Unmanaged<AnyObject>.passUnretained(spacethree as AnyObject).toOpaque())
print(Unmanaged<AnyObject>.passUnretained(spacetwo as AnyObject).toOpaque())

let 的方式的 struct 内部参数不能改变

spacethree 和 spacetwo 的改变都不会对对方产生影响。



mutating 关键字
使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。

```

33.协议

``` 
协议中定义的方法，依然是不能有方法体，协议可以设置参数，参数必须要设置{get} 或者 {get set}

使用 extension 为现有的类型添加功能，比如添加一个计算属性的方法。你可以在任何地方使用 extension 来给任意类型添加协议，甚至是从外部库或者框架中导入的类型。

你可以像使用其他命名类型一样，创建一个有不同类型但是都实现同一个协议的对象集合。当你处理协议类型的值时，协议外定义的方法不可用。都被当成协议类型对象处理

```

34.类型转换

```
swift 中没有 toInt toString等转换方法

let convertedNumber = Int(b)
print(convertedNumber ?? "")


如果 possibleNumber不能转换，将为 nil

在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针，它是一个确定的值，用来表示值的缺失。任何类型的可选都可以被设置为 nil，不只是对象类型。

```

35.断言 

```
release 情况  断言在 swift 无效 断言错误信息有在控制台打出，oc正常
```

36.swift   get set 

```
var count: String {
       return ""
}


var _count: String = ""  //防止循环引用
var count: String {
    get {
        return _count
    }
    set {
        _count = newValue;
    }
}
```

37.变量定义

```
var count: String {
    return ""
}
上面这种不用等号的方式，  下面这张使用了等号，那么左右两边类型必须一样，而右边给了一个闭包，显然和String类型不一样，所以闭包需要执行，并返回里面的内容 "" 保证两边类型一致
var count: String = {
    return ""
}()

```

38. swift 少用类型强转换  as！ 多做类型判断 






参考文献

[Swift3.0中文文档（非最新）](http://www.cocoachina.com/industry/20140613/8818.html)

[Swift3.0官方文档](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)