

IOS 动态库和静态库的区别

https://www.gitbook.com/book/leon_lizi/-framework-/details

动态库

.framework 

在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑（见这里的讨论)。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。

由于上面提到的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如微信的SDK）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。于是人们想出了各种奇技淫巧去让 Xcode Build 出 iOS 可以使用的 Framework，具体做法参考这里和这里，这种方法产生的 Framework 还有 “伪”(Fake) Framework 和 “真”(Real) Framework 的区别。

iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以），上面提到的的奇技淫巧也就没有必要了（新的做法参考这里）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。

tips : 在 swift 中 需要import到代码中，即使是OC库，在swift桥接文件中引入了。



静态库

.a

静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。

静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。



使用静态库的好处

1，模块化，分工合作

2，避免少量改动经常导致大量的重复编译连接

3，也可以重用，注意不是共享使用

动态库使用有如下好处：

1使用动态库，可以将最终可执行文件体积缩小

2使用动态库，多个应用程序共享内存中得同一份库文件，节省资源

3使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。



首先通过新建菜单的 Framework & Library 创建一个 Cocoa Touch Framework 项目，命名为 HelloKit，然后添加一个 Swift 文件以及随便一些什么内容，比如：


    public class Hello {
    public class func sayHello() {
        print("Hello Kit")
    }
    }

注意我们在这里添加了 public 声明，这是因为我们的目的是在当前 module 之外使用这些代码。将运行目标选择为任一 iOS 模拟器，然后使用 Shift + Cmd + I 进行 Profiling 编译。编译完成后在工程product文件夹 进入后选取对应的模拟器对应文件夹  里找到对应的 HelloKit.framework。

如果直接使用 Cmd + B 进行编译的话我们得到的会是一个 Debug 版本的结果，在绝大多数情况下这应该不是我们想要的，除非你是需要用来进行调试。

然后新建一个项目来看看如何使用这个框架吧。建立新的 Xcode 项目，语言当然是选择为 Swift，然后将刚才的 HelloKit.framework 拖到 Xcode 项目中就可以了。我们最好勾选上 Copy items if needed，这样原来的框架的改动就不会影响到我们的项目了。

接下来，我们在需要使用这个框架的地方加上对框架的导入和调用。为了简单，我们就在 AppDelegate.swift 的 didFinishLaunching 方法中对 sayHello 进行一次调用：


    func application(application: UIApplication!,
    didFinishLaunchingWithOptions launchOptions: NSDictionary!) -> Bool {
    // Override point for customization after application launch.
    Hello.sayHello()
    return true
    }

当然，别忘记在顶部加上 import HelloKit 来导入框架。



但是故事还没有最终结束。我们刚才编译的时候只做了模拟器的版本，如果你尝试一下在 app 项目中将目标切换为真机的话，会发现根本无法编译，这是由于模拟器和实际设备所使用的架构不同导致的。我们需要回到框架项目中，将编译目标切换为 iOS Device，然后再次使用 Shift + Cmd + I 进行编译。这时我们可以在工程product文件夹 进入后选取对应的真机对应文件夹   Release-iphoneos 文件夹下得到真实设备可以使用的框架。最后我们通过 lipo 命令将适用于多个架构的二进制文件进行合并，以得到可以在模拟器和实际设备上通用的二进制文件：


       lipo -create -output HelloKit \
       Release-iphoneos/HelloKit.framework/HelloKit \
       Release-iphonesimulator/HelloKit.framework/HelloKit
然后将得到的包含各架构的新的 HelloKit 文件复制到刚才的模拟器版本的 HelloKit.framework 中 (没错其实它是个文件夹)，覆盖原来的版本。最后再将 Release-iphoneos 中的框架文件里的 /Modules/HelloKit.swiftmodule 下的 arm.swiftmodule 和 arm64.swiftmodule 两个文件复制到模拟器版本的对应的文件夹下 (这个文件夹下最终应该会有 i386，x86_64，arm 和 arm64 四个版本的 module 文件)。我们现在就得到了一个通吃模拟器和实际设备的框架了，用这个框架替换掉刚才我们复制到 app 项目中的那个，app 应该就可以同时在模拟器和设备上使用这个自制框架了。

再次提醒，本文所述的用 Swift 构建框架项目，然后在其他项目中使用这个框架的做法并不是推荐做法。对于 Objective-C 来说这个做法没有什么太大问题，但是对于 Swift 的框架来说，因为现在 Swift 的解释和运行环境还没有非常稳定，因此在项目中使用非同项目 target 的框架的时候，很有可能项目和框架的 Swift 运行环境 有所差异。有时候这会导致不必要的问题和麻烦。







oc 项目同时引入oc库和swift

在 bridge 中  多引用一个Foundation的库

```
#import <Foundation/Foundation.h>
#import <Masonry/Masonry.h>
```

Swift和Objective-C Mixed 混编pod







## Quick（TDD,BDD）

TDD,BDD及初步使用Quick http://www.jianshu.com/p/95e84dcada56

测试驱动开发(Test Driven Development，以下简称TDD)是保证代码质量的不二法则，也是先进程序开发的共识。

Quick + Nimble ： http://blog.csdn.net/lym594887256/article/details/51441625

```
//
//  ViewControllerSpec.swift
//  SwiftDemo
//
//  Created by yanghuang on 17/2/9.
//  Copyright © 2017年 com.jinfuzi. All rights reserved.
//


import Quick
import Nimble
import SwiftDemo // 工程名字 开始测试  win + u

class ViewControllerSpec: QuickSpec {
    override func spec() {
        // context用于指定条件或状态
        
        describe("a dolphin") {
            var dolphin : Dolphin!
            
            it("can it eat more", closure: { 
               dolphin = Dolphin(canEat2: 4)
               dolphin.eat()
               expect(dolphin.isEnough()).to(equal(status.notHungry))//断言
                
            })
            
        }
    }
    
    
    class ViewControllerSpec: QuickSpec {
    override func spec() {
        // context用于指定条件或状态
        
        describe("a dolphin") {
            var dolphin : Dolphin!
            beforeEach {
                dolphin = Dolphin(canEat2: 4)
            }
            describe("section eat", {
                beforeEach {
                  dolphin.eat()  //要在beforeEach中执行 ，不然空指针错误
                }
                it("can it eat more", closure: {
                    expect(dolphin.isEnough()).to(equal(status.notHungry))
                    
                })
                
            })

        }
    }
}
    

```




Xcode单元测试基本用法及Quick进一步介绍 http://www.jianshu.com/p/cba66a8e6bf1



Mocking in Swift http://www.jianshu.com/p/e2dd3fcccad4



## SwiftJSON

同 JSONSerializationSwiftyJSON 相比，在获取多层次结构的JSON数据时。SwiftyJSON不需要一直判断这个节点是否存在，是不是我们想要的class，下一个节点是否存在，是不是我们想要的class…。同时，SwiftyJSON内部会自动对optional（可选类型）进行拆包（Wrapping ），大大简化了代码。

tips 

        当JSON 就只有一个部分时 不需要JSON[0]["name"] 取值  直接JSON["name"]
        let jsondata = "{\"name\" : \"小米\"}"
        //字符串转Data
        var data = jsondata.data(using: String.Encoding.utf8, allowLossyConversion: false)
        var json = JSON(data: data!)
        print(json["name"])
        
        let jsonStr = "[{\"name\": \"hangge\", \"age\": 100, \"phones\": [{\"name\": \"公司\",\"number\": \"123456\"}, {\"name\": \"家庭\",\"number\": \"001\"}]}, {\"name\": \"big boss\",\"age\": 1,\"phones\": [{ \"name\": \"公司\",\"number\": \"111111\"}]}]"
        但当JSON为复杂数组的时候  通过 JSON[0]["name"] 可以取第一部分的json中得name属性


swiftJSON 赋值 

```
let jsondata = "[{\"name\" : \"小米\"}]"
        var data = jsondata.data(using: String.Encoding.utf8, allowLossyConversion: false)
        var json = JSON(data: data!)

        json[0]["type"] = "sss"
        print(json.rawString())
```

http://www.hangge.com/blog/cache/detail_968.html





## DZNEmptyDataSet



tips : customViewforEmptyDataSet  直接返回View的时候显示不出来 默认都没有颜色，会进行二次处理



使用customViewforEmptyDataSet  的时候会忽略offset和verticalOffset两个的作用





## Charts

http://www.jianshu.com/p/45194d861b21

表格  常用



## MGSwipeTableCell

侧滑功能cell