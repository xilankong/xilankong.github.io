---
layout: post
category: 学习之路
---

tag:

1.cornerRadius 属于layer层的参数，无法通过UIView animation来动画变更

```
    CABasicAnimation *basicAnimation = [CABasicAnimation animationWithKeyPath:@"cornerRadius"];
    basicAnimation.duration = 0.2;
    [self.animationView.layer setCornerRadius:20.0f];
    [self.animationView.layer addAnimation:basicAnimation forKey:@"cornerRadius"];
```

2.CGAffineTransformMakeRotation 使用的时候  如果直接frame变更 会导致形变 使用center的变更来变更位置就不会。

3.CAAnimation 的代理

```
CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @"position.x";
animation.fromValue = @(15);
animation.toValue = @(SCREEN_WIDTH-15);
animation.duration = 1.0f;
animation.autoreverses = YES;
animation.repeatCount = HUGE_VAL;

// 保证fillMode起作用
// flyRight.removedOnCompletion = false
// 动画结束后,layer会保持结束状态
// flyRight.fillMode = kCAFillModeForwards
animation.delegate = self;
[self.imageViewOne.layer addAnimation:animation forKey:@"p_img_one"];


-(void)animationDidStart:(CAAnimation *)anim
{
    NSLog(@"start");
}
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag
{
    NSLog(@"stop");
}
```



4.当UIView remove出父容器  UIView 会自动销毁  layer动画也是  但我们处理layer销毁的时候最好还是主动去remove掉动画



5.如何主动停止



UIView 动画  / Layer动画    通用

removeAllAnimations 或者移除某个动画  



暂停/恢复：

    if (self.imageViewOne.layer.speed == 0.0) {
      CFTimeInterval pausedTime = [self.imageViewOne.layer timeOffset];
      self.imageViewOne.layer.speed = 1.0;
      self.imageViewOne.layer.timeOffset = 0.0;
      self.imageViewOne.layer.beginTime = 0.0;
      CFTimeInterval timeSincePause = [self.imageViewOne.layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime;
      self.imageViewOne.layer.beginTime = timeSincePause;
    }else{
    
    CFTimeInterval pausedTime = [self.imageViewOne.layer convertTime:CACurrentMediaTime() fromLayer:nil];
    self.imageViewOne.layer.speed = 0.0;
    self.imageViewOne.layer.timeOffset = pausedTime;
    }
在一个动画过程中插入其他动画  阻塞？



6.CA动画 基本 key path 

position.x 针对的时center



## 一、CAAnimation

### 1.核心动画介绍

#### 1.什么是核心动画

Core Animation可以用在 Mac OS X 和 iOS平台. Core Animation的动画执行过程是在后台操作的.不会阻塞主线程. 要注意的是, Core Animation是直接作用在CALayer上的.并非UIView。

动画操作过程：

1、创建一个CAAnimation对象

2、设置一些动画的相关属性

3、给CALayer添加动画（addAnimation:forKey: 方法）

4、移除CALayer中得动画（removeAnimationForKey: 方法）

总体来说核心动画的优点有：

1、性能强大，使用硬件加速，可以同时向多个图层添加不同的动画效果

2、接口易用，只需要少量的代码就可以实现复杂的动画效果。

3、运行在后台线程中，在动画过程中可以响应交互事件（UIView动画默认动画过程中不响应交互事件）。（ CALayer不响应用户事件？）



#### 2.核心动画类

![png](https://xilankong.github.io/resource/animtion_tree.png)

CAAnimation是所有动画对象的父类，实现CAMediaTiming协议，负责控制动画的时间、速度和时间曲线等等，是一个抽象类，不能直接使用。

CAPropertyAnimation ：是CAAnimation的子类，它支持动画地显示图层的keyPath，不直接使用。

综上，核心动画类中可以直接使用的类有：

1. CABasicAnimation  基础动画

2. CAKeyframeAnimation  关键帧动画

3. CATransition 转场动画

4. CAAnimationGroup 组动画

5. CASpringAnimation 弹性动画 （iOS9.0之后新增CASpringAnimation类，它实现弹簧效果的动画，是CABasicAnimation的子类。）

#### 1）CAAnimation

##### 属性：

1. duration：动画的持续时间，默认为0.25秒

2. repeatCount：动画的重复次数

3. repeatDuration：动画的重复时间

4. removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode属性为kCAFillModeForwards

5. fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后

6. beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间

7. timingFunction：速度控制函数，控制动画运行的节奏

   枚举参数：

   ```
   kCAMediaTimingFunctionLinear  时间曲线函数，匀速
   kCAMediaTimingFunctionEaseIn  时间曲线函数，由慢到特别快
   kCAMediaTimingFunctionEaseOut  时间曲线函数，由快到慢
   kCAMediaTimingFunctionEaseInEaseOut  时间曲线函数，由慢到快
   kCAMediaTimingFunctionDefault   系统默认
   ```

8. delegate：动画代理，一般设置隐式代理，该代理是NSObject的分类，需要遵守协议CAAnimationDelegate

   （1）`- (void)animationDidStart:(CAAnimation *)anim;`核心动画开始时执行
   （2）`- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;`核心动画执行结束后调用

#### 2）CAPropertyAnimation

##### 属性：

1.keyPath参数：通过指定CALayer的一个属性名做为keyPath里的参数(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。
比如：

CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"position.y"];

#### 一些常用的animationWithKeyPath值的总结

| 值                       | 说明                  | 使用形式                                     |
| ----------------------- | ------------------- | ---------------------------------------- |
| transform.scale         | 比例转化                | @(0.8)                                   |
| transform.scale.x       | 宽的比例                | @(0.8)                                   |
| transform.scale.y       | 高的比例                | @(0.8)                                   |
| transform.rotation.x    | 围绕x轴旋转              | @(M_PI)                                  |
| transform.rotation.y    | 围绕y轴旋转              | @(M_PI)                                  |
| transform.rotation.z    | 围绕z轴旋转              | @(M_PI)                                  |
| cornerRadius            | 圆角的设置               | @(50)                                    |
| backgroundColor         | 背景颜色的变化             | (id)[UIColor purpleColor].CGColor        |
| bounds                  | 大小，中心不变             | [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; |
| position                | 位置(中心点的改变)          | [NSValue valueWithCGPoint:CGPointMake(300, 300)]; |
| contents                | 内容，比如UIImageView的图片 | imageAnima.toValue = (id)[UIImage imageNamed:@"to"].CGImage; |
| opacity                 | 透明度                 | @(0.7)                                   |
| contentsRect.size.width | 横向拉伸缩放              | @(0.4)最好是0~1之间的                          |

CGAffineTransform

#### 3）CABasicAnimation

##### 属性：

**1.fromValue** : keyPath相应属性的初始值
**2.toValue** : keyPath相应属性的结束值，到某个固定的值（类似transform的make含义）
注意：随着动画的进行,在长度为duration的持续时间内,keyPath相应属性的值从fromValue渐渐地变为toValue.
如果fillMode = kCAFillModeForwards和removedOnComletion = NO;那么在动画执行完毕后,图层会保持显示动画执行后的状态,但实质上,图层的属性值还是动画执行前的初始值,并没有真正被改变.比如: CALayer的postion初始值为(0,0),CABasicAnimation的fromValue为(10,10),toValue为 (100,100),虽然动画执行完毕后图层保持在(100,100) 这个位置,实质上图层的position还是为(0,0);
**3.byValue**：不断进行累加的数值（byvalue 值加上fromValue => tovalue）
例子：

```
CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
animation.byValue = @(M_PI * 2);
```

#### 4)  CAKeyframeAnimation

##### 属性

**values**：NSArray对象，里面的元素称为”关键帧”（NSValue类型），动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧（ NSValue）
例子：

```
//设置动画属性

NSValue *p1 = [NSValue valueWithCGPoint:CGPointMake(50, 150)];
NSValue *p2 = [NSValue valueWithCGPoint:CGPointMake(250, 150)];
NSValue *p3 = [NSValue valueWithCGPoint:CGPointMake(50, 550)];
NSValue *p4 = [NSValue valueWithCGPoint:CGPointMake(250, 550)];
animKey.values = @[p1, p2, p3, p4];
```

**keyTimes**：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧，当keyTimes没有设置的时候,各个关键帧的时间是平分的

**path**：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动，path只对CALayer的anchorPoint和position起作用，如果设置了path，那么values将被忽略。
例子：

```
UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 100, 250, 100)];
animKey.path = path.CGPath;
```

**rotationMode**：旋转模式
（1）默认nil

（2）设置为kCAAnimationRotateAuto 或 kCAAnimationRotateAutoReverse 会随着旋转的角度做 ”自转“
animKey.rotationMode = kCAAnimationRotateAuto; 



#### 5)  CAAnimationGroup

animations：动画组，用来保存一组动画对象的NSArray
默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间
例子：

// 2. 向组动画中添加各种子动画
// 2.1 旋转
CABasicAnimation *anim1 = [CABasicAnimation animationWithKeyPath:@"transform.rotation.z"];
// anim1.toValue = @(M_PI * 2 * 500);
anim1.byValue = @(M_PI * 2 * 1000);
// 2.2 缩放
CABasicAnimation *anim2 = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
anim2.toValue = @(0.1);
// 2.3 改变位置, 修改position
CAKeyframeAnimation *anim3 = [CAKeyframeAnimation animationWithKeyPath:@"position"];
anim3.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 100, 250, 100)].CGPath;

// 把子动画添加到组动画中
anim.animations = @[anim1, anim2, anim3];



#### 6)  CATransition

type：设置动画过渡的类型

```
kCATransitionFade 交叉淡化过渡

kCATransitionMoveIn 新视图移到旧视图上面

kCATransitionPush 新视图把旧视图推出去

kCATransitionReveal 将旧视图移开,显示下面的新视图
```

下面类型包装成字符串赋值


转场动画过渡效果
subtype：设置动画过渡方向

```
kCATransitionFromRight

kCATransitionFromLeft

kCATransitionFromTop

kCATransitionFromBottom
```

startProgress：动画起点(在整体动画的百分比)

endProgress：动画终点(在整体动画的百分比)
例子：

```
(IBAction)didRecognizeSwipeGesture:(UISwipeGestureRecognizer *)sender {

  // 1. 创建一个转场动画对象
  CATransition *anim = [[CATransition alloc] init];
  // 设置转场动画的类型
  anim.type = @"suckEffect";
  // 设置转场动画时间
  anim.duration = 1.5;
  anim.delegate = self;
  // 判断方向
  if (sender.direction == UISwipeGestureRecognizerDirectionLeft) {
      // 设置转场动画的子类型
      anim.subtype = kCATransitionFromRight;
      // NSLog(@"left");
      self.index++;
  } else {
      // 设置转场动画的子类型
      anim.subtype = kCATransitionFromLeft;
      // NSLog(@"right");
      self.index--;
  }

  // 判断是否越界
  if (self.index > 4) {
      self.index = 0;
  }

  if (self.index < 0) {
      self.index = 4;
  }

  // 拼接图片名称
  NSString *imgName = [NSString stringWithFormat:@"%d", self.index + 1];
  // 切换图片
  self.imgViewIcon.image = [UIImage imageNamed:imgName];
  // 把转场动画添加到对应的控件上
   [self.imgViewIcon.layer addAnimation:anim forKey:@"anim1"];
}

```



　　fillMode：视图在非Active时的行为

　　removedOnCompletion：动画执行完毕后是否从图层上移除，默认为YES（视图会恢复到动画前的状态），可设置为NO（图层保持动画执行后的状态，前提是fillMode设置为kCAFillModeForwards）

　　beginTime：动画延迟执行时间（通过CACurrentMediaTime() + your time 设置）

　　delegate：代理

代理方法如下：
     - (void)animationDidStart:(CAAnimation *)anim;  //动画开始
     - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; //动画结束

代理造成的循环引用问题 由于CAAnimation的delegate使用的strong类型，

所以在全局变量如下设置时会产生循环引用的情况

self.animation.delegate = self;//可通过复用dealloc方法来验证

```
使用NSProxy解决，在一个对象中对self 弱引用处理  然后通过类方法把 弱引用处理过的self对象转给delegate

YYWeakProxy
```



### 2.CA图形绘制



1.CAAnimation 

1.图形绘制（基础属性、基础方法的使用介绍、使用场景、实例） 

 CALayer(和各种子类http://blog.csdn.net/iunion/article/details/26221213)  

CGContextRef  UIBezierPathhttp://www.cnblogs.com/small-octopus/p/4874600.html   



## 二、UIViewAnimation

1.UIViewAnimation

1.基础方法 属性介绍 使用场景 实例

给view加上动画，本质上是对其layer进行操作，layer包含了各种支持动画的属性，动画则包含了属性变化的值、变化的速度、变化的时间等等，两者结合产生动画的过程。核心动画和UIView动画的对比：UIView动画可以看成是对核心动画的封装，和UIView动画不同的是，通过核心动画改变layer的状态（比如position），动画执行完毕后实际上是没有改变的（表面上看起来已改变）。

2.特效动画

## 三、长循动画

3.长循动画 粒子动画类

## 四、其他动画

4.控制器转场动画、动力学 、手势动画

转场动画

http://www.jianshu.com/p/45434f73019e

http://www.cocoachina.com/ios/20150719/12600.html

动力学

http://www.cocoachina.com/ios/20150729/12775.html

http://blog.csdn.net/gmfxch/article/details/46758157

## 五、Facebook POP库

5.facebook pop

基本和caanimation的使用规则类似

6.测试



## 六、常见问题

1、 如果当动画正在执行的时候, 将程序退出到后台, 那么当程序再次进入前台的时候就不执行了。

**原因**: 因为再次进入前台后动画已经被删除了。

**解决**: anim.removedOnCompletion = NO;



动画总结

http://www.ithao123.cn/content-2377425.html

http://www.cocoachina.com/ios/20141022/10005.html

https://www.objccn.io/issue-12-1/