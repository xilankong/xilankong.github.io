---
layout: post
category: 学习之路
---

## 1.为什么UI要在主线程更新

因为UIKit不是线程安全的。试想下面这几种情况：

两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。 

两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。 

两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。 

iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。

## 

## 2.有什么软件或者插件可以测试这个问题吗？



## 3.我的想法

View的更新操作 使用runtime 去替换 View 中实现 的方法 不变更实现。只是在中间插入 线程检查操作，发现子线程就必须打印线程调用栈并触发crash。

问题：替换哪些方法更合适?  都会涉及到哪些基础控件需要category？



## 4.例子

1.创建一个UIImage的category

```
@implementation UIImage (demo)

+(void)load
{
    Method  m1 = class_getClassMethod([UIImage class],@selector(imageNamed:));
    
    Method m2 = class_getClassMethod([UIImage class],@selector(ximageNamed:));
    
    // 开始交换方法实现
    method_exchangeImplementations(m1, m2);
}
+(UIImage *)ximageNamed:(NSString *)name
{
    NSLog(@"进入方法-开始检查线程");
    
    NSThread *thread = [NSThread currentThread];
    if (![thread isMainThread]) {
        NSLog(@" 当前线程不是主线程  %@",[NSThread callStackSymbols]);
    }
    return [UIImage ximageNamed:name];
}
@end
```

2.在一个视图内实现一段UIImage的异步赋予图片

```
    UIImageView *img = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 300, 300)];
    [self.view addSubview:img];
    img.image = [UIImage imageNamed:@"networklosed"];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        img.image = [UIImage imageNamed:@"mncg_search_nor"];
    });
    NSLog(@"测试线程是否异步");
```

3.检测结果为非主线程 并打印出线程 函数调用栈