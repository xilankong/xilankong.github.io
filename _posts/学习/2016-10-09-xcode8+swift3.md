---


layout: post
category: 学习之路
title:  "xcode8+swift3" 
---

swift 官方文档翻译 不是最新

http://www.cocoachina.com/industry/20140613/8818.html



http://www.cnblogs.com/kenshincui/p/5594951.html



http://www.jianshu.com/p/460b5424942a

官方文档 3.0

https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94

3.0 基础



数组构建方法

```
var array = [String]();
var array = Array(repeating:0,count:5)
```



数组的遍历

```
// 遍历数组
for i in 0..<array.count {
    print(array[i])
}

// forin方式
for item in array {
    print(item)
}

// 设置遍历的区间
for item in array[0..<2] {
    print(item)
}

// enum 遍历
for en in array2.enumerated() {
    print(en)
    // 下标
    print(en.offset)
    // 值
    print(en.element)
}
// 下标和数值同时 遍历
for (n,s) in array2.enumerated() {
     print(n , "==", s);
}

// 反序遍历
for s in array2.reversed() {
    print(s)
}
        
// 遍历下标和数值 反序
for (xxx,ooo) in array2.enumerated().reversed() {
    print(xxx ,"====" ,ooo)
}
```





字典创建方法



var dict : [String : String] = [:]

var dict : Dictionary<String,String> = Dictionary.init();

var airports : Dictionary<String, String> = ["TYP":"Tokyo", "DUB":"Boublin"]
var airports2 = ["TYP":"Tokyo", "DUB":"Boublin"]
var empty_dic = Dictionary<String, String>()



swift 和 oc 交互 分别有两个文件 工程名-Swift.h 是 用于 oc 调用 swift ， 工程名-Bridging-Header 是用于 swift调用oc

swift 进入oc 



oc 进入swift swift 有命名空间 

- (Class)swiftClassFromString:(NSString *)className {
    NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"];
    NSString *classStringName = [NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className];
    return NSClassFromString(classStringName);
  }
- http://stackoverflow.com/questions/24030814/swift-language-nsclassfromstring

http://www.cnblogs.com/godlovexq/p/5293027.html





swift3.0 新特性

3.0  @noescape   变成默认属性

@escaping 逃逸闭包

逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行

@autoclosure 自动闭包

(1)默认非逃逸
(2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。
(3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。
(4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。
(5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。
(6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明: @autoclosure @escaping 旧版本：@autoclosure(escaping)



swift 枚举 

```
var result = Planet.One;
result = .Two;
switch result {
case .One:
 print("执行One");
case .Two:
 print("执行Two");
default:
 print("执行Default");
}
```

元祖 枚举

```
enum Barcode {

case UPCA(Int,Int,Int)

case QRCode(String)

}

var code = Barcode.UPCA(1, 8, 8);

switch code {

case .UPCA(let num1,let num2,let num3):

 print("(num1)");

case .QRCode(let strOne):

 print("(strOne)");

default:

print("111");

}

enum Expression {

case add(Int)

case plus(Int)

}

var method = Expression.add(5);

switch method {

case .add(let num):

print("(num)");

default:

print("xxx");

}
```

柯里化





swift  闭包懒加载按钮 不能先给target  



swift lazy属性

  lazy var html: () -> String = {

        if let text = self.text {
            return "11111";
        } else {
            return "2222";
        }
    }
    
    lazy var second:String = {
        if let text = self.text {
            return "11111";
        } else {
            return "2222";
        }
    }()  //不要忘记最后的小括号，只有加了小括号，必包才会在掉用的时候立刻执行。要类型声明lazy var second:String，这样Xcode会进行类型检查。
一 懒加载初始化的定义

懒加载初始化只进入一次  并且在需要的时候才调用


在Objective C中， 懒加载初始化是这样写的

```
@property (strong,nonatomic) CAShapeLayer * shapelayer;

-(CAShapeLayer *)shapelayer{   

 if (!_shapelayer) {       

 _shapelayer = [CAShapeLayer layer];    
}    
return _shapelayer;
}

```


那么何为 懒加载初始化呢？ 
从OC的代码中不难看出， 懒加载初始化，就是在变量第一次使用的时候才进行初始化。

二 Swift中的 懒加载初始化
Swift中，有两种方式来 懒加载初始化。 
第一种，简单表达式

    lazy var first = NSArray(objects: "1","2")
第二种，闭包

lazy var second:String = {        return "second"        }()

注意

不要忘记最后的小括号，只有加了小括号，必包才会在掉用的时候立刻执行。
要类型声明lazy var second:String，这样Xcode会进行类型检查。


三  懒加载初始化的使用场景
属性本身依赖于外部因素才能初始化 
completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀

class Demo{    

var url:NSString    

lazy var completeURL:NSString = {       

 [unowned self] in       

 if self.url.hasPrefix("http://"){           

 return self.url        

}else{            

return "http://".stringByAppendingString(self.url)        

}        

}()    

init(url:NSString){       

 self.url = url    

}}
属性需要复杂计算，消耗大量CPU

lazy var second:Int = {        var sum = 0        for i in 1...100000{            sum += i        }        return sum        }()
属性不确定是否会使用到

官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化class DataImporter {    /*    DataImporter is a class to import data from an external file.    The class is assumed to take a non-trivial amount of time to initialize.    */    var fileName = "data.txt"    // the DataImporter class would provide data importing functionality here}class DataManager {    lazy var importer = DataImporter()    var data = [String]()    // the DataManager class would provide data management functionality here}let manager = DataManager()manager.data.append("Some data")manager.data.append("Some more data")
定制化的初始化 
有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护

lazy var dataArray:NSMutableArray = {        var array = NSMutableArray()        for  i in 1...100{            array.addObject(NSNumber(integer: i))        }        return array        }()



swift  -  oc



http://www.cocoachina.com/swift/20150608/12025.html



http://blog.csdn.net/fengsh998/article/details/34440159

Swift访问OC 通过  [ 项目名-Bridging-Header.h ] 文件 把需要引用的OC文件在这个头文件中引入



OC访问Swift  swift项目会自动生成一个 [ 项目名-Swift.h ] 文件 不可见，但是可以跳转进入，所有swift代码生成的类属性 都会在这个文件中转义一份oc的样式 



oc pch文件的使用



http://www.jianshu.com/p/67ce72c4ad6c



注意要在  build - setting 中得 prefix Header配置新建的pch文件  配置格式 $(SRCROOT)/项目名称/pch文件名





当xib layout设置width>=0的时候  在代码中设置constraints = 0 无效 比如我需要移除一个label的宽度 但是label在xib中自适应的width>0   ?????





UITabelView 的 headView 想要动态更新大小的时候 需要变更view的frame然后重新设置tableHeaderView





swift  masonry 的使用   http://www.jianshu.com/p/aef3da10ae07