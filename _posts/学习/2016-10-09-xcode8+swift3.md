---


layout: post
category: 学习之路
title:  "xcode8+swift3" 
---

swift 官方文档翻译 不是最新

http://www.cocoachina.com/industry/20140613/8818.html



http://www.cnblogs.com/kenshincui/p/5594951.html



http://www.jianshu.com/p/460b5424942a

官方文档 3.0

https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94

3.0 基础



数组构建方法

```
var array = [String]();
var array = Array(repeating:0,count:5)
```



数组的遍历

```
// 遍历数组
for i in 0..<array.count {
    print(array[i])
}

// forin方式
for item in array {
    print(item)
}

// 设置遍历的区间
for item in array[0..<2] {
    print(item)
}

// enum 遍历
for en in array2.enumerated() {
    print(en)
    // 下标
    print(en.offset)
    // 值
    print(en.element)
}
// 下标和数值同时 遍历
for (n,s) in array2.enumerated() {
     print(n , "==", s);
}

// 反序遍历
for s in array2.reversed() {
    print(s)
}
        
// 遍历下标和数值 反序
for (xxx,ooo) in array2.enumerated().reversed() {
    print(xxx ,"====" ,ooo)
}
```





字典创建方法



var dict : [String : String] = [:]

var dict : Dictionary<String,String> = Dictionary.init();

var airports : Dictionary<String, String> = ["TYP":"Tokyo", "DUB":"Boublin"]
var airports2 = ["TYP":"Tokyo", "DUB":"Boublin"]
var empty_dic = Dictionary<String, String>()



swift 和 oc 交互 分别有两个文件 工程名-Swift.h 是 用于 oc 调用 swift ， 工程名-Bridging-Header 是用于 swift调用oc

swift 进入oc 



oc 进入swift swift 有命名空间 

- (Class)swiftClassFromString:(NSString *)className {
    NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"];
    NSString *classStringName = [NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className];
    return NSClassFromString(classStringName);
  }
- http://stackoverflow.com/questions/24030814/swift-language-nsclassfromstring

http://www.cnblogs.com/godlovexq/p/5293027.html





swift3.0 新特性

3.0 弃用 @noescape  

@escaping 逃逸闭包

逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行

@autoclosure 自动闭包

(1)默认非逃逸
(2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。
(3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。
(4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。
(5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。
(6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明: @autoclosure @escaping 旧版本：@autoclosure(escaping)



swift 枚举 

```
var result = Planet.One;
result = .Two;
switch result {
case .One:
 print("执行One");
case .Two:
 print("执行Two");
default:
 print("执行Default");
}
```

元祖 枚举

enum Barcode {
​    

    case UPCA(Int,Int,Int)
    case QRCode(String)
}

var code = Barcode.UPCA(1, 8, 8);

switch code {
case .UPCA(let num1,let num2,let num3):
      print("\(num1)");
case .QRCode(let strOne):
      print("\(strOne)");
default:
    print("111");
}

enum Expression {
    case add(Int)
    case plus(Int)
}

var method = Expression.add(5);
switch method {
case .add(let num):
    print("\(num)");
default:
    print("xxx");
}
