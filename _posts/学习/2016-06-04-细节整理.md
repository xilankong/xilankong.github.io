---
layout: post
category: 学习之路
---

QUESTION:

1、IOS 7.0下面使用自动布局之后 再次在layoutSubViews中变更了 子view的frame 需要更新AutoLayout机制  [self.view layoutIfNeeded]; 

添加到父类控制器的 -(void)viewDidLayoutSubviews 方法中

//必须要 Auto Layout still required after sending -viewDidLayoutSubviews to the view controller.



2、导航条上会用到的属性变化

1. 按钮颜色
2. title颜色
3. 导航背景色
4. 顶部状态栏变色

```
//按钮颜色
self.navigationController.navigationBar.tintColor = [UIColor whiteColor];
//导航条bar背景色
self.navigationController.navigationBar.barTintColor = [UIColor blackColor];
//导航条文字title颜色
[self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor whiteColor]}];
//设置顶部状态栏变色

1.控制器是依赖于系统的UINavigationController的：
第一步 ： 拓展一个UINavigationController的子类，
并设置 将导航控制器内所有控制器的顶部状态栏设置权赋予这些控制器。
- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}

第二步 ： 在导航下的控制器中实现 配置 

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent; //白色
    //return UIStatusBarStyleDefault; //黑色
}

2.直接设置
1在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO

2 在需要改变状态栏颜色的ViewController中在ViewDidLoad方法中增加：

[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];

//这个地方，UIStatusBarStyleDefault外，设置其他值，导航条的文字颜色都将是白色，亲试。
```



3、Xcode卡 经常丢失高亮和代码提示

未解决



4、导航条背景色变透明

```
在viewwillappear调用
- (void)jfz_changeNavigationBarTintColorWithoutBottomLine:(UIColor *)color
{
    if ([self.navigationBar respondsToSelector:@selector(setBackgroundImage:forBarMetrics:)]){
        NSArray *list=self.navigationBar.subviews;
        for (id obj in list) {
            if ([obj isKindOfClass:[UIImageView class]]) {
                UIImageView *imageView=(UIImageView *)obj;
                imageView.hidden = YES;
            }
        }
    }
    if (self.currentNaviBackgroundColor != color){
        self.currentNaviBackgroundColor = color;
        self.navigationBackground.image = [UIImage jfz_imageWithColor:color withSize:CGSizeMake(self.navigationBackground.bounds.size.width, self.navigationBackground.bounds.size.height)];
    }
    [self.navigationBar insertSubview:self.navigationBackground atIndex:0];
    
}
在viewwillDisappear调用
- (void)jfz_removeCurrentNavigationBackground {
    [self.navigationBackground removeFromSuperview];
    if ([self.navigationBar respondsToSelector:@selector( setBackgroundImage:forBarMetrics:)]){
        NSArray *list=self.navigationBar.subviews;
        for (id obj in list) {
            if ([obj isKindOfClass:[UIImageView class]]) {
                UIImageView *imageView=(UIImageView *)obj;
                imageView.hidden = NO;
            }
        }
    }
}
```



5、在安装cocoapods遇到的问题  （未验证）

```
[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master
Cloning into 'master'...
error: RPC failed; curl 56 SSLRead() return error -36
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
```

解决方案： 

先在终端输入”sudo xcode-select -switch “，然后，打开Xcode—>右键显示包内容，找到Developer文件夹拖到终端里面

PS:一些xcode-select的命令的使用：

xcode-select [-help]
xcode-select [-switch xcode_folder_path]
xcode-select [-print-path]
xcode-select [-version]

例如： 
打印当前xcode的路径    xcode-select --print-path

输出：/Applications/Xcode.app/Contents/Developer



6、函数调用栈

```
(NSArray *)callStackReturnAddresses ／／线程的调用都会有函数的调用 函数的调用就会有栈返回地址的记录，在这里返回的是函数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组

(NSArray *)callStackSymbols ／／同上面的方法一样，只不过返回的事该线程调用函数的名字数字
```



6、iOS开发工具——统计Crash的工具Crashlytics

未查看



7、UITableViewCell  在点击之后马上取消点击效果

(void)setSelected:(BOOL)selected animated:(BOOL)animated {
//    [super setSelected:selected animated:animated];

}

在点击之后重新退回页面的时候取消点击效果

​ [tableView deselectRowAtIndexPath:indexPath animated:YES];

同时，tableViewCell 自带取消点击效果 



8、让scrollView延伸到导航条下面   使用需要注意场合 

self.automaticallyAdjustsScrollViewInsets = NO;

???

​    self.edgesForExtendedLayout = UIRectEdgeNone;

9、错误案例：

    NSDictionary *dict = [NSDictionary dictionary];
    [dict setValue:@"xx" forKey:@"key"];
NSDictionary 是不可变的



10、UIVisualEffectView 毛玻璃效果

    UIVisualEffectView *blurView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight ]];
    blurView.layer.opacity = .9;
    blurView.frame = self.view.frame;
    [self.view addSubview:blurView];
11、 po [self.view recursiveDescription] 打印当前视图subviews的UI层次



12、instrument 使用

1.Target failed to run: Permission to debug jp.psc.TabletSync was denied. The app must be signed with a development identity (e.g. iOS Developer).

把 工程的scheme 中的profile  build模式改成debug





13、在Pod库中使用xcasset的拷贝陷阱

工作中遇到一个难解的BUG - 在App中用UIImage的imageNamed:方法读取的图片始终是不正确的。突然图片获取途径都是正常情况下 图片资源却取的不正确。排除缓存问题后，查看ipa包下面的图片是正确的。 

原因：http://blog.startry.com/2016/03/17/the-trap-of-image-resource/

CocoaPods在Pod里引用了任意一个xcasset相关的文件后, 就会去根目录搜索所有的xcasset组合成为最终的car。CocoaPods设定这样脚本的原因是无法精确的将主工程下的xcasset寻找到, 只能采用暴力的方式去解决, 暂时也没有更好的解决方案！

解决办法：

方法一: 删除所有物理目录下多余的xcasset, 本身在源代码根目录下放置没有用到库本身就是非常危险的行为。
方法二: 通过Podfile Hook去屏蔽Pod库资源的Copy和合成, 替换核心脚本, 定向指定自己需要Copy的资源。
方法三: 逃避的方法, 不要在Pod库中使用xcasset。本身CocoaPods的初衷并没有打算支持资源文件的, 后续演变成目前的形态。(不适用xcasset默认png压缩不会执行, 可能需要手动执行, 并且图片容易被提取)



14、IOS 按钮xib设置按钮取消点击效果 要从 system 改成custom



15、cocoa pods 升级更新

//gem更新

sudo gem update -n /usr/local/bin --system

//升级指定版本的cocoapods

sudo gem install -n /usr/local/bin cocoapods --version 1.1.0

sudo gem install -n /usr/local/bin cocoapods

//安装卸载指定版本的cocoapods

sudo gem install cocoapods --version 0.24.0

sudo gem uninstall cocoapods卸载cocoapods

16、查看具体设备 

```
#import <sys/sysctl.h>

+ (NSString*)getDeviceVersion

{
    
    size_t size;
    
    sysctlbyname("hw.machine",NULL, &size, NULL,0);
    
    char *machine = (char*)malloc(size);
    
    sysctlbyname("hw.machine", machine, &size,NULL, 0);
    
    NSString *platform = [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
    
    //NSString *platform = [NSStringstringWithUTF8String:machine];二者等效
    
    free(machine);
    
    return platform;
    
}

NSLog(@"%@",[ViewController getDeviceVersion])
```

17.

#  错误操作  真正原因是代理被修改

当使用图片选择器的时候 如果是控制器设置的时局部变量，不能在弹出之前 给代理  需要在弹出之后给上代理处理、当遇到代理回调不出现的时候 检查代理是否被修改

    UIImagePickerController *picker = [[UIImagePickerController alloc] init];
    picker.sourceType               = (int)sourceType;
    picker.delegate                 = (id)self;
    [self presentViewController:picker animated:YES completion:^{
        picker.delegate                 = (id)self;
    }];
18.

oc中  @class 和 #import的区别

@class可以减少xcode编译文件数  @class 可以解决指针引用某个类中的内容等问题  

@class 告诉xcode  后面这个类 只需要知道是指针引用就行，不需要知道全部定义  所有判断使用的时候 看是否需要知道全部定义：例如继承之类的  无法用@class

19.

IOS 响应链

http://ios.jobbole.com/88526/

NSScaner

http://blog.csdn.net/likendsl/article/details/7974761



20.

static和const的使用


##### static  生命周期


1.

修饰局部变量、让局部变量只初始化一次、局部变量在程序中只有一份内存

并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）

2.
修饰全局变量

全局变量的作用域仅限于当前文件

##### const  是否可修改


没有const修饰的指针

指针p和*p都能被修改

// 定义一个指针变量
int *p = NULL;

// 定义2个int类型的变量
int a = 10;
int b = 30;

// p指向a
p = &a;
*p = 20;

// p指向b
p = &b;
*p = 40;

NSLog(@"%d %d", a, b);
const修饰的*p

被const修饰的*p只能被赋值一次，以后不能赋值，否则编译器报错

// const修饰的*p
const int *p = NULL;
int const *p = null;

*p = 20; // 编译器报错，不能修改*p的值
const修饰的p

被const修饰的p只能存一次地址，以后再也不能其它存地址了，否则编译器报错

// const修饰的指针变量p
int * const p = NULL;
int a = 20;

p = &a; // 编译器报错，不能修改指针变量p
const在声明字符串的用法
  NSString * const ZMJName = @"jack";
static和const联合使用
static将一个全局变量变成局部变量
const将一个局部变量变成局部常量
// 定义了一个局部常量
static const CGFloat ZMJRed = 0.4;
static const CGFloat ZMJGreen = 0.6;
static const CGFloat ZMJBlue = 0.7;
使用static const 与 #define
使用static const修饰变量和宏定义的比较
相同点 : 都不能再被修改  一处修改，其它都改了
不同点 : static const修饰变量只有一份内存  宏定义，只是简单的替换，每次使用都需要创建一份内存
结论 :
使用static const修饰更加高效，在同一个文件内可以使用static const取代#define
    // static const修饰变量只有一份内存
    static const CGFloat ZMJRed = 0.4;
    // 宏定义，只是用0.4替换ZMJRed，每次使用都需要创建一份内存
    #define ZMJRed 0.4
const实际开发的应用
一般专门存放常量的引用

// 定义了整个程序都能访问的常量
const CGFloat ZMJRed = 0.4;
NSString * const ZMJName = @"jack";



21.

tableView的侧滑删除  commitEditingStyle 、canEditRowAtIndexPath

deleteRowsAtIndexPaths 的时候 需要先 更新数据源 再移除 防止空指针问题

22.

对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。

    NSString *string = @"origin";
    NSString *stringCopy = [string copy];
    理解这个的时候要分清楚，*string 是一个指针，它本身有一个内存地址 存放了@"origin"这个对象的内存地址
    每次拷贝都会生成一个新的指针地址 *stringCopy  但是这个指针地址内存放的对象内存地址会因为拷贝方式不一样而不一样。
23.

Xcode 7.0也就是iOS9.0中开发要求App内访问的网络必须使用HTTPS协议。那么我们公司没用采用https怎么办？如果发现网络请求失败，Xcode后台报错信息为： 
The resource could not be loaded because the App Transport Security policy requires the use of a secure connection. 
（大概意思就是：资源数据不能被下载，因为APP传输安全策略需要采用安全的连接方式）。

解决方法：

在Info.plist中添加NSAppTransportSecurity类型Dictionary。 
在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES

    <key>NSAppTransportSecurity</key>
    <dict>
          <key>NSAllowsArbitraryLoads</key>
          <true/>
    </dict>
找到info.plist,注意不是测试文件里面的plist哦。 



24.监听侧滑完成

```
    [self.transitionCoordinator notifyWhenInteractionEndsUsingBlock:^(id<UIViewControllerTransitionCoordinatorContext>  _Nonnull context) {
        
    }];
```



25.  沙盒

    http://www.jianshu.com/p/f74a5ef11b78



26.字典设置





27.事件阻隔

比如button中加个view view的事件会阻隔掉button的touch事件 怎么办？

view.userInteractionEnabled  = NO;//取消view的事件响应能力即可



28.

@property (nonatomic, strong) NSMutableArray *dataArray;

当回用到dataArray去变更添加数据的时候，前面如果声明为copy  在构造的时候  需要使用mutableCopy 复制一份，不然会出现_ _NSArrayI 问题  也可直接用strong类型





29.

当一个View要随着内部内容自动变更frame