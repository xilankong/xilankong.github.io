---
layout: post
category: 学习之路
title : "IOS开发工具整理"


---

## **1、Xcode调试工具** **：LLDB**

 LLDB是Xcode自带的一个开源调试器。存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它

```
1.断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态直接暂停，
2.控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序
```

暂停状态你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展，平时我们使用的多的 例如 p、po。但是其实还有更多的小技巧可以用来为我们服务。

### LLDB语法

```
<command> [<subcommand> [<subcommand>...]] <action> [-options [option-value]] [argument [argument...]]
```

1. command(命令)和subcommand(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。
2. action：执行命令的操作
3. options：命令选项 
4. arguement：命令的参数
5. []：表示命令是可选的，可以有也可以没有 <> 无特定作用 不需要写出在命令中

```
例如:
breakpoint set -n goS  //给goS方法添加一个断点

command: breakpoint 表示断点命令
action: set 表示设置断点
option: -n 表示根据方法name设置断点
arguement: goS 表示方法名为mian
```

### 原始(raw)命令

LLDB支持不带命令选项(options)的原始(raw)命令，原始命令会将命令后面的所有东西当做参数(arguement)传递。不过很多原始命令也可以带命令选项，当你使用命令选项的时候，需要在命令选项后面加--区分命令选项和参数。

常用的expression就是raw命令，一般情况下我们使用expression打印一个东西是这样的：

```
expression  btn
```

我们知道，OC里所有的对象都是用指针表示的，所以一般打印的时候，打印出来的是对象的指针，而不是对象本身。当我们想打印一个对象的时候。需要使用 -O(o 大写 不是零)命令选项，我们应该用双中杠(- -)将命令选项和参数区分：

```
expression -O -- btn
```



### 唯一匹配原则

LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一匹配到某个命令，则只写前n个字母等效于写下完整的命令。

使用唯一匹配原则简写，下面2条命令等效：

```
1、expression  btn
2、exp btn
```





LLDB使用的表达式语法 和你断点区域使用的语法一样，代码是swift 调试表达式也是swift oc同理

### LLDB命令

**1.expression** 

expression 可简写为e，作用为执行一个表达式，可以用来查询当前堆栈变量的值。查询的时候和p是一样的。

当然e的更主要的用法是通过执行表达式，动态修改当前线程堆栈变量的值，从而达到调试的目的（其实查询也很主要，只是会用另一种方式查询）。

```
 oc
 e viewController.view.backgroundColor = [UIColor blackColor] 
 swift
 e viewController.view.backgroundColor = UIColor.black
 //动态将我们后面要跳入的控制器背景色改变
```

我们也可以在某个if..else..的语句前打上断点，直接修改条件表达式的值，使程序覆盖了不同分支，而不用代码修改变量值、多次编译执行来进行调试，节省了修改与编译时间。



**2.p、po  & print & call**

print: 打印某个东西，可以是变量和表达式

p: 可以看做是print的简写 和 expression 一样

po : 和 expression -O 一样

call: 调用某个方法。



**3.thread backtrace & bt  | frame**

有时候我们想要了解线程堆栈信息，可以使用thread backtrace thread backtrace作用是将线程的堆栈打印出来。我们来看看他的语法

```
thread backtrace [-c <count>] [-s <frame-index>] [-e <boolean>]
```

-c：设置打印堆栈的帧数(frame)
-s：设置从哪个帧(frame)开始打印
-e：是否显示额外的回溯

当发生crash的时候，我们可以使用thread backtrace查看堆栈调用  bt 是缩写别名。

打印出来的结果其实和我们Xcode侧边Thread调试的堆栈调用信息是一样的。

```
* thread #1: tid = 0xdf89, 0x0000000109f0a94a SWIFTDEMO`ViewController.viewWillAppear(animated=true, self=0x00007fbfc950c7c0) -> () + 122 at ViewController.swift:32, queue = 'com.apple.main-thread', stop reason = breakpoint 4.1
  * frame #0: 0x0000000109f0a94a SWIFTDEMO`ViewController.viewWillAppear(animated=true, self=0x00007fbfc950c7c0) -> () + 122 at ViewController.swift:32
    frame #1: 0x0000000109f0aa01 SWIFTDEMO`@objc ViewController.viewWillAppear(Bool) -> () + 49 at ViewController.swift:0

```

在上面打出的堆栈调用信息中可以看到很多frame（帧） 开头的段落。

**frame 可以使用的命令** 

**frame variable**  ，可以打印出当前frame的所有变量 如果需要打印frame中得指定变量，也可以在后面跟参数

```
(lldb) frame variable
(Bool) animated = true
(SWIFTDEMO.ViewController) self = 0x00007fbfc950c7c0 {
  UIKit.UIViewController = {
    UIKit.UIResponder = {
      ObjectiveC.NSObject = {}
    }
  }
  btn = 0x00007fbfc950cae0 {
    UIKit.UIControl = {
      baseUIView@0 = <extracting data from value failed>

      _targetActions = 0x000060800024b160 1 element
      _downTime = 502082955.614223
    }
  }
  name = "小白"
}
(lldb) frame variable self.btn
(UIButton) self.btn = 0x00007fbfc950cae0 {
  UIKit.UIControl = {
    baseUIView@0 = <extracting data from value failed>

    _targetActions = 0x000060800024b160 1 element
    _downTime = 502082955.614223
  }
}
```

**frame select** ,根据frame队列号选中堆栈调用列表中得frame 

```
(lldb) frame select 0
frame #0: 0x0000000109f0a94a SWIFTDEMO`ViewController.viewWillAppear(animated=true, self=0x00007fbfc950c7c0) -> () + 122 at ViewController.swift:32
   29  	    override func viewWillAppear(_ animated: Bool) {
   30  	        super.viewWillAppear(animated);
   31  	        
-> 32  	        btn.addTarget(self, action:#selector(goS(str:)), for: UIControlEvents.touchUpInside);
   33  	    }
   34  	    override func didReceiveMemoryWarning() {
   35  	        super.didReceiveMemoryWarning()
```

**frame info** ,查看当前frame的信息

不过以上操作都可以在Xcode的侧边Thread堆栈调用列表操作，所以使用也较少。

**4.thread return**

Debug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。 只支持返回int？ 还是swift有不兼容？

```
thread return [<expr>]
```

thread return可以接受一个表达式，调用命令之后直接从当前的frame返回表达式的值。

我们有一个someMethod方法，默认情况下是返回YES。我们想要让他返回NO

我们只需在方法的开始位置加一个断点，当程序中断的时候，输入命令即可:

```
thread return NO
```

效果相当于在断点位置直接调用return NO;，不会执行断点后面的代码



**5.thread其他不常用的命令**

thread 相关的还有其他一些不常用的命令，这里就简单介绍一下即可，如果需要了解更多，可以使用命令help thread查阅

thread jump: 直接让程序跳到某一行。由于ARC下编译器实际插入了不少retain，release命令。跳过一些代码不执行很可能会造成对象内存混乱发生crash。
thread list: 列出所有的线程
thread select: 选择某个线程
thread until: 传入一个line的参数，让程序执行到这行的时候暂停
thread info: 输出当前线程的信息



**6.c & n & s & finish**

c/ continue/ thread continue: 这三个命令都表示程序继续运行
n/ next/ thread step-over: 这三个命令表示单步运行
s/ step/ thread step-in: 这三个命令效果表示进入某个方法
finish/ step-out: 这两个命令效果表示直接走完当前方法，返回到上层frame



**7.breakpoint**

breakpoint set 设置断点

参数 ：

-n 根据当前类中方法名设置断点

```
(lldb) breakpoint set  -n viewDidLoad
Breakpoint 6: 2 locations.
```

-f 根据我们指定文件设置断点 

```
(lldb) breakpoint set -f VcTwo.swift -n viewDidLoad
Breakpoint 8: 2 locations.
```

-l 根据文件某一行设置断点 和 -f配合使用

```
(lldb) breakpoint set -f VcTwo.swift -l 35
Breakpoint 12: where = SWIFTDEMO`SWIFTDEMO.VcTwo.viewDidLoad () -> () + 679 at VcTwo.swift:35, address = 0x0000000109f08637
```

-c 设置条件断点

```
breakpoint set -n goS -c flag == YES
```

-o 设置单次断点

```
breakpoint set -n goS -O
```

breakpoint list 断点列表

```
(lldb) breakpoint list
Current breakpoints:
1: file = '/Users/young/Desktop/demo/SWIFTDEMO/SWIFTDEMO/File.swift', line = 41, exact_match = 0, locations = 0 (pending)
2: file = '/Users/young/Desktop/demo/SWIFTDEMO/SWIFTDEMO/ViewController.swift', line = 32, exact_match = 0, locations = 1, resolved = 1, hit count = 0
  2.1: where = SWIFTDEMO`SWIFTDEMO.ViewController.viewWillAppear (Swift.Bool) -> () + 122 at ViewController.swift:32, address = 0x0000000105c2187a, resolved, hit count = 0 
```

breakpoint disable/enable 暂停/恢复断点

```
(lldb) breakpoint disable 2
1 breakpoints disabled.
```

breakpoint delete  删除断点

```
(lldb) breakpoint delete 1
1 breakpoints deleted; 0 breakpoint locations disabled.
```

删除所有断点

```
(lldb) breakpoint delete 
About to delete all breakpoints, do you want to do that?: [Y/n] y
All breakpoints removed. (6 breakpoints)
```

如果文件不存在或者方法不存在

```
Breakpoint 11: no locations (pending).
WARNING:  Unable to resolve breakpoint to any actual locations.
```

**8.watchpoint **

watchpoint  观察变量或者属性的变化 只要产生变化就会中断 （慎用）

```
(lldb) watchpoint set variable btn
Watchpoint created: Watchpoint 1: addr = 0x7fff59fe1d38 size = 8 state = enabled type = w
    declare @ '/Users/young/Desktop/demo/SWIFTDEMO/SWIFTDEMO/ViewController.swift:14'
    watchpoint spec = 'btn'
    new value: 0x00007fef4af14de0

Watchpoint 1 hit:
old value: 0x00007fef4af14de0
new value: 0x0000000105c61008

Watchpoint 1 hit:
old value: 0x0000000105c61008
new value: 0x0000000000000000
```

其他操作和breakpoint差不多。



9.target 暂未测试







expression -- (void)[CATransaction flush] 不起作用



http://blog.csdn.net/u011619283/article/details/53080147

## 2、日志调试，xcode崩溃日志



发电公司



## 3、Charles 黑魔法























 -> JFZLogger (1.0.5)

    - WARN  | source: Git SSH URLs will NOT work for people behind firewalls configured to only allow HTTP, therefore HTTPS is preferred.
    - WARN  | url: There was a problem validating the URL git@gitlab.jfz.net:iOS/JFZLogger.git.
    - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code.
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:57:9: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:102:13: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:105:13: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:170:9: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:173:9: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:188:13: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'
    - ERROR | [iOS] xcodebuild:  /Users/young/Desktop/workplace/JFZLogger/JFZLogger/Classes/Source/JFZLogger.m:191:13: error: use of undeclared identifier 'LOG_ASYNC_ENABLED'

[!] JFZLogger did not pass validation, due to 8 errors and 2 warnings.
You can use the `--no-clean` option to inspect any issue.





参考：http://ios.jobbole.com/83393/