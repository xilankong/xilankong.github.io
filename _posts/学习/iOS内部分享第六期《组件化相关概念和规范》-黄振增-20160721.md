#金斧子组件化方案
***

##索引

1. 组件化背景
2. 常用方案分析
3. 金斧子方案
4. 常见问题
5. 参考资料


### 1.组件化背景

#####合适时机
当公司处于起步阶段，各部分需求还没有稳定，组件化没有那么迫切，甚至还会影响开发效率；经过N个版本的迭代，部分需求逐步稳定，各种业务模块增多，组件化时机成熟。

####减少耦合
现阶段所有接口暴漏出来，整个工程都可见，随处交叉引用；当业务增多，某些源文件依赖于20多个文件或者同个功能多个入口存在多个相似备份；组件化引入，就是为了减少各个模块显式依赖，统一的对外接口规范。

####App间共用，资源共享
目前公司存在于几个移动端App，相同组件各自维护，Bug修复后，没有及时知会其它项目组；同时各项目组对同一个事情重复搬砖，重复劳动；进一步发展，新App出现时，只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App。

***


### 2.现有方案

####基于协议调度（Route）
类似于C/S架构，本地调度中心相当于本地Http服务器，注册各种协议，监听事件到来，最终转发各种请求。所有业务调用都通过Route进行。可参考第三方框架[JLRoutes](https://github.com/joeldev/JLRoutes)，其调用流程如下图：<br/>
![Route流程](http://gitlab.jfz.net/iOS/iOSStudy/raw/master/training/iOS内部分享第五期《组件化相关概念和规范》-黄振增-20160721/img/Route流程.png)

1）注册事件

```
[JLRoutes addRoute:@"/user/view/:userID" handler:^BOOL(NSDictionary *parameters) {
    NSString *userID = parameters[@"userID"]; // defined in the route by specifying ":userID"
    // present UI for viewing user with ID 'userID'
    return YES; // return YES to say we have handled the route
  }];

- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *, id> *)options {
  return [JLRoutes routeURL:url];
}  
```

2）调用模块

```
NSURL *viewUserURL = [NSURL URLWithString:@"myapp://user/view/joeldev"];
[[UIApplication sharedApplication] openURL:viewUserURL];
```

####基于运行时调度（Runtime）
基于Mediator模式和Target-Action模式，采用了runtime来完成调度，其流程如下所示：<br/>
![Runtime流程](http://gitlab.jfz.net/iOS/iOSStudy/raw/master/training/iOS内部分享第五期《组件化相关概念和规范》-黄振增-20160721/img/Runtime流程.png)

1）组件对外类别(Category)模块

```
@interface JFZRoute (JFZRouteKWLStockActions)

- (UIViewController *)jfzKWLStock_openAccountStock:(NSDictionary *)parameters autoPush:(BOOL)autoPush;

@end
```

<font color=red></font>

2）组件目标(Target)模块

```
@interface Target_JFZKWLStockAction : NSObject

//开户入口
- (UIViewController *)Action_openAccountStock:(NSDictionary *)parameters;

@end
```

### 3.现有方案对比分析
####方案一：基于协议调度
基于协议调度通过URL导航和Protocol实现。<br />
1）App启动过程时，根据本地路由表，映射各个模块和URL关系，注册必要的URL，用于各个模块直接的调度；<br />

2）模块调度，URL请求分为远程请求和本地请求；

<font color=red>远程请求形式为：</font>

```
jfz://jfz.com/fund/detail?id=123&type=0
```
参数为基本数据类型，如常见json格式：

| 类型          	| 描述           
| ------------- 	|------------------
| Number      	| 双引号的反斜杠转义的Unicode
| String      	| 双引号的反斜杠转义的Unicode
| Boolean 		| true 或 false
| Array 			| 值的有序序列
| Value 			| 可以是一个字符串，一个数字，真的还是假（true/false），空(null )等
| Object 			| 无序集合键值对
| Whitespace 		| 可以使用任何一对中的令牌
| null 			| empty

<font color=red>本地请求形式为：</font>

```
[JFZRoute loadUrl:@"/fund/detail" parameters:{id:1, type:0, model:[NSObject  new]}]
```
相比于远程请求，本地请求除了能够使用基本数据类型，同时能够使用复杂数据类型，如对象，结构体等；

3）接口参数形式<br/>
支持基础参数和复杂参数，如上所述。

4）参数对外暴露<br/>
不管是远程调用还是本地调用，参数的键值对（key-value）都存在于调用方，增加对外依赖和理解程度。

5）组件生命周期<br/>
部分组件和App生命周期一样，只有App消亡时，内存才被释放。

6）可插拔性<br/>
当组件移除后，App还能正常使用，不会造成崩溃

7）接口维护<br/>
需要文档维护URL列表，同时大家还要记住每个URL和参数对应模块

####方案二：基于运行时调度

基于运行时调度通过Runtime查找组件和Category实现。<br />
1）每个Category和Target一一对应，只有组件使用时才注册；

````
if ([target respondsToSelector:action]) {
	[target performSelector:action withObject:parameters]
}
````

2）模块调度，支持远程请求和本地请求；

<font color=red>远程请求形式为：</font>

```
jfz://jfz.com/fund/detail?id=123&type=0
```
当App之外的模块调用App时，“解析模块”，如JockeyJS或JLRoute，转译后，然后调用本地组件对外类别(Category)。

<font color=red>本地请求形式为：</font>

先对简单，调用本地组件对外类别(Category)，即可。

3）接口参数形式<br/>
组件间支持基础参数和特殊参数，如

````
- (UIViewController *)jfzKWLStock_openAccountStock:(NSDictionary *)parameters autoPush:(BOOL)autoPush;
````
通过函数参数形式，能够使用特殊参数，如对象，结构体，指针等

4）参数对外暴露程度<br/>
尽量使用函数参数传递，少使用自定义对象， 如自定义类，系统SDK中存在除外，
目的减少组件信息对外暴漏。

如，基金赎回组件，内部需要产品ID、购买使用银行卡、赎回完回调接口，可如下定义

````
- (void)jfzFZFund_redeemActionAfterAuthWithProductId:(NSString *)productId bankCardNumber:(NSString *)bankCardNumber completion:(void(^)(BOOL success))completionHandler；
````
需要更多参数输入，可以申明一个字典集合或数组参数。

5）组件生命周期<br />
使用时创建合适实例对象，使用完后及时销毁，运行时特性决定。

6）可插拔性<br/>
当组件移除后，App还能正常使用，不会造成崩溃

7）接口维护<br/>
所有对外接口，都集中在每个Category中，需要对每个接口做好注释和参数说明

***

### 4.我们的方案
基于上述分析，从维护和可扩展性看，采用第二种方案。<br />
1）组件对外接口能够很好披露，哪些方法和参数能够使用，一目了然；<br/>
2）组件对外Category开放，组件内部实现黑盒；通过注释代替文档；<br/>
3）动态加入组件，启动时不需要注册；<br/>


***

### 5.组件化步骤
组件一般分为基础组件、独立业务组件和非独立业务组件。

####1.基础组件
像项目第三方依赖的组件，如AFNetworking、SDWebImage和fmdb等基础组件，我们需要做的事情就是将一些基础组件从主工程剥离出来，形成产品自己的私有基础库仓库。

现项目公共组件：

|公共基础组件					|产品基础组件
|----------------			|----------------
| 组件化中间件 				|UI组件
| 网络监听 					|分类Category
| 日志上报 					|WebView容器
| 统计上报 					|登陆、激活和注册等上报
| 推送 						|弹窗
| 网络库封装 					|Loading组件
| 热修复 					|
| 长连接	 					|
| JockeyJS 					|
| ...... 					|......

基础组件可以被直接依赖使用，像系统自带SDK一样，可以不需要通过“组件中间件”调度。

####2.独立业务组件
基础组件之上，某些耦合相对较低或相对独立的业务模块，可以单独抽成组件，进行独立开发和测试。

常见业务组件，如

|独立业务组件				|独立业务组件		|独立业务组件
|----------------		|-------------	|------
| 吐槽反馈 					|UI组件				|常见问答
| 登陆 						|分享				|手势
| 基金	 					|保险				|固收
| 更多	 					|各种详情			|模拟炒股
| ...... 					|......			|......

独立业务组件一般通过“组件中间件”调度，实现组件解耦，尽量减少对外依赖。


####3.非独立组件
目前耦合严重，不太稳定模块，可以先不抽取，待时机成熟而做。

***

### 5.常见问题

####1.组件维护
1）接口最小化原则，尽量暴露少的接口；<br />
2）接口命名规范<br/>
Category以"jfz+模块名_"开头，如

```
jfzKWLStok_
```
Target以"Target_模块名_Action"形式，如

```
Target_KWLStok_Action
```
3）组件规范

####2.组件版本发布
组件版本号采用（x.y.z），即"主版本号.次版本号.修订版本号"。<br />
<font color=red>修订号：组件修复问题但没有影响API接口，增加修订号z+1；<br /></font>
<font color=red>次版本号：组件增加接口或兼容版本升级，增加次版本号y+1；<br /></font>
<font color=red>主版本号：减少或者修改接口，增加主版本号x+1； <br /></font>

####3.多个项目公共组件图片资源
两种方式：
1）同一个组件建立多个podspec，分别指向不同项目，如

```
GXQShareKit.podspec
s.resource_bundles = {
'GXQShareKit' => ['GXQShareKit/Assets/GXQShareKit/*.png']
}

JFZShareKit.podspec
s.resource_bundles = {
'JFZShareKit' => ['JFZShareKit/Assets/JFZShareKit/*.png']
}

```

2）同一个组件podspec基于环境变量方式，如

```
if ENV['TARGET'] == 'gxq'
    s.resource_bundles = {
      'testPod' => ['testPod/Assets/gxq/*.png']
    }
else
    s.resource_bundles = {
    'testPod' => ['testPod/Assets/jfz/*.png']
    }
end
```
当执行env TARGET=gxq pod update --no-repo-update
将加载gxq分支资源

####4.多个组件公共图片资源
将每个组件都存放一张公共图片，如返回按钮图片

####5.Route中间件维护
Route都集中于单个pod，多个项目间公用问题

####6.私有仓库维护
今后iOS移动端所有私有仓库地址：git@gitlab.jfz.net:iOS/JFZSpecs.git
公共组件和独立业务组件，都放到私有仓库；


***

### 6.参考资料
1. [版本号规范](http://semver.org/)


***