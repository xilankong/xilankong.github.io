## 认识动态库和静态库

### 1、库（Library）

库是指一段编译好的二进制代码，并提供头文件供别人使用。

### 2、动态库（Dynamic library）

动态库也称动态链接，是在程序编译时不会被链接到目标代码中，直到可执行文件被执行过程中才被加载调用，即按需加载。

### 3、静态库（Static library）

静态库也称静态链接，是在链接阶段，将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件 ( XXX.app 包内的exec ) 中。

### 4、搜索路径 （Search path）

搜索路径是指程序链接时，到哪个位置寻找库。

```
@executable_path：表示可执行程序所在的目录。
@loader_path：表示每一个被加载的 binary (包括App, dylib, framework, plugin等) 所在的目录。
@rpath：是一个保存着一个或多个路径的变量，告诉连接器到哪里找库。
```

### 5、Mach-O Type 

全称 Mach Object Type ，是一种用于存储可执行文件，目标代码，动态库，内核转储的文件格式。

Xcode中查看Target 的 Build Settings 可以发现可以选择，里面就包含了动态库和静态库。

#### 6、其他 

.tbd 文件格式: 存储跨平台模块映射的文本文件，Xcode7以后 .dylib格式 动态库替换为.tbd格式。

framework是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。

.a 文件

.o 文件

_CodeSignature 目录

.car 文件

Framework目录

der文件

exec文件

.bundle

## 静态库特点

1、常见以.a或.framework结尾。

2、静态库存储结构

当App依赖的第三方库采用静态库形式链接，编译器链接时，将收集编译好代码和第三方库，存储于App代码区域，即这些资源是App可执行文件的一部分。App启动时，存储于App代码区域的代码将加载到App寻址地址空间。其流程如下图

![](https://xilankong.github.io/resource/address_space1_2x.png)



## 动态库特点

1、常见以 .tbd 或 .dylib 或 .framework 结尾。（默认在.app包内的Framework文件夹中）

2、动态库最低支持版本 8.0

3、动态库存储结构

当App依赖的第三方库采用动态库形式链接，编译器链接时，将第三方库相对引用，存储于App代码区域，真实的依赖资源存储于操作系统或各个App共用路径下。App启动时，只加载需要的资源到App寻址地址空间，即按需索取。其流程如下图

![](https://xilankong.github.io/resource/address_space2_2x.png)



4、

App之间共用库，但是苹果本身是强制不允许的（进程间共享动态库是不允许的，iOS上的动态库只能是私有的，因此我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。）

但iOS8之后，开放了`App Extension`功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。

5、

签名：动态库都有签名

比如我们在.app包里可以看到 _CodeSignature 会出现在很多包含非系统资源的目录级，这个其实就相当于资源签名，也是为了防止热更新等操作。

6、

OC和Swift 都是C编写的，编译后都是.o文件 ，为什么混编的时候不能用动态库，只是因为苹果不允许OC Swift混编成库而已。。。

7、

@import 和 #import的区别 

```
#import 防止重复导入，
#import 相当于直接导入对应文件，而@import相当于引入一个对应文件的地址，需要使用的时候再去引入使用
@import 引入某个框架下得某个文件可以不需要明确框架，会自动引入。
#import 编译会慢一点

import 中得 <> 和 "" 的区别  查找路径优先级不同，<> 优先查找系统层再找用户自定义层，""相反 
```

import

动态库引入其他动态库的时候要用@import









# [iOS - 静态库的创建与使用](http://www.cnblogs.com/dingding3w/p/5338341.html)

　　在日常项目开发中,不论是为了两个公司项目上的业务交流还是为了减少项目的编译时间,有的时候我们会把项目中的私密内容打包成静态库,或者是把项目中变动较少一部分打包成静态库以便提高编译效率,那么下面我们就来学习一下"iOS-静态库的创建与使用":

(一)iOS静态库、动态库与Framework静态库与动态库的区别:

　　(1)什么是库？

　　　　库(Library)直白一点说就是一段编译好的二进制代码,加上头文件就可以供别人使用;(例如: iOS中Objective-C编译下的.h和.m文件,打包静态库后会变为.h和.a文件);

　　(2)什么是静态库？

　　　　①静态库即静态链接库(例如: windows下的.lib、Mac和Linux下的.a);

　　　　②静态库在编译的时候会被直接拷贝一份,复制到目标程序里并且这段代码在目标程序里就不会在改变了,我猜这也是该库叫"静态库"的原因;

　　　　③静态库的利弊:

　　　　　　1)利: 静态库在编译完成之后,库文件实际上就没有作用了,目标程序没有外部依赖,直接就可以运行;

　　　　　　2)弊: 弊端静态库会使用目标程序的体积增大;

　　(3)什么是动态库?

　　　　①动态库即动态链接库(例如: windows下的.dll、Mac下的.dylib、Linux下的.so);

　　　　②与静态库相反,动态库在编译时并不会被拷贝到目标程序中,目标程序中只会存储指向动态库的引用,等到程序运行时,动态库才会被真正加载进来;

　　　　③动态库的利弊:

　　　　　　1)利: 不需要拷贝到目标程序中,不会影响目标程序的体积,而且同一份库可以被多个程序使用(因为这个原因，动态库也被称作共享库); 同时,编译时才载入的特性,也可以让我们随时对库进行替换,而不需要重新编译代码;

　　　　　　2)弊: 动态载入会带来一部分性能损失,使用动态库也会使得程序依赖于外部环境;如果环境缺少动态库或者库的版本不正确,就会导致程序无法运行;

　　(4)什么时候我们会用到库呢?

　　　　①某些代码片段需要给别人使用,但是我们不希望别人看到源码,就需要以库的形式进行封装,只暴露出头文件;

　　　　②对于某些不会进行大的改动的代码,我们想减少编译的时间,就可以把它打包成库,因为库是已经编译好的二进制了,编译的时候只需要 Link 一下,不会浪费编译时间;

　　　　说明:上面提到库在使用的时候需要Link,Link 的方式有两种:静态和动态,于是便产生了静态库和动态库("攻城狮"的思维就是这么简单😄😄);

　　(5)iOS Framework?

　　　　①除了上面我们提到iOS的.a和.dylib之外,Mac OS/iOS 平台还可以使用 Framework,Framework实际上是一种打包方式,将库的二进制文件、头文件和有关的资源文件打包到一起,方便管理和分发;在 iOS 8 之前,iOS 平台不支持使用动态 Framework,开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework,Foundation.Framework 等等;

　　　　②上面这种限制可能是出于安全的考虑,换一个角度讲,因为 iOS 应用都是运行在沙盒当中,不同的程序之间不能共享代码,同时动态下载代码又是被苹果明令禁止的,没办法发挥出动态库的优势,实际上动态库也就没有存在的必要了;

　　　　③由于上面提到的限制,开发者想要在 iOS 平台共享代码,唯一的选择就是打包成静态库 .a 文件,同时附上头文件;但是这样的打包方式不够方便,使用时也比较麻烦,大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用;

　　　　④终于在日思夜盼便迎来了iOS对动态库的支持: iOS 8/Xcode 6 推出之后,iOS 平台添加了动态库的支持,同时 Xcode 6 也原生自带了 Framework 支持(动态和静态都可以);

　　　　⑤但是说道这里博主要告诉一下大家,iOS动态库且用且珍惜(小心应用审核被拒😄😄);

(二)切入主题"iOS静态库的创建":

　　(1)我们先了解静态库文件的版本(四种):

　　　　①真机-Debug版本;　　②真机-Release版本　　③模拟器-Debug版本　　④模拟器-Release版本;

　　(2)Debug(调试)版本特点:

　　　　①含完整的符号信息,以方便调试;　　②不会对代码进行优化;

　　(3)Release(发布)版本特点:

　　　　①不会包含完整的符号信息;　　②执行代码是进行过优化的;　　③大小会比Debug版本的略小　　④在执行速度方面,Release版本会快一些;

　　　　所以我们一般开发中都打包Release(发布)版本使用;

　　(4)再来了解一下iPhone设备CPU的架构简介:

　　　　①模拟器: (4s~5: i386)　　　　(5s~6splus: x86_64)

　　　　②真   机: (3gs~4s: armv7)　  (5~5c: armv7s)　　　　  (5s~6splus: arm64)[说明: 静态库只要支持了armv7,就可以跑在armv7s的架构上];



http://www.cnblogs.com/dingding3w/p/5338341.html