---
layout: post
category: 2017年
title : "iOS、OC基础知识"
---

## 运行时runtime

OC语言最大的特色，OC是C的升级、OC必须转为C然后再转为汇编。



### 实例 (instance)

实例 (instance)  到底是由什么构成，我们查看一下objc.h中的源码：

```
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;
/// Represents an instance of a class.
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
/// A pointer to an instance of a class.
typedef struct objc_object *id;
```

由此看出，我们创建的一个对象或实例其实就是一个struct objc_object结构体，而我们常用的动态类型 id 也就是这个结构体的指针。

我们创建的类的实例最终获取的都是一个结构体指针，这个结构体只有一个成员变量就是`Class`类型的`isa`指针，日常实例使用，我们调用实例的 class 方法，返回一个Class类型对象，也就是实例的类，并且可以通过这个class来初始化实例。所以我们可以知道： 这个Class就是代表这个实例的类，所以实例的isa指针指向的是这个实例的类。

```
NSString *str = [[NSString alloc] initWithString: @"Hello World"];
Class strClass = [str class];
NSString *str2 = [[strClass alloc] initWithString: @"Hello World"];

从这可以推断我们上面描述的 isa指针指向的就是这个实例的类。
```



## class object、metaclass

OC中的类本身也是一个对象：类对象（class object），上面实例中的 [str class] 方法返回的就是一个类对象。那么类对象又是什么？  `Class `是结构体指针，指向 结构体 ` objc_class` , 下面是这个结构体:

```
struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
    Class _Nullable super_class                             
    const char * _Nonnull name                              
    long version                                            
    long info                                                
    long instance_size                                       
    struct objc_ivar_list * _Nullable ivars                 
    struct objc_method_list * _Nullable * _Nullable methodLists                    
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
}
```

**这个结构体就是整个类对象，包含了实例对象和实例方法等创建所需的所有信息**，我们称这个结构体包含的数据为元数据(metadata)，在metadata中我们可以看到第一个参数依然是一个Class类型的 isa指针，这个类对象的isa指针指向的对象，我们称之为 元类（metaclass），**元类中存储了类对象和类方法等创建所需的所有信息**。

下面是一张网上copy的图，很详细的描述了整个闭环：



![](https://xilankong.github.io/resource/runtime-isa.png)





## 消息传递、消息转发



### objc_msgSend







http://www.cocoachina.com/ios/20170427/19145.html



isa指针的理解

```

```







运行时，swizling





方法转发 捕捉



动态绑定



动态链接



动态检查





runloop



事件响应链、传递链



触摸事件等



core graphics



引用计数



深复制浅复制



app生命周期



​	http://www.cocoachina.com/ios/20170427/19145.html



foundation kit



ui kit、动画



设计模式



线程并发



网络协议



文件数据处理



https抓包  网络部分 tcp/ip http/https socket ftp



和 webView、JS的交互



AFNetwork & Alamofire

- Masonry & SnapKit
- SDWebImage
- SwiftyJSON





bug检查排除



最后处理混编的问题、UI优化、编译优化



算法



最近处理过的复杂问题







常见关键字：

atomic：atomic意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，至少在当前的存取器上是安全的。它是一个默认的特性，但是很少使用。

nonatomic：nonatomic跟atomic刚好相反。表示非原子的，可以被多个线程访问。它的效率比atomic快。但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。

readwrite（默认）：readwrite是默认值，表示该属性同时拥有setter和getter。

readonly： readonly表示只有getter没有setter。

assign（默认）：assign用于值类型，如int、float、double和NSInteger，CGFloat等表示单纯的复制。还包括不存在所有权关系的对象，比如常见的delegate。

strong：strong是在IOS引入ARC的时候引入的关键字，是retain的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。strong跟retain的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。

weak：在setter方法中，需要对传入的对象不进行引用计数加1的操作。简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用weak声明的实例变量指向nil，即实例变量的值为0。（ARC IOS 5 之后）

copy：与strong类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身。

**其他



## iOS数据结构

### 链表

https://www.jianshu.com/p/12fe060811f2



### 堆和栈的区别

objective-c 对象所占内存总是分配在“堆空间”，并且堆内存是由你释放的，即release。
栈是由编译器管理自动释放的，在方法中（函数体）定义的变量通常在栈内。

1.栈区(stack):由编译器自动分配释放，存放函数的参数值，局部变量等值。其操作方式类似于数据结构中的栈。
2.堆区(heap):一般由程序员分配释放，若程序员不释放，则可能会引起内存泄漏。注 堆和数据结构中的堆栈不一样，其类似于链表。

栈是一个用来存储局部和临时变量的存储空间。在现代操作系统中,一个线程会分配一个栈. 当一个函数被调用,一个stack frame(栈帧)就会被压到stack里。里面包含这个函数涉及的参数,局部变量,返回地址等相关信息。当函数返回后,这个栈帧就会被销毁。而这一切都是自动的,由系统帮我们进行分配与销毁。对于程序员来说，我们无须自己调度。

堆从本质上来说，程序中所有的一切都在内存中（有些东西是不在堆栈中的，但在这篇文章中我们不作讨论）。在堆上，我们可以任何时候分配内存空间以及释放销毁它。你必须显示的请求在堆上分配内存空间，如果你不使用垃圾回收机制，你必须显示的去释放它。这就是在你的函数调用前需要完成的事情。简单来说，就是malloc与free。

通常以这种方式创建对象：
NSObject *obj = [[NSObject alloc] init];
系统会在栈上存储obj这个指针变量，它所指的对象在堆中。通过[NSObject alloc]系统会为其在堆中开辟一块内存空间，并为其生成NSObject所需内存结构布局。

栈对象：
     优点：1.高速，在栈上分配内存是非常快的。
                2.简单，栈对象有自己的生命周期，你永远不可能发生内存泄露。因为他总是在超出他的作用域时被自动销毁了
     缺点：栈对象严格的定义了生命周期也是其主要的缺点,栈对象的生命周期不适于Objective-C的引用计数内存管理方法。
在objective-c中只支持一个类型对象：blocks。
关于在block中的对象的生命周期问题。出现这问题的原因是，block是新的对象，当你使用block时候，如果你想对其保持引用，你需要对其进行copy操作，（从栈上copy到堆中，并返回一个指向他的指针），而不是对其进行retain操作
堆对象：
    优点：可以自己控制对象的生命周期。

    缺点：需要程序员手动释放，容易造成内存泄漏。



