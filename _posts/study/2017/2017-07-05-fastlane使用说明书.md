---
layout: post
category: 2017年
title : "fastlane使用说明书"
---

## 1.fastlane 介绍

fastlane是用Ruby语言编写的一套自动化工具集和框架，每一个工具实际都对应一个Ruby脚本，用来执行某一个特定的任务，而Fastlane核心框架则允许使用者通过类似配置文件的形式，将不同的工具有机而灵活的结合在一起，从而形成一个个完整的自动化流程。比如我需要完成一套发布流程：

```
#发布到AppStore

lane :release do
  #增加build版本号
  increment_build_number
  #pod资源更新
  cocoapods
  #打包
  gym
  #发布到AppleStore
  deliver(force: true)
end
```

#### 依赖环境：

- Xcode7 +
- macOS or Linux with Ruby 2.0.0 +

#### 本文版本：

fastlane版本：2.53.1

#### 安装：

[sudo] gem install fastlane

```
如果用的是mac自带的ruby，需要 sudo权限
使用: sudo gem install fastlane

如果报错：ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/commander 
使用: sudo gem install -n /usr/local/bin fastlane
```

#### 初始化：

在项目根目录下，初始化Fastlane：

fastlane init

会要求填写你的Apple ID，选择你的Team(如果有多个) 然后fastlane会自动检测当前目录下项目的App Name和App Identifier、Project。然后自行确认并按流程执行。

fastlane 初始化默认会创建三个文件：Fastfile、Appfile、Deliverfile；两个文件夹：metadata、screenshots

Fastfile : 核心文件，主要用于 cli 调用和处理具体的流程，lane相对于一个方法或者函数

Appfile : 存储有关开发者账号相关信息

Deliverfile: deliver工具的配置文件

#### 常用命令：

- fastlane actions: 展示所有有效action列表
- fastlane action [action_name]: 展示一个action的详细说明，使用方法等
- fastlane lanes: 展示fastfile中的所有lane
- fastlane list: 展示fastfile中的所有的有效的lane
- fastlane new_action: 创建一个新的action
- fastlane env: 打印fastlane、ruby环境，一般提bug到issue的时候会要求提供

#### 生命周期：

| 执行顺序 | 方法名         | 说明                     |
| ---- | ----------- | ---------------------- |
| 1    | before_all  | 在执行 lane 之前只执行一次       |
| 2    | before_each | 每次执行 lane 之前都会执行一次     |
| 3    | lane        | 自定义的任务                 |
| 4    | after_each  | 每次执行 lane 之后都会执行一次     |
| 5    | after_all   | 在执行 lane 成功结束之后执行一次    |
| 6    | error       | 在执行上述情况任意环境报错都会中止并执行一次 |



#### 其他：

1.如果Deliverfile、screenshots和metadata没有自动生成，通过deliver init 可以重新初始化

2.fastlane的配置会要求输入开发者账号密码，所有的密码都加密保存在系统的Keychain里

3.Matchfile: match 这个action的配置文件，fastlane match init 自动生成，存放git地址等

4.还有一些特殊情况也许并没有碰到，需要自行发掘



## 2.fastlane 使用

### lane的使用

lane是fastfile中的方法定义标签，可以理解为swift中定义一个函数，前面的 func。fastlane 都是基于ruby，所以fastfile中也是使用ruby语法的。

定义一个简单的无参lane

```
lane :package
	puts "这是一个lane"
end
```

定义一个带参的lane，在fastfile中option类似于一个字典集。我们可以通过  option[:configuration] 取其中value

```
 lane :package do |option| 
    configuration = option[:configuration]
    puts configuration
 end
 
 //lane的调用
 package(configuration: 'Release', export_method: 'ad-hoc')
```



### Action

除开我们自定义fastfile中的方法，fastlane还提供了很多已经写好的独立的方法库，也就是Actions。

Action是Fastlane自动化流程中的最小执行单元，直观上来讲就是Fastfile脚本中的一个个命令，而这些命令背后都对应一个用Ruby编写的脚本。

到目前为止，Fastlane的工具集大约包含180多个Action，基本上涵盖了打包，签名，测试，部署，发布，库管理等等移动开发中涉及到的内容。

```
fastlane actions : 查看action列表

fastlane action  action_name：查看具体action 描述
```

#### 常用Action

Action列表文档: [Actions](https://docs.fastlane.tools/actions/)

我们常用的主要包括下面几部分，其他action的使用可以参考官方文档:

- [scan](https://github.com/fastlane/fastlane/tree/master/scan) => 自动运行测试工具，并且可以生成漂亮的HTML报告
- [match](https://github.com/fastlane/fastlane/tree/master/match) => 一个新的证书和配置文件管理工具。把所有需要用到的证书传到git私有库上，任何需要配置的机器直接用match同步回来就不用管证书问题了
- [gym](https://github.com/fastlane/fastlane/tree/master/gym) => Fastlane家族的自动化编译工具，和其他工具配合的非常默契
- [deliver](https://github.com/fastlane/fastlane/tree/master/deliver) => 自动上传截图，APP的元数据，二进制(ipa)文件到iTunes Connect
- [pilot](https://github.com/fastlane/fastlane/tree/master/pilot) => 管理TestFlight的测试用户，上传二进制文件
- [spaceship](https://github.com/fastlane/fastlane/tree/master/spaceship) => 为pilot，boarding和deliver等工具提供和 iTC 和 ADC 的交互API。spaceship本来是个独立的项目，后来被Fastlane收编进来 [非官方的iTunes Connect JSON API的文档](https://github.com/fastlane/itc-api-docs)  

#### 常用Action使用

scan

```
release情况下无法正常运行scan，需要手动去Build Setting中更改enable Testability 在release 下的状态，改为 yes才可以运行。但是官方不建议做release下开启，Test一般在development configuration 下执行。
```

match

```
一个新的证书和配置文件管理工具。它会把所有需要用到的证书传到git私有库上，任何需要配置的机器直接用match同步回来就不用管证书问题了。保证大家用的都是同一份。不过我们一般都是一台机器需要用到distribution证书，所以意义不大。

1.match只认识通过match方式创建的pp文件 证书，其他方式创建的不予理会。
2.使用match 需要先撤销现在的证书。
3.如果苹果端的证书,pp文件已删除，那么远端git上的文件也会失效，并且在重新match的时候会失败,好像就只能删光 git端内容，重新match一遍。

常用参数：
git_url ： 指定对应git地址
git_branch ： 指定对应branch
type ：请求文件类型, appstore, adhoc, development, enterprise
app_identifier ： app_bundle_identify
clone_branch_directly : 只更新对应branch，只有在存在这个branch时才生效
force_for_new_devices : 如果设备devices列表更新了，就强制更新配置概要文件
verbose ：打印出额外的信息和所有的命令
```

gym

```
常用参数：
scheme ：指定打的哪个scheme
project ：指定project (未使用cocopods)
workspace ：指定workspace (使用cocopods)
clean ：打包前clean
xcargs ： 附加一些参数传递给xcodebuild 如： xcargs: 'DEBUG_INFORMATION_FORMAT="dwarf-with-dsym"',
export_method ：出包方法 app-store, ad-hoc, package, enterprise, development
configuration ： 指定构建App的配置  Release、Debug、自定义
output_directory ： 输出目录
output_name ：输出名称
include_symbols ：是否包含调试符号
include_bitcode ：是否开启bitcode

纯swift工程打包，在非appstore证书下签出来的包都缺少一个swiftsupport文件夹，里面放的是swift的支持库。
```

deliver

```

```

pilot

```

```

spaceship

```
spaceship其实一般fastfile中不会使用到，但是由于涉及到与ADC的通信，会出现一些奇奇怪怪的问题，所以对它也要有一点了解。

当我们通过CI 进行持续化的时候，会遇到如下问题：

Q1：通过CI去提交包到TestFlight/ITC的时候，需要生成一个特定于应用程序的密码:

1.https://appleid.apple.com/account/manage
2.生成一个 APP-SPECIFIC PASSWORDS，保留生成的特殊密码
3.使用环境变量提供这个密码给fastlane：  FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD

当然，你可以在CI指向的目标打包机中预先跑起来，并手动输入密码，密码会自动保存在keyChain中。

Q2：如果你的开发者账号设置了两步验证怎么办？

1.当第一次使用fastlane安装的时候，会要求提供两步验证核实你的身份来连接ADC，这个时候会将会话存到 spaceship 的 cookie，会话大概一个月有效期，但这肯定不是我们要求的
2.那问题来了，如果通过CI 的话，怎么去处理两步验证的问题，过期了怎么办？
3.我们可以通过fastlane去把这份cookie转成环境变量配置
4.fastlane spaceauth -u apple@krausefx.com  获取到一份配置内容,把这份内容配置在CI中，或者fastfile中，如下：
export FASTLANE_SESSION='---\n- !ruby/object:HTTP::Cookie\n  name: DES5c148586dfd451e55afbaaa5f62418f91\n  value: HSARMTKNSRVTWFla1+yO4gVPowH17VaaaxPFnUdMUegQZxqy1Ie1c2v6bM1vSOzIbuOmrl/FNenlScsd/NbF7/Lw4cpnL15jsyg0TOJwP32tC/NguPiyOaaaU+jrj4tf4uKdIywVaaaFSRVT\n  domain: idmsa.apple.com\n  for_domain: true\n  path: "/"\n  secure: true\n  httponly: true\n  expires: 2016-04-27 23:55:56.000000000 Z\n  max_age: \n  created_at: 2016-03-28 16:55:57.032086000 -07:00\n  accessed_at: 2016-03-28 19:11:17.828141000 -07:00\n'

fastfile 环境变量名称 FASTLANE_SESSION
```



上面提到的这些action都是常用的，正常打包流程必不可少的部分，还有一些常用于辅助作用的Action

- resign  ：重新签名

  ```
  fastlane sigh resign dev.ipa --signing_identity "证书ID" -p “dev.mobileprovision"
  ```

- get_info_plist_value  ：获取info.plist中得某个key的值

- set_info_plist_value  ：设置info.plist中得某个key的值

- increment_build_number  ：自动递增项目build号

- increment_version_number  ：自动递增项目版本号

以上两个都需要先配置好xcode, [配置文档](https://developer.apple.com/library/content/qa/qa1827/_index.html)


### 自定义Action

由于开发需求各自不同，已有的action不满足的情况下，Fastlane支持定义自己的Action。Fastlane为我们提供了现成的模板，即使你对Ruby的语法不熟悉，也没有关系，Fastlane是开源的嘛，可以直接下载源码看看别人的Action是怎么写的就知道了，我们可以在这个目录下找到所有的Action文件：

[Action_rbs](https://github.com/fastlane/fastlane/tree/master/fastlane/lib/fastlane/actions)

假设，我们针对pod的执行创建一个action来针对下面三种情况的执行

```
pod install --no-repo-update (避免master repo的每次更新耗时)
pod update --no-repo-update (避免master repo的每次更新耗时)
pod repo update XXX (私有repo的更新)
```

自定义Action的流程大约如下，首先，我们在终端中执行命令：

```
fastlane new_action
```

然后根据提示，在命令行中敲入action的名字pod，然后Fastlane会在当前目录的actions文件夹中帮我们创建了一个pod.rb的Ruby文件 （此处只有部分代码）

```
module Fastlane
  module Actions
    module SharedValues
      POD_CUSTOM_VALUE = :POD_CUSTOM_VALUE
    end
    class PodAction < Action
      def self.run(params)
        UI.message "Parameter API Token: #{params[:api_token]}"
      end
      ......
      def self.available_options
        # Define all options your action supports. 
      end
      ......
```

可以看到，自定义的Action都是隶属于Fastlane/Actions这个module，并且继承自Action这个父类。虽然模板中的内容还挺多，不过不用担心，大部分内容都是一些简单的文本描述，对于我们来说只需要重点关注这两个方法就行：

1. self.run方法：这里放置的是实际的业务处理代码。
2. self.available_options方法：这里声明需要对外暴露出的参数，没有声明的参数在执行过程中无法使用。

最终写完结果如下：

```
module Fastlane
  module Actions
    module SharedValues
      POD_INSTALL_CUSTOM_VALUE = :POD_INSTALL_CUSTOM_VALUE
    end
    class PodInstallAction < Action
      def self.run(params)
        repo = "-no-repo-update"
        command = []
        command << "pod install"
        if params[:repo_update]
          repo = "--repo-update"
        end
        command << repo
        if params[:verbose]
          command << "--verbose"
        end
        result = Actions.sh(command.join(' '))
        UI.success(command.join(' ') + " Successfully ")
        return result
      end

      def self.description
        "pod install action"
      end
      def self.details
        "verbose / repo-update"
      end
      def self.available_options
        [
        FastlaneCore::ConfigItem.new(key: :verbose,
                                       description: "Allow output detail in console",
                                       optional: true,
                                       is_string: false,
                                       default_value: false),
          FastlaneCore::ConfigItem.new(key: :repo_update,
                                       description: "Allow output detail in console",
                                       optional: true,
                                       is_string: false,
                                       default_value: false)
        ]
      end
      def self.output
      end
      def self.return_value
      end
      def self.authors
        ["yang"]
      end
      def self.is_supported?(platform)
        platform == :ios
      end
    end
  end
end
```

Action引用机制

远程引用

```
# 远程Git引用：
import_from_git(url: 'https://github.com/xilankong/ruby', branch: 'master')
# 复写发布项目的lane
lane :do_deliver_app do |options|
  # ...
end
```

本地引用

```
import "../GeneralFastfile"
actions_path '../custom_actions_folder/'
lane :appstore do |options|
  # ...
end
```



### Plugin

我们在使用Fastlane的时候常常会遇到这样的场景：

1. 我的自定义Action需要在多个内部项目中使用
2. 我觉得这个自定义Action很不错，想共享给其他的团队使用

此时，拷贝粘贴虽然可以解决问题，但并不是一个聪明的方案。将Action发布到Fastlane的官方仓库倒是一个不错的选择，但是官方仓库本身对Action的要求比较高，并不会接收非通用性的Action，即使接收了，整个发布周期也会比较长，而且以后无论是升级还是Bug修复，都依赖Fastlane本身的发版，大大降低了灵活性。

所以从1.93开始，Fastlane提供了一种Plugin的机制来解决这种问题。大家可以理解为：Plugin就是在Action的基础上做了一层包装，这个包装巧妙的利用了RubyGems这个相当成熟的Ruby库管理系统，所以其可以独立于Fastlane主仓库进行查找，安装，发布和删除。

我们甚至可以简单的认为：Plugin就是RubyGem封装的Action，我们可以像管理RubyGems一样来管理Fastlane的Plugin。

但是，如果为了多项目共享任务，或者共享fastfile，可以通过Action的远程引用机制。所以Plugin不过多介绍。



### 持续化打包还需要的Action

1.monkey

2.pod_install

3.ftp 提交远程服务器

4.测试日志解析

5.jira提交bug



## 3.常见问题

#### Fastlane安装问题

安装Fastlane(当前版本：ruby- 2.3.1、fastlane 2.45.0)

```
rvm安装 
curl -L get.rvm.io | bash -s stable  
安装成功后、启用rvm
source ~/.bashrc  
source ~/.bash_profile  
测试安装结果
rvm -v
升级ruby
rvm install 2.3.1
查看安装的所有ruby
rvm list
切换ruby
rvm use 2.3.1 
设置rvm默认版本
rvm --default 2.3.1

fastlane 安装：
sudo gem install -n /usr/local/bin fastlane
```




### 1.ruby版本必须高于2.0，测试本机2.0也无效，所以最好2.0+

出现的问题：

```
SSL errors can be caused by various components on your local machine.
Apple has recently changed their servers to require TLS 1.2, which may not be available to your system installed Ruby (2.0.0)
```

或者之前安装过fastlane会出现、由于fastlane 和 ruby版本不够

```
Connection reset by peer - SSL_connect 问题并且带有解释，让你更新ruby重装fastlane
```

更新完ruby 记得进行 fastlane重装(uninstall - install)  , 注意版本的切换, cocoapods也需要重新安装



Connection reset by peer - SSL_connect  问题全部exception

```
[17:14:30]: fastlane finished with errors
[17:14:30]: -----------------------------------------------------------------------
[17:14:30]: Connection reset by peer - SSL_connect
[17:14:30]: 
[17:14:30]: SSL errors can be caused by various components on your local machine.
[17:14:30]: Apple has recently changed their servers to require TLS 1.2, which may
[17:14:30]: not be available to your system installed Ruby (2.0.0)
[17:14:30]: 
[17:14:30]: The best solution is to use the self-contained fastlane version.
[17:14:30]: Which ships with a bundled OpenSSL,ruby and all gems - so you don't depend on system libraries
[17:14:30]:  - Use One-Click-Installer:
[17:14:30]:     - download fastlane at https://download.fastlane.tools
[17:14:30]: -----------------------------------------------------------
[17:14:30]:     - extract the archive and double click the `install`
[17:14:30]: -----------------------------------------------------------
[17:14:30]:  - Use Homebrew
[17:14:30]:     - update brew with `brew update`
[17:14:30]:     - install fastlane:
[17:14:30]: -----------------------------------------------------------
[17:14:30]:       - 🚀 `brew cask install fastlane` 🚀
[17:14:30]: -----------------------------------------------------------
[17:14:30]: for more details on ways to install fastlane please refer the documentation:
[17:14:30]: -----------------------------------------------------------
[17:14:30]:         🚀       https://docs.fastlane.tools          🚀   
[17:14:30]: -----------------------------------------------------------
[17:14:30]: 
[17:14:30]: You can also install a new version of Ruby
[17:14:30]: 
[17:14:30]: - Make sure OpenSSL is installed with Homebrew: `brew update && brew upgrade openssl`
[17:14:30]: - If you use system Ruby:
[17:14:30]:   - Run `brew update && brew install ruby`
[17:14:30]: - If you use rbenv with ruby-build:
[17:14:30]:   - Run `brew update && brew upgrade ruby-build && rbenv install 2.3.1`
[17:14:30]:   - Run `rbenv global 2.3.1` to make it the new global default Ruby version
[17:14:30]: - If you use rvm:
[17:14:30]:   - First run `rvm osx-ssl-certs update all`
[17:14:30]:   - Then run `rvm reinstall ruby-2.3.1 --with-openssl-dir=/usr/local`
[17:14:30]: 
[17:14:30]: If that doesn't fix your issue, please google for the following error message:
[17:14:30]:   'Connection reset by peer - SSL_connect'
[17:14:30]: -----------------------------------------------------------------------

[!] Connection reset by peer - SSL_connect
```

[ Error running 'requirements_osx_brew_update_system ruby-2.3.1](http://blog.csdn.net/qqlinxi/article/details/53648227)

如果使用RVM安装ruby，需要homebrew



#### 2.Jenkins 环境 RVM未激活问题

jenkins中获取不到在目标服务器安装的最新RVM 和 ruby、fastlane

解决方案 :

~/.bashrc 、~/.zshrc  、~/.zlogin 内容

```
PATH=$PATH:$HOME/.rvm/bin
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM 
```

在jenkins执行脚本内 启用RVM：

```
source $HOME/.rvm/scripts/rvm
```

[参考链接](https://reyesyang.info/articles/27-install-rvm-step-by-step-and-why-rvm-is-not-a-function)







