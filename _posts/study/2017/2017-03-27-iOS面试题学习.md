---
layout: post
category: 学习之路
title : "iOS面试题"
---

> 如果你不知道你接下来需要补充学习哪一部分知识，做点面试题吧。



### 基础部分



1、线程和进程有什么区别

```
进程是一个程序执行的实例，是资源分配的最小单位

线程是进程中的一个实例，是操作系统可以识别的最小执行和调度单位
```



2、说一下线程之间的通信

```
例如在多线程并发条件下，为了让线程之间可以更方便的共同完成一个任务，需要一些协调通信，采取的通信方式就是 等待、唤起。

也就是  wait()  和 notify()、 notifyAll()
```





5、hash算法

```
MD5 常用的文件完整性校验算法，加密算法
SHA-1

通过计算文件hash值
```





7、当用一个不存在的key来查找两个不同长度的字典，那么哪个效率会高？

```
表面上看可能是一样快，因为字典底层都用了哈希表，查找的时间复杂度为 O(1)，（最差的时候是O(n)）都是一样的，但是可能会由于两个哈希表的负载因子不同，倒是查找的时间也是不同的。
```



8、什么是指针常量和常量指针

```
指针常量是 常量，指针修饰它，这个常量的值是一个指针 int a； int *const b = &a;

常量指针本质是指针，常量修饰它  const int *p; 
```

9、不借用第三个变量，如何交换两个变量的值？

```
算术运算

int a,b;
a=10;b=12;
a=b-a; //a=2;b=12
b=b-a; //a=2;b=10
a=b+a; //a=10;b=10

位运算 异或

int a=10,b=12; //a=1010^b=1100;
a=a^b; //a=0110^b=1100;
b=a^b; //a=0110^b=1010;
a=a^b; //a=1100=12;b=1010;


栈实现

int exchange(int x,int y) 
{ 
stack S; 
push(S,x); 
push(S,y); 
x=pop(S); 
y=pop(S); 
}
```



10、用递归算法求1到n的和

```
func add(n: Int) -> Int {
    var sum = 0
    if n > 0 {
        sum = n + add(n: n - 1)
    } else {
        sum = 0
    }
    return sum
}
```

11、http的post和get啥区别？（区别挺多的，麻烦多说点）

```
这个可以说很多。不希望听到的答案有

两个差不多，随便用一个。
post比get安全（其实两个都不安全）
能说下两个http格式有什么不同，各自应用的场景就合格了。更多可以阅读下这个答案。

我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？我很想知道！
很多人都很排斥数据结构和算法题，我个人意见是复杂的可以不知道，基础的一定要了解。时间复杂度是什么得知道，list，queue，stack，table，tree这些都要明白是啥。连hash表的概念都不知道怎么能保证在写代码的时候注意性能呢。
```



47、解释下tcp的慢启动特性。



48、如何用HTTP实现长连接？



49、HTTP2.0针对同一个域名的多个请求，会建立多少个tcp连接？



聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。



### iOS部分

1、block分几种？分别是怎么样产生的？block的实质是什么？

```
在内存角度来看，block分为 全局 、栈 和 堆 三种类型，

有强制转引用的block就属于堆内存block

只用到外部局部变量、成员属性变量、没有强指针引用的block属于栈block

只引用全局变量或静态变量的block，生命周期和程序生命周期一样的block就是全局block

block的实质是一个对象，一个结构体
```



2、__block修饰的变量为什么能在block里面能改变其值？

```
__block修饰符标记后，block就会访问标记变量本身内存地址，而未标记对象则访问截获拷贝后的变量的内存地址
```



3、NSDictionary的实现原理是什么？

```
hash表
```



4、你们的App是如何处理本地数据安全的（比如用户名的密码）？

```
AES  DES
```



5、遇到过BAD_ACCESS的错误吗？你是怎样调试的？

```
1、xcode可以用僵尸模式打印出对象 然后通过对象查找对应的代码位置

sudo malloc_history 1527 0x7ff8fdd2f9c0


2、重写一个object的respondsToSelector方法，打印报错前的

-(BOOL) respondsToSelector:(SEL)aSelector {  
    printf("SELECTOR: %s\n", [NSStringFromSelector(aSelector) UTF8String]);  
    return [super respondsToSelector:aSelector];  
}


通过instruments的Zombies
```

6、如何设计一个通知中心



7、如何去设计一个方案去应对后端频繁更改的字段接口？



8、KVO、KVC的实现原理

```
1.KVO是基于runtime机制实现的

2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制

3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person

4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法

5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。


1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：?NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter?方法，setter?方法会负责在调用原?setter?方法之前和之后，通知所有观察对象属性值的更改情况。

2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；

3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。

4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）?因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。

5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath?的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath?的属性值已经变更；之后，?observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter?方法这种继承方式的注入是在运行时而不是编译时实现的。

```





9、category为什么不能添加属性？

```
category 它是在运行期决议的，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。

extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。

但是category则完全不一样，它是在运行期决议的。 
就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的。

那为什么 使用Runtime技术中的关联对象可以为类别添加属性。

其原因是：关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。

如合清理关联对象？

runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。（详见Runtime的源码）
```



10、说一下runloop和线程的关系

```
runloop与线程是一一对应的

runloop是来管理线程的

线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）
```

11、说一下autoreleasePool的实现原理

```

```



12、说一下简单工厂模式，工厂模式以及抽象工厂模式？

```

```



13、如何设计一个网络请求库

```


```



14、说一下多线程，你平常是怎么用的？



15、说一下UITableViewCell的卡顿你是怎么优化的？



16、看过哪些三方库？说一下实现原理以及好在哪里？



17、说一下HTTP协议以及经常使用的code码的含义。



18、什么是arc？（arc是为了解决什么问题诞生的？）

```
现在有不少程序员是直接从arc上手的，从没接触过mrc，对arc的理解仅仅停留在apple帮助管理内存的层面。这个问题真正想了解的是对内存管理的理解，retain release虽然不用写了，但arc下还是会有内存泄漏野指针crash的bug存在。如果能从retain count这种内存管理策略的角度去阐述arc诞生的意义就算答对了。如果还能扯下其他类型的策略，比如java里的mark and sweep，那就加分点赞。
```

19、请解释以下keywords的区别： assign vs weak, __block vs __weak

```
这道题属于基础语法题，可以网上搜到答案。不过真有不少同学不知道weak在对象释放后会置为nil。__block关键字的理解稍微难点，因为在arc和mrc下含义（对retain count的影响）完全不同。理解了这几个关键字就能应付使用block时引入retain cycle的风险了。这题还在内存管理的范畴之内。
```

20、使用atomic一定是线程安全的吗？

```
看这题的问法不用想答案肯定是NO。有些人说不出所以然，有些人知道通过property的方式使用才能保证安全，还有人知道这个用来做多线程安全会有性能损耗，更有出色的候选人能谈atomic,synchronized,NSLock,pthread mutex,OSSpinLock的差别
```

21、描述一个你遇到过的retain cycle例子。(别撒谎，你肯定遇到过)



22、+(void)load; +(void)initialize；有什么用处？

```

```



23、谈一谈消息发送 或者 对runtime的理解



24、如何高性能的给UIImageView加个圆角？



25、设计一套缓存策略（麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的））

```
内存缓存是个通用话题，每个平台都会涉及到。cache算法会影响到整个app的表现。候选人最好能谈下自己都了解哪些cache策略及各自的特点。常见的有FIFO,LRU,LRU-2,2Q等等。由于NSCache的缓存策略不透明，一些app开发者会选择自己做一套cache机制，其实并不难。
```



26、设计一个检测主线和卡顿的方案



27、说一下runtime，工作是如何使用的？看过runtime源码吗？



28、说几个你在工作中使用到的线程安全的例子



29、用过哪些锁？哪些锁的性能比较高？



30、说一下HTTP和HTTPs的请求过程？



31、说一下TCP和UDP



32、说一下静态库和动态库之间的区别



33、load和initialize方法分别在什么时候调用的？



34、NSNotificationCenter是在哪个线程发送的通知？



35、用过swift吗？如果没有，平常有学习吗？



36、说一下你对架构的理解？



37、为什么一定要在主线程里面更新UI？



38、ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？（把UIImageView放到UITableViewCell里面问更赞）

```
很多同学没有读源码的习惯，别人的轮子拿来只是用用却不知道真正的营养都在源代码里面。这两个经典的framework代码并不复杂，很值得一读。能对一个UIImageView怎么通过url展示一张图片有完整的理解。涉及到的知识点也非常多，UITableViewCell的复用，memory cache, disk cache, 多线程切换，甚至http协议本身都需要有一定的涉及。
```



39、讲讲你用Instrument优化动画性能的经历吧



40、loadView是干嘛用的？



41、viewWillLayoutSubView

```
controller layout触发的时候，开发者有机会去重新layout自己的各个subview。说UI熟悉的一定要知道。
```

42、GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？

```
两种queue，串行和并行。main queue是串行，global queue是并行。有些开发者为了在工作线程串行的处理任务会自己建立一个serial queue。背后是苹果维护的线程池，各种queue要用线程都是这个池子里取的。GCD大家都用过，但很多关键的概念不少人都理解的模凌两可。串行，并行，同步，异步是GCD的核心概念。
```



43、用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？

```
没用过sqlite是说不过去的。用过CoreData的肯定有很多血泪史要说。多谢线程模型你肯定做过比较选择。死锁是啥肯定也是要知道的，没遇到过至少能举个简单的例子来说明。单个线程可以死锁（main thread里dispatch_sync到main queue），多个线程直接也可以死锁（A，B线程互相持有对方需要的资源且互相等待）。
```



44、NSString如何计算字符的个数？

```

```



45、PKI体系当中加密和签名有什么区别？



46、如何自己高效实现NSUserDefault?



47、数据库建表的时候索引有什么用？



48、Full Text Search为什么快？



49、iOS下如何实现指定线程数目的线程池？



50、函数式编程当中的 first-class function是什么意思呢？



51、如何使用runtime hook一个class的某个方法，又如何hook某个instance的方法？



52、谈下Objective C都有哪些锁机制，你一般用哪个？



53、让你设计一种机制检测UIViewController的内存泄漏，你会怎么做？



54、通过[UIImage imageNamed:]生成的对象什么时候被释放？



55、applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。



56、如何终止正在运行的工作线程？



57、穷举iOS下所有的本地持久化方案。



58、项目中网络层如何做安全处理

```
尽量使用https

不要传输明文密码

Post并不比Get安全

不要使用301跳转

http请求都带上MAC

http请求使用临时密钥

AES使用CBC模式

1、尽量使用https

https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。

2、不要传输明文密码

不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh

token去申请新的token。

3、Post并不比Get安全

事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。

4、不要使用301跳转

301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。

5、http请求都带上MAC

所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication

Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request

params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。

6、http请求使用临时密钥

高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES

key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES

key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。

7、AES使用CBC模式

不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。
```





59、**假如Controller太臃肿，如何优化？**

**1.将网络请求抽象到单独的类中**

方便在基类中处理公共逻辑；

方便在基类中处理缓存逻辑，以及其它一些公共逻辑；

方便做对象的持久化。

**2.将界面的封装抽象到专门的类中**

构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。

**3.构造 ViewModel**

借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。

**4.专门构造存储类**

专门来处理本地数据的存取。

**5.整合常量**





60、M、V、C相互通讯规则你知道的有哪些？









http://www.cocoachina.com/ios/20180305/22453.html