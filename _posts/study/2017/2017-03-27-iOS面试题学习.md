---
layout: post
category: 学习之路
title : "iOS面试题"
---

> 如果你不知道你接下来需要补充学习哪一部分知识，做点面试题吧。



## 基础部分



#### 1、线程和进程有什么区别

```
进程是一个程序执行的实例，是资源分配的最小单位

线程是进程中的一个实例，是操作系统可以识别的最小执行和调度单位
```



#### 2、说一下线程之间的通信

```
例如在多线程并发条件下，为了让线程之间可以更方便的共同完成一个任务，需要一些协调通信，采取的通信方式就是 等待、唤起。

也就是  wait()  和 notify()、 notifyAll()
```



#### 5、hash算法

```
MD5 常用的文件完整性校验算法，加密算法
SHA-1

通过计算文件hash值
```



#### 6、当用一个不存在的key来查找两个不同长度的字典，那么哪个效率会高？

```
表面上看可能是一样快，因为字典底层都用了哈希表，查找的时间复杂度为 O(1)，（最差的时候是O(n)）都是一样的，但是可能会由于两个哈希表的负载因子不同，倒是查找的时间也是不同的。
```



#### 7、什么是指针常量和常量指针

```
指针常量是 常量，指针修饰它，这个常量的值是一个指针 int a； int *const b = &a;

常量指针本质是指针，常量修饰它  const int *p; 
```



#### 8、不借用第三个变量，如何交换两个变量的值？

```
算术运算

int a,b;
a=10;b=12;
a=b-a; //a=2;b=12
b=b-a; //a=2;b=10
a=b+a; //a=10;b=10

位运算 异或

int a=10,b=12; //a=1010^b=1100;
a=a^b; //a=0110^b=1100;
b=a^b; //a=0110^b=1010;
a=a^b; //a=1100=12;b=1010;


栈实现

int exchange(int x,int y) 
{ 
stack S; 
push(S,x); 
push(S,y); 
x=pop(S); 
y=pop(S); 
}
```



#### 9、用递归算法求1到n的和

```
func add(n: Int) -> Int {
    var sum = 0
    if n > 0 {
        sum = n + add(n: n - 1)
    } else {
        sum = 0
    }
    return sum
}
```



#### 10、http 的 POST 和 GET 啥区别？

```

最直观的区别就是GET是获取数据、POST是提交数据

GET请求的数据会附在URL之后

POST把提交的数据则放置在是HTTP包的包体中

GET请求URL受浏览器影响 所以有长度限制

POST没有

POST的数据传输不是直接拼接URL 所以相对安全一些

```



#### 11、解释下tcp的慢启动特性

```
慢启动通过逐步增大拥塞窗口的值来控制网络拥塞。

通常在刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段的数值。而在每收到一个对新报文段的确认后，把拥塞窗口增加至多一个MSS数值。

也就是说，第一次时发送1个报文，在收到接收端确认之后，第二次时发送2个报文，同样都确认后，第三次时发送4个报文，2倍指数增长。

它的名字虽然叫慢启动，但实际上一点不慢，因为指数增长是很快的，所以它需要一个上限值，默认为64k。

慢启动的作用就是最大限度使用网络资源。
```



#### 12、如何用HTTP实现长连接？



#### 13、HTTP2.0针对同一个域名的多个请求，会建立多少个tcp连接？



#### 14、聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。



#### 15、通信底层原理（OSI七层模型）

```
OSI采用了分层的结构化技术，共分七层：
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
```



#### 16、介绍一下XMPP？

```
XMPP是一种以XML为基础的开放式实时通信协议。
简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。
```



17、ssl/tls证书作用



18、Socket连接和Http连接区别

```
Http是基于Tcp的，而Socket是一套编程接口让我们更方便的使用Tcp/Ip协议；Http是应用层协议，在Tcp/Udp上一层。
1：Http是基于"请求-响应"的，服务器不能主动向客户端推送数据，只能借助客户端请求到后向客户端推送数据，而Sokcet双方随时可以互发数据；
2：Http不是持久连接的，Socket用Tcp是持久连接；
3：Http基于Tcp，Socket可以基于Tcp/Udp；
4：Http连接是通过Socket实现的；
5：Http连接后发送的数据必须满足Http协议规定的格式：请求头、请求头和请求体，而Socket连接后发送的数据没有格式要求。
```





#### 27、说一下HTTP协议以及经常使用的code码的含义。

```
一些常见的状态代码为：

200 - 服务器成功返回网页
404 - 请求的网页不存在
503 - 服务器暂时不可用

1xx（临时响应）

用于表示临时响应并需要请求者执行操作才能继续的状态代码。
100（继续） 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。

101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备进行切换。

2xx（成功）

用于表示服务器已成功处理了请求的状态代码。
200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。

201（已创建） 请求成功且服务器已创建了新的资源。

202（已接受） 服务器已接受了请求，但尚未对其进行处理。

203（非授权信息） 服务器已成功处理了请求，但返回了可能来自另一来源的信息。

204（无内容） 服务器成功处理了请求，但未返回任何内容。

205（重置内容） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。

206（部分内容） 服务器成功处理了部分 GET 请求。

3xx（已重定向）

要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。
300（多种选择） 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。

301（永久移动） 请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。

302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。

303（查看其他位置） 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。

304（未修改）
自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。
如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销

305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。

307（临时重定向） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。

4xx（请求错误）

这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。
400（错误请求） 服务器不理解请求的语法。

401（未授权） 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。

403（已禁止） 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码（您可在 Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。

404（未找到）
服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。
如然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 robots.txt）。
如果您在 Googlebot 尝试抓取的网址上发现此状态（位于"诊断"标签的 HTTP 错误页上），那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。

405（方法禁用） 禁用请求中所指定的方法。

406（不接受） 无法使用请求的内容特性来响应请求的网页。

407（需要代理授权） 此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。

408（请求超时） 服务器等候请求时超时。

409（冲突） 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。

410（已删除） 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。

411（需要有效长度） 服务器不会接受包含无效内容长度标头字段的请求。

412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。

413（请求实体过大） 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。

414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法进行处理。

415（不支持的媒体类型） 请求的格式不受请求页面的支持。

416（请求范围不符合要求） 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。

417（未满足期望值） 服务器未满足"期望"请求标头字段的要求。

5xx（服务器错误）

这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。
500（服务器内部错误） 服务器遇到错误，无法完成请求。

501（尚未实施） 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。

502（错误网关） 服务器作为网关或代理，从上游服务器收到了无效的响应。

503（服务不可用） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。

504（网关超时） 服务器作为网关或代理，未及时从上游服务器接收请求。

505（HTTP 版本不受支持） 服务器不支持请求中所使用的 HTTP 协议版本。

```



19、Tcp三次握手、四次挥手



39、说一下HTTP和HTTPs的请求过程？



#### 17、聊一聊二叉树搜索（Binary search tree）



https://www.jianshu.com/p/d6a2eabc8549



https://zhuanlan.zhihu.com/p/33695619



leetCode

剑指offer





## iOS部分



#### 1、block分几种？分别是怎么样产生的？block的实质是什么？

```
在内存角度来看，block分为 全局 、栈 和 堆 三种类型，

有强制转引用的block就属于堆内存block

只用到外部局部变量、成员属性变量、没有强指针引用的block属于栈block

只引用全局变量或静态变量的block，生命周期和程序生命周期一样的block就是全局block

block的实质是一个对象，一个结构体
```



#### 2、__block修饰的变量为什么能在block里面能改变其值？

```
__block修饰符标记后，block就会访问标记变量本身内存地址，而未标记对象则访问截获拷贝后的变量的内存地址
```



#### 3、block应该用copy关键字还是strong关键字？

```
block 使用 copy 是从 MRC 遗留下来的“传统”

在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区。

在 ARC 中写不写都行

对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
```



#### 4、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的

```
@property = ivar + getter + setter;

“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）

“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。
```



#### 5、用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？

```
用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。

//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。

这里还有一个引申问题：

NSMutableArray 如果用 copy修饰了会出现什么问题?

Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x600000a100c0'

由于使用的是copy属性，本身的可变属性默认有一个不可变的拷贝 NSArray ，所以我们用这个可变数组去添加元素的时候，找不到对应方法而发生crash。

```



#### 6、浅拷贝和深拷贝的区别？

```
浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。

只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制
```



#### 7、@synthesize 和 @dynamic 分别有什么作用？

```
@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。
如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;
// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)
1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。

```



#### 8、如何让自己的类用copy修饰符

```
若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：
    1. 需声明该类遵从 NSCopying 协议
    2. 实现 NSCopying 协议的方法。
        // 该协议只有一个方法: 
        - (id)copyWithZone:(NSZone *)zone;
        // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。

```



#### 9、ViewController生命周期

```
按照执行顺序排列：
1. initWithCoder：通过nib文件初始化时触发。
2. awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      
3. loadView：开始加载视图控制器自带的view。
4. viewDidLoad：视图控制器的view被加载完成。  
5. viewWillAppear：视图控制器的view将要显示在window上。
6. updateViewConstraints：视图控制器的view开始更新AutoLayout约束。
7. viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。
8. viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。
9. viewDidAppear：视图控制器的view已经展示到window上。 
10. viewWillDisappear：视图控制器的view将要从window上消失。
11. viewDidDisappear：视图控制器的view已经从window上消失。
```

#### 10、OC的反射机制

```
1). class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@"student"); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);
2). SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@"setName");  
        [stu performSelector:selector withObject:@"Mike"];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
```

#### 11、self 和 super

```
self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。
上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。

```



#### 12、id 和 NSObject＊的区别

```
id是一个 objc_object 结构体指针，定义是
typedef struct objc_object *id
id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。

NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。

不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。

```



#### 13、NSDictionary的实现原理是什么？

```
一：字典原理

NSDictionary（字典）是使用hash表来实现key和value之间的映射和存储的

方法：- (void)setObject:(id)anObject forKey:(id)aKey;

Objective-C中的字典NSDictionary底层其实是一个哈希表

二：哈希原理

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。

哈希概念:哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。

三：哈希存储过程

1.根据 key 计算出它的哈希值 h。

2.假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。

3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。

在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。

哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为:

负载因子 = 总键值对数 / 箱子个数

负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。

哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。

哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。

基于以上总结，细心的朋友可能会发现哈希表的两个问题:

1.如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。

2.如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。

```



#### 14、你们的App是如何处理本地数据安全的（比如用户名的密码）？

```
AES  DES
```



#### 15、遇到过BAD_ACCESS的错误吗？你是怎样调试的？

90%的错误来源在于对一个已经释放的对象进行release操作, 或者说对一个访问不到的地址进行访问，可能是由于些变量已经被回收了，亦可能是由于使用栈内存的基本类型的数据赋值给了id类型的变量。

例如：

```

id x_id = [self performSelector:@selector(returnInt)];
    
- (int)returnInt { return 5; }

上面通过id去接受int返回值，int是存放在栈里面的，堆内存地址如何找得到，自然就是 EXC_BAD_ACCESS。

```

**处理方法**

1、xcode可以用僵尸模式打印出对象 然后通过对象查找对应的代码位置

```
1、Edit Scheme - Diagnositics - Memory Management 勾选 Zombie Objects 和 Malloc Stack

2、会打印出 
cyuyan[7756:17601127] *** -[UIViewController respondsToSelector:]: message sent to deallocated instance 0x7fe71240d390

这句开启僵尸模式后打出来的输出，包含了我们需要的 进程pid、崩溃地址，终端通过下面命令查看堆栈日志来找到崩溃代码

3、查找日志
sudo malloc_history 7756 0x7fe71240d390
```



2、在 other c flags中加入-D FOR_DEBUG（记住请只在Debug Configuration下加入此标记）。这样当你程序崩溃时，Xcode的console上就会准确地记录了最后运行的object的方法。重写一个object的respondsToSelector方法，打印报错前的

```
#ifdef _FOR_DEBUG_  
-(BOOL) respondsToSelector:(SEL)aSelector {  
    printf("SELECTOR: %s\n", [NSStringFromSelector(aSelector) UTF8String]);  
    return [super respondsToSelector:aSelector];  
}  
#endif
```

3、通过instruments的Zombies



**怎么定位到野指针的地方。如果还没定位到，这个对象被提前释放了，怎么知道该对象在什么地方释放的**





#### 16、如何设计一个通知中心



#### 17、如何去设计一个方案去应对后端频繁更改的字段接口？



#### 18、KVO、KVC的实现原理

**KVC实现**

键值编码

```
1.KVC是基于runtime机制实现的

2、可以访问私有成员变量、可以间接修改私有变量的值


[object setValue:@"134567" forKey:@"uid"];

就会被编译器处理成:
// 首先找到对应sel
SEL sel = sel_get_uid("setValue:forKey:");
// 根据object->isa找到sel对应的IMP实现指针
IMP method = objc_msg_lookup (object->isa,sel);
// 调用指针完成KVC赋值
method(object, sel, @"134567", @"uid");

KVC键值查找原理

setValue:forKey:搜索方式

1、首先搜索setKey:方法.(key指成员变量名, 首字母大写)
2、上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名.(NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)
3、如果没有找到成员变量, 调用setValue:forUnderfinedKey:

valueForKey:的搜索方式

1、首先按getKey, key, isKey的顺序查找getter方法, 找到直接调用. 如果是BOOL、int等内建值类型, 会做NSNumber的转换.
2、上面的getter没找到, 查找countOfKey, objectInKeyAtindex, KeyAtindexes格式的方法. 如果countOfKey和另外两个方法中的一个找到, 那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法.
3、还没找到, 查找countOfKey, enumeratorOfKey, memberOfKey格式的方法. 如果这三个方法都找到, 那么就返回一个可以响应NSSet所有方法的代理集合.
4、还是没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey, key, iskey的顺序搜索成员名.
5、再没找到, 调用valueForUndefinedKey.




当一个对象调用setValue方法时，方法内部会做以下操作：
1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。
2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。
3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。
4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。

```



**KVO实现**

键值观察、观察者模式的一种应用

```
基础

1.KVO是基于runtime机制实现的

2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制

3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person

4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法

5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。

深入

1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：?NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter?方法，setter?方法会负责在调用原?setter?方法之前和之后，通知所有观察对象属性值的更改情况。

2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；

3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。

4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）?因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。

5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath?的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath?的属性值已经变更；之后，?observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter?方法这种继承方式的注入是在运行时而不是编译时实现的。

```



#### 19、category为什么不能添加属性？

```
category 它是在运行期决议的，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。

extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。

但是category则完全不一样，它是在运行期决议的。 
就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的。

那为什么 使用Runtime技术中的关联对象可以为类别添加属性。

其原因是：关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。

如合清理关联对象？

runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。（详见Runtime的源码）
```



#### 20、说一下runloop和线程的关系

```
runloop与线程是一一对应的

runloop是来管理线程的

线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）
```

#### 21、说一下autoreleasePool的实现原理

```
在自动释放池被销毁或耗尽时，会向池中的所有对象发送release消息，释放所有autorelease对象。

ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool

AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage作为结点以双向链表的形式组合而成，会在一个Page空间占满时进行增加，objc_autoreleasePoolPop(哨兵对象)

主线程：

runloop默认开启，每一次运行循环开始，也就是每当事件被触发时都会创建自动释放池。运行循环结束前会释放自动释放池，还有池子满了也会销毁。

子线程：

runloop默认不开启，不会自动创建自动释放池，在需要使用自动释放池的时候，需要我们手动创建、添加自动释放池，此时如果所有的异步代码都写在自动释放池中，也可以理解为当子线程销毁的时候，自动释放池释放
```



#### 22、说一下简单工厂模式，工厂模式以及抽象工厂模式？

```

```



#### 23、如何设计一个网络请求库

```


```



#### 24、说一下多线程，你平常是怎么用的？



#### 25、说一下UITableViewCell的卡顿你是怎么优化的？



#### 26、看过哪些三方库？说一下实现原理以及好在哪里？





#### 28、什么是ARC？（ARC是为了解决什么问题诞生的？）

```

ARC全称是 Automatic Reference Counting，是Objective-C的内存管理机制。简单地来说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。

ARC的使用是为了解决对象retain和release匹配的问题。以前手动管理造成内存泄漏或者重复释放的问题将不复存在。

以前需要手动的通过retain去为对象获取内存，并用release释放内存。所以以前的操作称为MRC (Manual Reference Counting)。

```



#### 29、请解释以下keywords的区别： assign vs weak,  _block vs  _weak

```
这道题属于基础语法题，可以网上搜到答案。不过真有不少同学不知道weak在对象释放后会置为nil。__block关键字的理解稍微难点，因为在arc和mrc下含义（对retain count的影响）完全不同。理解了这几个关键字就能应付使用block时引入retain cycle的风险了。这题还在内存管理的范畴之内。


```



#### 30、使用atomic一定是线程安全的吗？

```
看这题的问法不用想答案肯定是NO。有些人说不出所以然，有些人知道通过property的方式使用才能保证安全，还有人知道这个用来做多线程安全会有性能损耗，更有出色的候选人能谈atomic,synchronized,NSLock,pthread mutex,OSSpinLock的差别
```



#### 31、描述一个你遇到过的retain cycle例子



#### 32、+(void)load;  +(void)initialize; 有什么用处？方法分别在什么时候调用的?

```
+(void)load;
当类对象被引入项目时, runtime 会向每一个类对象发送 load 消息。
load 方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类, 子类优先于分类。
由于 load 方法会在类被 import 时调用一次,而这时往往是改变类的行为的最佳时机，在这里可以使用例如 method swizlling 来修改原有的方法。
load 方法不会被类自动继承。
+(void)initialize;
也是在第一次使用这个类的时候会调用这个方法，也就是说 initialize 也是懒加载

总结：

在 Objective-C 中，runtime 会自动调用每个类的这两个方法
1.+load 会在类初始加载时调用
2.+initialize 会在第一次调用类的类方法或实例方法之前被调用
这两个方法是可选的，且只有在实现了它们时才会被调用
两者的共同点：两个方法都只会被调用一次

```



#### 33、谈一谈消息发送 或者 对runtime的理解, 说一下工作是如何使用runtime的？看过runtime源码吗？



#### 34、如何高性能的给UIImageView加个圆角？

```
如何高性能的给 UIImageView 加个圆角?

不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。

self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;
正确的解决方案：使用绘图技术

- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}
还有一种方案：使用了贝塞尔曲线"切割"个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。

UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];

```





#### 35、设计一套缓存策略（麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的））

```
内存缓存是个通用话题，每个平台都会涉及到。cache算法会影响到整个app的表现。候选人最好能谈下自己都了解哪些cache策略及各自的特点。常见的有FIFO,LRU,LRU-2,2Q等等。由于NSCache的缓存策略不透明，一些app开发者会选择自己做一套cache机制，其实并不难。
```



#### 36、设计一个检测主线和卡顿的方案



#### 37、说几个你在工作中使用到的线程安全的例子



#### 38、用过哪些锁？哪些锁的性能比较高？谈下Objective C都有哪些锁机制，你一般用哪个？





#### 32、说一下静态库和动态库之间的区别





#### 34、NSNotificationCenter是在哪个线程发送的通知？



#### 36、说一下你对架构的理解？ 技术架构如何搭建？





有关架构方面



[参考文章一 ](https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)

[参考文章二](https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html)



#### 37、为什么一定要在主线程里面更新UI？



#### 38、ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？（把UIImageView放到UITableViewCell里面问更赞）

```
很多同学没有读源码的习惯，别人的轮子拿来只是用用却不知道真正的营养都在源代码里面。这两个经典的framework代码并不复杂，很值得一读。能对一个UIImageView怎么通过url展示一张图片有完整的理解。涉及到的知识点也非常多，UITableViewCell的复用，memory cache, disk cache, 多线程切换，甚至http协议本身都需要有一定的涉及。
```



#### 39、讲讲你用Instrument优化动画性能的经历吧



#### 40、loadView是干嘛用的？



#### 41、viewWillLayoutSubView

```
controller layout触发的时候，开发者有机会去重新layout自己的各个subview。说UI熟悉的一定要知道。
```



#### 42、GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？

```
两种queue，串行和并行。main queue是串行，global queue是并行。有些开发者为了在工作线程串行的处理任务会自己建立一个serial queue。背后是苹果维护的线程池，各种queue要用线程都是这个池子里取的。GCD大家都用过，但很多关键的概念不少人都理解的模凌两可。串行，并行，同步，异步是GCD的核心概念。
```



#### 43、用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？

```
没用过sqlite是说不过去的。用过CoreData的肯定有很多血泪史要说。多谢线程模型你肯定做过比较选择。死锁是啥肯定也是要知道的，没遇到过至少能举个简单的例子来说明。单个线程可以死锁（main thread里dispatch_sync到main queue），多个线程直接也可以死锁（A，B线程互相持有对方需要的资源且互相等待）。
```



#### 44、NSString如何计算字符的个数？

```

```



#### 45、PKI体系当中加密和签名有什么区别？



#### 46、如何自己高效实现NSUserDefault?



#### 47、数据库建表的时候索引有什么用？



#### 48、Full Text Search为什么快？



#### 49、iOS下如何实现指定线程数目的线程池？



#### 50、函数式编程当中的 first-class function是什么意思呢？



#### 51、如何使用runtime hook一个class的某个方法，又如何hook某个instance的方法？



#### 53、让你设计一种机制检测UIViewController的内存泄漏，你会怎么做？Instrument是如何检测内存泄漏的



#### 54、通过[UIImage imageNamed:]生成的对象什么时候被释放？



#### 55、applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。



#### 56、如何终止正在运行的工作线程？



#### 57、穷举iOS下所有的本地持久化方案。



#### 58、项目中网络层如何做安全处理

```
尽量使用https

不要传输明文密码

Post并不比Get安全

不要使用301跳转

http请求都带上MAC

http请求使用临时密钥

AES使用CBC模式

1、尽量使用https

https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。

2、不要传输明文密码

不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh

token去申请新的token。

3、Post并不比Get安全

事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。

4、不要使用301跳转

301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。

5、http请求都带上MAC

所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication

Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request

params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。

6、http请求使用临时密钥

高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES

key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES

key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。

7、AES使用CBC模式

不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。
```





#### 59、假如Controller太臃肿，如何优化？

```
1.将网络请求抽象到单独的类中

方便在基类中处理公共逻辑；

方便在基类中处理缓存逻辑，以及其它一些公共逻辑；

方便做对象的持久化。

2.将界面的封装抽象到专门的类中

构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。

3.构造 ViewModel

借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。

4.专门构造存储类

专门来处理本地数据的存取。

5.整合常量

```





#### 3.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？

```
可能造成tableView卡顿的原因有：

1.最常用的就是cell的重用， 注册重用标识符

如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell

如果有很多数据的时候，就会堆积很多cell。

如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell

2.避免cell的重新布局

cell的布局填充等操作 比较耗时，一般创建时就布局好

如可以将cell单独放到一个自定义类，初始化时就布局好

3.提前计算并缓存cell的属性及内容

当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度

而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell

4.减少cell中控件的数量

尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，

不适用的可以先隐藏

5.不要使用ClearColor，无背景色，透明度也不要设置为0

渲染耗时比较长

6.使用局部更新

如果只是更新某组的话，使用reloadSection进行局部更

7.加载网络数据，下载图片，使用异步加载，并缓存

8.少使用addView 给cell动态添加view

9.按需加载cell，cell滚动很快时，只加载范围内的cell

10.不要实现无用的代理方法，tableView只遵守两个协议

11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可

12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。

13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；

14.使用正确的数据结构来存储数据。

```



#### 60、M、V、C相互通讯规则你知道的有哪些？

```
MVC 是一种设计思想，一种框架模式，是一种把应用中所有类组织起来的策略，它把你的程序分为三块，分别是：

M（Model）：实际上考虑的是“什么”问题，你的程序本质上是什么，独立于 UI 工作。是程序中用于处理应用程序逻辑的部分，通常负责存取数据。

C（Controller）：控制你 Model 如何呈现在屏幕上，当它需要数据的时候就告诉 Model，你帮我获取某某数据；当它需要 UI 展示和更新的时候就告诉 View，你帮我生成一个 UI 显示某某数据，是 Model 和 View 沟通的桥梁。

V（View）：Controller 的手下，是 Controller 要使用的类，用于构建视图，通常是根据 Model 来创建视图的。

要了解 MVC 如何工作，首先需要了解这三个模块间如何通信。

MVC通信规则

http://cc.cocimg.com/api/uploads//20171127/1511752329535960.jpg

Controller to Model

可以直接单向通信。Controller 需要将 Model 呈现给用户，因此需要知道模型的一切，还需要有同 Model 完全通信的能力，并且能任意使用 Model 的公共 API。

Controller to View

可以直接单向通信。Controller 通过 View 来布局用户界面。

Model to View

永远不要直接通信。Model 是独立于 UI 的，并不需要和 View 直接通信，View 通过 Controller 获取 Model 数据

View to Controller

View 不能对 Controller 知道的太多，因此要通过间接的方式通信。

Target

action。首先 Controller 会给自己留一个 target，再把配套的 action 交给 View 作为联系方式。那么 View

接收到某些变化时，View 就会发送 action 给 target 从而达到通知的目的。这里 View 只需要发送

action，并不需要知道 Controller 如何去执行方法。

代理。有时候 View 没有足够的逻辑去判断用户操作是否符合规范，他会把判断这些问题的权力委托给其他对象，他只需获得答案就行了，并不会管是谁给的答案。

DataSoure。View 没有拥有他们所显示数据的权力，View 只能向 Controller 请求数据进行显示，Controller 则获取 Model 的数据整理排版后提供给 View。

Model 访问 Controller

同样的 Model 是独立于 UI 存在的，因此无法直接与 Controller 通信，但是当 Model 本身信息发生了改变的时候，会通过下面的方式进行间接通信。

Notification & KVO一种类似电台的方法，Model 信息改变时会广播消息给感兴趣的人 ，只要 Controller 接收到了这个广播的时候就会主动联系 Model，获取新的数据并提供给 View。

从上面的简单介绍中我们来简单概括一下 MVC 模式的优点。

1.低耦合性

2.有利于开发分工

3.有利于组件重用

4.可维护性
```





#### 61、NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?

```
1.不准

2.不准的原因如下：

1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。

2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。

当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。

PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。

方法一：

1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。

self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];

[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];

2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；

- (void)timerMethod2 {
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
[thread start];
}
- (void)newThread
{
@autoreleasepool
{
[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] run];
}
}
总结：

一开始的时候系统就为我们将主线程的main runloop隐式的启动了。

在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop

方法二：

使用示例

使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。

关于数据结构mach_timebase_info的定义如下：

struct mach_timebase_info {uint32_t numer;uint32_t denom;};
#include
#include
static const uint64_t NANOS_PER_USEC = 1000ULL;
static const uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;
static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;
static mach_timebase_info_data_t timebase_info;
static uint64_t nanos_to_abs(uint64_t nanos) {
return nanos * timebase_info.denom / timebase_info.numer;
}
void example_mach_wait_until(int seconds)
{
mach_timebase_info(&timebase_info);
uint64_t time_to_wait = nanos_to_abs(seconds * NANOS_PER_SEC);
uint64_t now = mach_absolute_time();
mach_wait_until(now + time_to_wait);
}
方法三：直接使用GCD替代！
```



####  你知道哪些设计模式，并简要叙述？

```
1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。
2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。
3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。
4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。
5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。
6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。
```



####import跟 #include 有什么区别，@class呢，#import<> 跟 #import””有什么区别？

```
1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。
2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3). #import<>用来包含系统的头文件，#import””用来包含用户头文件。
```



#### tableView的重用机制能简单说一下么？



#### 写一个线程安全的单例模式 - 保证线程安全的方式（加锁和GCD栅栏，队列组相关知识）



#### 在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？

```
答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。
```



#### 自定义库要注意些什么



```
抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一
个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个
解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给是
哦难过者，如解压完成、解压出错等。在框架内部去构建对象的关系，
通过抽象让其更为健壮、便于更改。其次是API的说明文档。

```

#### 对于Objective-C，你认为它最大的优点和最大的不足是什么

```
最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲
 突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的
命名冲突，可以使用link命令及flag解决冲突。
```



你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和G.C.D的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。

```
使用NSOperationQueue用来管理子类化的NSOperation对象，控制
其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别
是 NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中
使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中
使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，
是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接
口简单，建议在复杂项目中使用。
项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线
程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议
在简单项目中使用。

```



#### 程序内存分区

```
程序内存分区
以下是比较常用的五分区方式，当然也不排除网上有其他的分区方式。

栈
栈的大小在编译时就已经确定了，一般是2M；栈是一块从高到低地址的连续区域，存放临时变量和执行函数时的内存等。栈内存分配分为动态和静态，静态如自动变量（局部变量）等，动态如alloc等。

堆
堆是从低到高地址的不连续区域，类似链表；用来存放malloc或new申请的内存。

全局/静态
存放静态/全局变量；全局区细分为未初始化/初始化区。

常量
存放常量；程序中使用的常量会到常量区获取。
可以看看这个例子来理解一下。

...int a;//a在全局未初始化区int a = 10;//a在全局初始化区 10在常量区static int a = 10;//a在静态区 10在常量区//程序入口int main(...) {   int a = 10;//a在栈区 10在常量区
   static int a = 10;//a在静态区 10在常量区
   char *a = (char *)malloc(10); //a在栈区 malloc后的内存在堆区
   ...
}
代码
存放二进制代码，运行程序就是执行代码，代码要执行就要加载进内存（RAM运行内存）。


```



### extern的作用

告诉编译器，这个全局变量在本文件找不到就去其他文件去找。如有必要需要使用#import "x.h"这样编译器才知道到哪里去找。使用extern前要保证对应变量被编译过。

```
//.hint age = 10;//error 不能.h此处声明全局非静态变量，.m中可以extern int age = 10;//error 和int age = 10;等价extern static int age = 10;//全局静态变量声明不和extern一起用@interface Class : NSObject...@end//.mextern static int age = 10;//全局静态变量声明不和extern一起用@implementation Class {   int age;//成员变量不能用作extern;}
- (void)test {    extern int age = 10;//error 因为这并不是全局变量
    static int age = 10;//error 因为这并不是全局变量
    extern int age;//error 因为这并不是全局变量}
...@end


```



#### const



#### static



http://www.cocoachina.com/ios/20161110/18035.html



#### 指针函数/函数指针/Block

###### 指针函数

C语言的概念；本质是函数，返回指针。

```
char *fun() {    char *p = "";    return p;
}
```

###### 函数指针

C语言的概念；本质是指针，指向函数。

```
int fun(int a,int b) {    return a + b;
}int (*func)(int,int);
func = fun;
func(1,2);//3
```

###### Block

OC语言的概念；表示一个代码块，OC中视为对象；挺像C函数指针的。

```
//typedeftypedef int (^SumBlock)(int a,int b);
SumBlock sumBlock = ^(int a,int b) {    return a + b;
};
sumBlock(1,2);//3//普通
 int (^sumBlock)(int a,int b) = ^(int a,int b) {    return a + b;
};
sumBlock(1,2);//3
```



#### 信号量：dispatch_semaphore。



#### iOS类和结构体有什么区别

区别还是有很多的，答到核心的就可以了。
1：类指针赋值时只是复制了地址，结构体是复制内容；
2：类不能有同名同参数个数的方法，结构体可以；
3：结构体方法实现编译时就确定了，类方法实现可动态改变；
4：内存分配不一样，结构体在栈，类在堆；
5：结构体可以多重继承，类只能单继承。





#### 线程安全方法

线程安全：多线程环境下保证数据的完整性。

###### 队列

把操作放入队列线性执行，可用GCD和NSOperationQueue。

###### 锁/信号量

用锁/信号量形成操作互斥。

###### 让操作原子化

让操作原子执行，系统提供了一些原子执行的方法。

###### 了解更多

[iOS-线程安全](https://juejin.im/entry/59cbbd1f6fb9a00a664a468f)



#### NSOperationQueue和GCD区别联系

###### 区别

NSOperationQueue没有串行/并发队列，但可以设置最大并发数；
NSOperationQueue支持方法和block，GCD只支持block；
NSOperationQueue可以暂停/取消操作；
NSOperationQueue支持更多的功能，比如KVO和自定义操作；
NSOperationQueue可以设置操作的优先级，GCD只能设置队列的优先级。

###### 联系

提供的功能是相似的；
NSOperationQueue是GCD的封装。





#### 11.对程序性能的优化你有什么建议?

> 1.使用复用机制
> 2.尽可能设置 View 为不透明
> 3.避免臃肿的 XIB 文件
> 4.不要阻塞主线程
> 5.图片尺寸匹配 UIImageView
> 6.选择合适的容器
> 7.启用 GZIP 数据压缩
> 8.View 的复用和懒加载机制
> 9、缓存
> 服务器的响应信息（response）。
> 图片。
> 计算值。比如：UITableView 的 row heights。
> 10.关于图形绘制
> 11.处理 Memory Warnings
> 在 AppDelegate 中实现 - [AppDelegate applicationDidReceiveMemoryWarning:] 代理方法。
> 在 UIViewController 中重载 didReceiveMemoryWarning 方法。
> 监听 UIApplicationDidReceiveMemoryWarningNotification 通知。
> 12.复用高开销的对象
> 13.减少离屏渲染(设置圆角和阴影的时候可以选用绘制的方法)
> 14.优化 UITableView
> 通过正确的设置 reuseIdentifier 来重用 Cell。
> 尽量减少不必要的透明 View。
> 尽量避免渐变效果、图片拉伸和离屏渲染。
> 当不同的行的高度不一样时，尽量缓存它们的高度值。
> 如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且缓存服务器的 response。
> 使用 shadowPath 来设置阴影效果。
> 尽量减少 subview 的数量，对于 subview 较多并且样式多变的 Cell，可以考虑用异步绘制或重写 drawRect。
> 尽量优化 - [UITableView tableView:cellForRowAtIndexPath:] 方法中的处理逻辑，如果确实要做一些处理，可以考虑做一次，缓存结果。
> 选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的。
> 对于 rowHeight、sectionFooterHeight、sectionHeaderHeight 尽量使用常量。
> 15.选择合适的数据存储方式
> 在 iOS 中可以用来进行数据持有化的方案包括：
> NSUserDefaults。只适合用来存小数据。
> XML、JSON、Plist 等文件。JSON 和 XML 文件的差异在「选择正确的数据格式」已经说过了。
> 使用 NSCoding 来存档。NSCoding 同样是对文件进行读写，所以它也会面临必须加载整个文件才能继续的问题。
> 使用 SQLite 数据库。可以配合 FMDB 使用。数据的相对文件来说还是好处很多的，比如可以按需取数据、不用暴力查找等等。
> 使用 CoreData。也是数据库技术，跟 SQLite 的性能差异比较小。但是 CoreData 是一个对象图谱模型，显得更面向对象；SQLite 就是常规的 DBMS。
> 16.减少应用启动时间
> 快速启动应用对于用户来说可以留下很好的印象。尤其是第一次使用时。
> 保证应用快速启动的指导原则：
> 尽量将启动过程中的处理分拆成各个异步处理流，比如：网络请求、数据库访问、数据解析等等。
> 避免臃肿的 XIB 文件，因为它们会在你的主线程中进行加载。重申：Storyboard 没这个问题，放心使用。
> 注意：在测试程序启动性能的时候，最好用与 Xcode 断开连接的设备进行测试。因为 watchdog 在使用 Xcode 进行调试的时候是不会启动的。
> 17.使用 Autorelease Pool （内存释放池）
> 18.imageNamed 和 imageWithContentsOfFile





#### NSURLConnection 和NSURLSession 的区别是 么? NSURLProtocol是做什么的?

> 1.下载
> NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。
> 而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码
> 2.请求方法的控制
> NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。
> NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。
> 使用NSURLSession进行断点下载更加便捷.
> NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进



#### 如果项目开始容错处理没做？如何防止拦截潜在的崩溃？

```
例：

1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。

2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。

3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。

总结：

1、不要过分相信服务器返回的数据会永远的正确。

2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。

```





#### 容错处理你们一般是注意哪些？

```
在团队协作开发当中，由于每个团队成员的水平不一，很难控制代码的质量，保证代码的健壮性，经常会发生由于后台返回异常数据造成app崩溃闪退的情况，为了避免这样的情况项目中做一些容错处理，显得格外重要，极大程度上降低了因为数据容错不到位产生崩溃闪退的概率。

例如：

1.字典

2.数组；

3.野指针；

4.NSNull

等~

```



#### 2.内存泄漏可能会出现的几种原因，聊聊你的看法？

```
第一种可能：第三方框架不当使用；

第二种可能：block循环引用；

第三种可能：delegate循环引用；

第四种可能：NSTimer循环引用

第五种可能：非OC对象内存处理

第六种可能：地图类处理

第七种可能：大次数循环内存暴涨



追问一：非OC对象如何处理？

非OC对象，其需要手动执行释放操作例：CGImageRelease(ref)，否则会造成大量的内存泄漏导致程序崩溃。

其他的对于CoreFoundation框架下的某些对象或变量需要手动释放、C语言代码中的malloc等需要对应free。

```



#### 常用锁有以下几种：

```


1.@synchronized 关键字加锁

\2. NSLock 对象锁

\3. NSCondition

\4. NSConditionLock 条件锁

\5. NSRecursiveLock 递归锁

\6. pthread_mutex 互斥锁（C语言）

\7. dispatch_semaphore 信号量实现加锁（GCD）

\8. OSSpinLock

9.pthread_rwlock

10.POSIX Conditions

11.os_unfair_lock

追问一：自旋和互斥对比？

自旋锁和互斥锁

相同点：都能保证同一时间只有一个线程访问共享资源。都能保证线程安全。

不同点：

互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。

自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。

自旋锁的效率高于互斥锁。

使用自旋锁时要注意：

由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪费CPU时间。

持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能导致整个系统挂起。

使用任何锁都需要消耗系统资源（内存资源和CPU时间），这种资源消耗可以分为两类：

1.建立锁所需要的资源

2.当线程被阻塞时所需要的资源

追问二：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！

cpp实现：



两种锁的加锁原理：

互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。

自旋锁：线程一直是running(加锁——>解锁)，死循环检测锁的标志位，机制不复杂。



```







#### 优化你是从哪几方面着手

```
一、首页启动速度

启动过程中做的事情越少越好（尽可能将多个接口合并）

不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）

在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）

尽量减小包的大小

优化方法：

量化启动时间

启动速度模块化

辅助工具（友盟，听云，Flurry）

二、页面浏览速度

json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）

数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）

数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）

内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）

延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）

算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）

三、操作流畅度优化：

Tableview 优化（tableview cell的加载优化）

ViewController加载优化（不同view之间的跳转，可以提前准备好数据）

四、数据库的优化：

数据库设计上面的重构

查询语句的优化

分库分表（数据太多的时候，可以分不同的表或者库）

五、服务器端和客户端的交互优化：

客户端尽量减少请求

服务端尽量做多的逻辑处理

服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）

通信协议的优化。（减少报文的大小）

电量使用优化（尽量不要使用后台运行）

```









#### 怎么防止别人动态在你程序生成代码？怎么防止反编译？

```
（这题是听错了面试官的意思）

面试官意思是怎么防止别人反编译你的app？

1.本地数据加密

iOS应用防反编译加密技术之一：对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息

2.URL编码加密

iOS应用防反编译加密技术之二：对程序中出现的URL进行编码加密，防止URL被静态分析

3.网络传输数据加密

iOS应用防反编译加密技术之三：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据

4.方法体，方法名高级混淆

iOS应用防反编译加密技术之四：对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码

5.程序结构混排加密

iOS应用防反编译加密技术之五：对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低

```





#### GCD执行原理？

```

```



GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用胡话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？）

而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。

• 如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。

•

如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。

•

这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5~8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3~5条最为合理。

通过案例明白GCD的执行原理

案例一：

![img](http://upload-images.jianshu.io/upload_images/1829339-a469ae8280a8d244?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

**分析：**

首先执行任务1，这是肯定没问题的，只是接下来，程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后执行任务3。但这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务。那么，现在任务2就会被加到最后，任务3排在了任务2前面，问题来了：

任务3要等任务2执行完才能执行，任务2又排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等待的局面。【既然这样，那干脆就卡在这里吧】这就是死锁。

![img](http://upload-images.jianshu.io/upload_images/1829339-e18da8433f72dee3?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

案例二：

![img](http://upload-images.jianshu.io/upload_images/1829339-e983c3d83b5527ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

**分析：**

首先执行任务1，接下来会遇到一个同步线程，程序会进入等待。等待任务2执行完成以后，才能继续执行任务3。从dispatch_get_global_queue可以看出，任务2被加入到了全局的并行队列中，当并行队列执行完任务2以后，返回到主队列，继续执行任务3。

![img](http://upload-images.jianshu.io/upload_images/1829339-6abd1b12cf63dece?imageMogr2/auto-orient/strip%7CimageView2/2/w/528)

案例三：

![img](http://upload-images.jianshu.io/upload_images/1829339-99917457dbcbfb7e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

案例四：

![img](http://upload-images.jianshu.io/upload_images/1829339-cd97e461b7060eba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

分析：

首先，将【任务1、异步线程、任务5】加入Main

Queue中，异步线程中的任务是：【任务2、同步线程、任务4】。所以，先执行任务1，然后将异步线程中的任务加入到Global

Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。然后再看异步线程中的任务执行顺序。任务2执行完以后，遇到同步线程。将同步线程中的任务加入到Main

Queue中，这时加入的任务3在任务5的后面。当任务3执行完以后，没有了阻塞，程序继续执行任务4。

![img](http://upload-images.jianshu.io/upload_images/1829339-c806de24ecd0a4b3?imageMogr2/auto-orient/strip%7CimageView2/2/w/676)

案例五：

![img](http://upload-images.jianshu.io/upload_images/1829339-2c0e1a968c5b3911?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

分析：

和上面几个案例的分析类似，先来看看都有哪些任务加入了Main Queue：

【异步线程、任务4、死循环、任务5】。

在加入到Global Queue异步线程中的任务有：

【任务1、同步线程、任务3】。第一个就是异步线程，任务4不用等待，

所以结果任务1和任务4顺序不一定。任务4完成后，程序进入死循环，

Main Queue阻塞。但是加入到Global Queue的异步线程不受影响，

继续执行任务1后面的同步线程。同步线程中，将任务2加入到了主线程，

并且，任务3等待任务2完成以后才能执行。这时的主线程，已经被死循环阻塞了。

所以任务2无法执行，当然任务3也无法执行，在死循环后的任务5也不会执行。

![img](http://upload-images.jianshu.io/upload_images/1829339-a6d19be63551df66?imageMogr2/auto-orient/strip%7CimageView2/2/w/861)







#### 你理解的多线程？

```
1.可能会追问，每种多线程基于什么语言？

2.生命周期是如何管理？

3.你更倾向于哪种？追问至现在常用的两种你的看法是？

第一种：pthread

.特点：

1）一套通用的多线程API

2）适用于Unix\Linux\Windows等系统

3）跨平台\可移植

4）使用难度大

b.使用语言：c语言

c.使用频率：几乎不用

d.线程生命周期：由程序员进行管理

第二种：NSThread

a.特点：

1）使用更加面向对象

2）简单易用，可直接操作线程对象

b.使用语言：OC语言

c.使用频率：偶尔使用

d.线程生命周期：由程序员进行管理

第三种：GCD

a.特点：

1）旨在替代NSThread等线程技术

2）充分利用设备的多核（自动）

b.使用语言：C语言

c.使用频率：经常使用

d.线程生命周期：自动管理

第四种：NSOperation

a.特点：

1）基于GCD（底层是GCD）

2）比GCD多了一些更简单实用的功能

3）使用更加面向对象

b.使用语言：OC语言

c.使用频率：经常使用

d.线程生命周期：自动管理

多线程的原理

同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）

多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）

如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象

思考：如果线程非常非常多，会发生什么情况？

CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源

每条线程被调度执行的频次会降低（线程的执行效率降低）

多线程的优点

能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）

多线程的缺点

开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享

你更倾向于哪一种？

倾向于GCD：

GCD

技术是一个轻量的，底层实现隐藏的神奇技术，我们能够通过GCD和block轻松实现多线程编程，有时候，GCD相比其他系统提供的多线程方法更加有效，当然，有时候GCD不是最佳选择，另一个多线程编程的技术

NSOprationQueue 让我们能够将后台线程以队列方式依序执行，并提供更多操作的入口，这和 GCD 的实现有些类似。

这种类似不是一个巧合，在早期，MacOX

与 iOS 的程序都普遍采用Operation

Queue来进行编写后台线程代码，而之后出现的GCD技术大体是依照前者的原则来实现的，而随着GCD的普及，在iOS 4 与 MacOS X

10.6以后，Operation Queue的底层实现都是用GCD来实现的。

那这两者直接有什么区别呢？

1.    GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；

2.    在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；

3.    NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；

4.    我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务；

5.    在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；

6.    我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。

总的来说，Operation

queue

提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation

queue 为我们提供能更多的选择。

倾向于：NSOperation

NSOperation相对于GCD：

1，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。

2，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。

3，NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）

4，GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。

使用NSOperation的情况：各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。

使用GCD的情况：一般的需求很简单的多线程操作，用GCD都可以了，简单高效。

从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。

当需求简单，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。



```







#### SD原理以及最大支持多少个下载数？



#### runtime动态创建一个类，需要注意什么？







#### 还有一个很长字符串，你用什么算法搜索到abc的位置？



#### https和ssl在握手方向有什么区别？



#### 代码文件编译生成过程，编译和链接有什么区别，链接做了什么事情



#### 用C语言实现一个通知流程，说思路即可！



#### A B 线程执行到一半去执行C线程，用OC和C各自怎么实现！



#### 快排的原理



#### C语言中strlen和sizeof的区别



#### 推送的原理



#### 一个页面可以由几个控制器共同管理吗



#### 项目上线或者版本迭代，有过被拒吗？是什么原因？怎么解决？



#### 转场动画相关操作



#### tableViewCell的自适应如何实现，如何保证性能







#### cocoaPods的实现思路，为什么没有使用cocoaPods管理自己的SDK



#### 请说明并比较以下关键词：atomatic, nonatomic

atomic修饰的对象会保证setter和getter的完整性，任何线程对其访问都可以得到一个完整的初始化后的对象。因为要保证操作完成，所以速度慢。它比nonatomic安全，但也并不是绝对的线程安全，例如多个线程同时调用set和get就会导致获得的对象值不一样。绝对的线程安全就要用关键词synchronized。
nonatomic修饰的对象不保证setter和getter的完整性，所以多个线程对它进行访问，它可能会返回未初始化的对象。正因为如此，它比atomic快，但也是线程不安全的。





#### 你平时做过什么有技术难点的东西，然后怎么解决的





## Swift部分



#### 1.什么是函数式编程？



#### 2.什么是ABI？



#### 3.什么是MVC,请结合CocoaTouch说明？



#### 4.什么是MVVM，请设计View moled需要考虑哪些？



#### 5.swift相对于OC有哪些优点？



#### 6.什么是泛型,swift在哪些地方使用了泛型？



#### 7.defer、guard的作用？



#### 8.swift语法糖？！的本质（实现原理）



#### 9.举例swift中模式匹配的作用？



#### 10.swift中private与OC中block的区别？



#### 11.什么是capture list，举例说明用处？



#### 12.swift中private与fileprivate的区别？



#### 13.REST、HTTP、JSON是什么？



#### 14.delegate解决了什么问题，Notification与它有什么不同？



#### 16.LLVM与Clang的区别？



#### 17.Class、objc的区别是什么？



#### 18.class 和 struct 的区别



#### 19.不通过继承，代码复用（共享）的方式有哪些



#### 20.Set 独有的方法有哪些？



#### 21.实现一个 min 函数，返回两个元素较小的元素



#### 22.map、filter、reduce 的作用



#### 23.map 与 flatmap 的区别



#### 24.什么是 copy on write



#### 25.如何获取当前代码的函数名和行号



#### 26.如何声明一个只能被类 conform 的 protocol



#### 27.String 与 NSString 的关系与区别



#### 28.怎么获取一个 String 的长度



#### 29.如何截取 String 的某段字符串



#### 30.throws 和 rethrows 的用法与作用



#### 31.try？ 和 try！是什么意思



#### 32.associatedtype 的作用



#### 33.什么时候使用 final



#### 34.public 和 open 的区别



#### 35.声明一个只有一个参数没有返回值闭包的别名



#### 36.Self 的使用场景



#### 37.dynamic 的作用



#### 38.什么时候使用 @objc



#### 39.Optional（可选型） 是用什么实现的



#### 40.如何自定义下标获取



#### 41.?? 的作用



#### 42.lazy 的作用



#### 43.一个类型表示选项，可以同时表示有几个选项选中（类似 UIViewAnimationOptions ），用什么类型表示



44.inout 的作用

45.Error 如果要兼容 NSError 需要做什么操作

46.下面的代码都用了哪些语法糖

```
[1, 2, 3].map{ $0 * 2 }

```

47.什么是高阶函数



48.下面的代码会不会崩溃，说出原因

```
var mutableArray = [1,2,3]
for _ in mutableArray {
    mutableArray.removeLast()
}

```

49.给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明

50.定义静态方法时关键字 static 和 class 有什么区别‘



# 高级

1.一个 Sequence 的索引是不是一定从 0 开始？

2.数组都实现了哪些协议

3.如何自定义模式匹配

4.autoclosure 的作用

5.编译选项 whole module optmization 优化了什么

6.下面代码中 mutating 的作用是什么

```
struct Person {

    var name: String {
        mutating get {
            return store
        }
    }
}

```

7.如何让自定义对象支持字面量初始化

8.dynamic framework 和 static framework 的区别是什么



9.为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃。

10.一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。



# 道长的 Swift 面试题

https://www.jianshu.com/p/07c9c6464f83

https://www.jianshu.com/p/7c7f4b4e4efe

https://www.jianshu.com/p/55210e9b8c8b









http://www.cocoachina.com/ios/20180305/22453.html