## iOS部分

1.你常用的设计模式，讲一讲具体使用细节



2.在开发过程中遇到的困难、问题



3.iOS持有一个对象的原理

retainCount



4.画UML



5.产生循环引用的场景



6.



1.dSYM你是如何分析的？

```
dsym分析根据，分析 log、dsym、app


```







2.多线程有哪几种？你更倾向于哪一种？

```
NSOperation、NSThread、 GCD

倾向于gcd
```





3.单例弊端？

```

```





4.如何把异步线程转换成同步任务进行单元测试？http://blog.csdn.net/u010742414/article/details/78260938

5.介绍下App启动的完成过程？

6.比如App启动过慢，你可能想到的因素有哪些？

7.0x8badf00d表示是什么？

http://www.cnblogs.com/smileEvday/p/Crash1.html

程序启动或者恢复时间过长被watch dog终止 无响应崩溃 don‘t block main thread  否在主线程请求了网络，或者其他耗时的事情卡住了正常初始化流程。

通常系统允许一个App从启动到可以相应用户事件的时间最多为5S，如果超过了5S，App就会被系统终止掉。在Launch，resume，suspend，quit时都会有相应的时间要求。在Highlight Thread里面我们可以看到被终止时调用到的位置，xxxAppDelegate加上行号。 

PS. 在连接Xcode调试时为了便于调试，系统会暂时禁用掉Watchdog，所以此类问题的发现需要使用正常的启动模式。



8.怎么防止反编译？

9.说说你遇到到的技术难点？

10.说说你了解的第三方原理或底层知识？

3面

1.介绍下内存的几大区域？

### 栈区,堆区,静态区(全局变量区),常量区,代码区

1 栈 －－有编译器自动分配释放

 2. 堆 －－ 一般由程序员分配释放，若程序员不释放，程序结束时    可能由OS回收 

 3. 全局区（静态区） －－ 全局变量和静态变量的存储是放在一块 的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。 
 4. 另外还有一个专门放常量的地方。程序结束释放。



2.你是如何组件化解耦的？

route url注册 协议跳转

- 对每个模块间相互调用解耦
- 统一wap与本地调用

蘑菇街App组件化之路

http://limboy.me/tech/2016/03/10/mgj-components.html





3.runtime如何通过selector找到对应的IMP地址

http://blog.csdn.net/dp948080952/article/details/52437451



4.runloop内部实现逻辑？

5.你理解的多线程？

6.GCD执行原理？

7.怎么防止别人动态在你程序生成代码

8.YYAsyncLayer如何异步绘制？

9.优化你是从哪几方面着手？





招聘一个靠谱ios

http://www.cocoachina.com/ios/20150803/12872.html

http://www.cocoachina.com/ios/20150825/13195.html

http://www.cocoachina.com/ios/20171127/21331.html

http://www.jianshu.com/p/dd17bdcff9f7







## ios基础

OC语言特点

```
实例变量
@interface MyViewController :UIViewController
{
    UIButton *myButton;
}

属性
@property (nonatomic, retain) UIButton *myButton;

苹果将默认编译器从GCC转换为LLVM(low level virtual machine)，从此不再需要为属性声明实例变量了，
声明属性会自动生成一个以下划线开头的实例变量。

不想用带下划线的实例变量 
可以在实现中添加 @synthesize myButton = xxx；来改


成员变量，实例变量本质上就是成员变量，实例变量+基本数据类型变量=成员变量

成员变量是定义在｛｝号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量。而属性变量是用于与其他对象交互的变量。

属性的其他：

在@property（描述1 , 描述2 , 描述3）(class *) varName 里面，有3个描述词需要填写（也可以不填写取默认值）
1. nonatomic<-->atomic
2. readwrite<-->readonly
3. retain/copy/assign

retain：他指的是将某个内存区域的指针赋值给变量，同时把该内存区域的引用计数器加1.每执行一次，该内存区域的引用计数器就要加1，当该区域的引用计数器变为0的时候内存区域被释放！
 
copy：它指的是将目标内存区域的值复制一份，然后开辟新的内存区域（新的指针）粘贴这个值。同时变量被赋值为新内存区域的指针！
 
assign：它指的是，仅只把目标内存区域的指针赋值给变量，该内存区域的引用计数器不发生变化！
```



1、扩充C的面向对象编程语言

2、动态语言

```
1、动态类型 id

2、动态绑定 消息发送机制，编译时并未绑定、知道运行时消息发送时才进行绑定

3、动态加载 运行时动态添加代码、动态加载资源
```

3、类别的特点、类别与扩展和匿名类别的区别

```
category 类别

@interface UIView (category)
@property NSString *demo;
@end

@implementation UIView (category)
@end

匿名类别，在.m文件里面我们常用的匿名类别，这里是可以添加实例变量的

@interface UIView() {
    NSString *str;
}

类别中可以添加属性，但是不能添加实例变量，类别中的属性不会自动生成实例变量 @synthesize也不允许在category中使用。相当于提供了一套getter、setter方法。

注意一点，匿名类别(匿名扩展)是可以添加实例变量的，非匿名类别是不能添加实例变量的，只能添加方法，或者属性（其实也是方法）。

extension 扩展

oc的扩展较为简单，就是匿名类别，且扩展中的修改都是私有的
在扩展里面 我们可以更改属性的内部权限，比如对外只读可以修改为内部可读可写
```

4、self和super的区别

```
self 是类的隐藏参数，指向的是当前对象，而super并不是指向当前对象父类的指针，其实super是一个编译器标识符，在运行时与self相同指向同一个消息接受对象。只是self会优先在当前对象类的methodList中查找，而super优先在父类中查找。
```

5、定义一个对象，它的内存大小是多少

class_getInstanceSize(obj);  8个字节

6、ios能不能动态给对象添加属性

```
https://blog.csdn.net/shengyumojian/article/details/44919695
```

7、atomic和nonatomic的区别？

```
atomic：默认是有该属性的，这个属性是为了保证程序在多线程情况下，编译器会自动生成一些互斥加锁代码，避免该变量的读写不同步问题。
nonatomic：如果该对象无需考虑多线程的情况，请加入这个属性，这样会让编译器少生成一些互斥加锁代码，可以提高效率。

atomic的意思就是setter/getter这个函数，是一个原语操作，只对这两个方法处理
```



8、如何保证线程的安全

```
1、@synchronized

@synchronized(obj)指令使用obj为该锁的唯一标示，只有当标示相同时才满足互斥，使用的有优点是不需要手动去创建锁对象，缺点是会自动添加隐式的异常处理，当异常抛出时自动的释放互斥锁。

2、dispatch_semphore

3、NSLock



使用信号量保证线程的安全


```

9、一下代码输出什么

```
dispatch_async(main_thread) {
      dispatch_sync (main_thread) {
          print("123")
      }
     print("456")
}

dispatch_async(main_thread) {
      dispatch_sync (global_thread) {
          print("123")
      }
     print("456")
}

什么都没有输出，死锁错误
```





## 基础部分



1、线程与进程的区别

进程是程序执行的实例，是资源分配的最小单位

线程是进程中的一个实例，是运行最小单位



2、打开一个url发生了是么

跟据域名查找ip 涉及到DNS解析

根据ip访问服务器、涉及到握手、涉及到连接建立，通信请求



3、http的请求方式

GET  POST  HEAD  OPTIONS  PUT  DELETE  TRACE  CONNECT



4、http工作过程，http是超文本传输协议，一种通信协议

http是应用层协议，由请求和响应构成，标准的客户端服务器模型，是一个无状态的协议（对事务处理没有记忆能力）

Internet中的TCP / IP协议传输，http协议就是TCP / IP模型中应用层的协议，http承载于TCP协议之上，如果承载于TLS或者SSL协议之上，就成了https

http端口号默认 80是 https端口号默认 443



工作流程：

1、访问超链接，http开始工作

2、建立连接后 客户端发送一个请求给服务器，请求格式为 ：统一资源标识符（URL）、协议版本号、MIME信息 包括请求修饰符、客户端信息和其他内容

3、服务器接受请求后，给予响应信息，格式为一个状态行，包括信息的协议版本号。一个成功或者错误的代码，MIME信息包括服务器信息、实体信息、其他内容

4、客户端接受响应信息后展示，然后断开连接



5、二叉树

