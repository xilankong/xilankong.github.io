---
layout: post
category: 学习之路
title : "iOS面试题"
---

> 如果你不知道你接下来需要补充学习哪一部分知识，做点面试题吧。



## 基础部分



#### 1、线程和进程有什么区别

```
进程是一个程序执行的实例，是资源分配的最小单位

线程是进程中的一个实例，是操作系统可以识别的最小执行和调度单位
```



#### 2、说一下线程之间的通信

```
例如在多线程并发条件下，为了让线程之间可以更方便的共同完成一个任务，需要一些协调通信，采取的通信方式就是 等待、唤起。

也就是  wait()  和 notify()、 notifyAll()
```



#### 5、hash算法

```
MD5 常用的文件完整性校验算法，加密算法
SHA-1

通过计算文件hash值
```



#### 6、当用一个不存在的key来查找两个不同长度的字典，那么哪个效率会高？

```
表面上看可能是一样快，因为字典底层都用了哈希表，查找的时间复杂度为 O(1)，（最差的时候是O(n)）都是一样的，但是可能会由于两个哈希表的负载因子不同，倒是查找的时间也是不同的。
```



#### 7、什么是指针常量和常量指针

```
指针常量是 常量，指针修饰它，这个常量的值是一个指针 int a； int *const b = &a;

常量指针本质是指针，常量修饰它  const int *p; 
```



#### 8、不借用第三个变量，如何交换两个变量的值？

```
算术运算

int a,b;
a=10;b=12;
a=b-a; //a=2;b=12
b=b-a; //a=2;b=10
a=b+a; //a=10;b=10

位运算 异或

int a=10,b=12; //a=1010^b=1100;
a=a^b; //a=0110^b=1100;
b=a^b; //a=0110^b=1010;
a=a^b; //a=1100=12;b=1010;


栈实现

int exchange(int x,int y) 
{ 
stack S; 
push(S,x); 
push(S,y); 
x=pop(S); 
y=pop(S); 
}
```



#### 9、用递归算法求1到n的和

```
func add(n: Int) -> Int {
    var sum = 0
    if n > 0 {
        sum = n + add(n: n - 1)
    } else {
        sum = 0
    }
    return sum
}
```



#### 10、http 的 POST 和 GET 啥区别？

```

最直观的区别就是GET是获取数据、POST是提交数据

GET请求的数据会附在URL之后

POST把提交的数据则放置在是HTTP包的包体中

GET请求URL受浏览器影响 所以有长度限制

POST没有

POST的数据传输不是直接拼接URL 所以相对安全一些

```



#### 11、解释下tcp的慢启动特性

```
慢启动通过逐步增大拥塞窗口的值来控制网络拥塞。

通常在刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段的数值。而在每收到一个对新报文段的确认后，把拥塞窗口增加至多一个MSS数值。

也就是说，第一次时发送1个报文，在收到接收端确认之后，第二次时发送2个报文，同样都确认后，第三次时发送4个报文，2倍指数增长。

它的名字虽然叫慢启动，但实际上一点不慢，因为指数增长是很快的，所以它需要一个上限值，默认为64k。

慢启动的作用就是最大限度使用网络资源。
```



#### 12、如何用HTTP实现长连接？



#### 13、HTTP2.0针对同一个域名的多个请求，会建立多少个tcp连接？



#### 14、聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。



#### 15、通信底层原理（OSI七层模型）

```
OSI采用了分层的结构化技术，共分七层：
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
```



#### 16、介绍一下XMPP？

```
XMPP是一种以XML为基础的开放式实时通信协议。
简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。
```



17、ssl/tls证书作用



18、Socket连接和Http连接区别

```
Http是基于Tcp的，而Socket是一套编程接口让我们更方便的使用Tcp/Ip协议；Http是应用层协议，在Tcp/Udp上一层。
1：Http是基于"请求-响应"的，服务器不能主动向客户端推送数据，只能借助客户端请求到后向客户端推送数据，而Sokcet双方随时可以互发数据；
2：Http不是持久连接的，Socket用Tcp是持久连接；
3：Http基于Tcp，Socket可以基于Tcp/Udp；
4：Http连接是通过Socket实现的；
5：Http连接后发送的数据必须满足Http协议规定的格式：请求头、请求头和请求体，而Socket连接后发送的数据没有格式要求。
```





19、Tcp三次握手、四次挥手



#### 17、聊一聊二叉树搜索（Binary search tree）







## iOS部分



#### 1、block分几种？分别是怎么样产生的？block的实质是什么？

```
在内存角度来看，block分为 全局 、栈 和 堆 三种类型，

有强制转引用的block就属于堆内存block

只用到外部局部变量、成员属性变量、没有强指针引用的block属于栈block

只引用全局变量或静态变量的block，生命周期和程序生命周期一样的block就是全局block

block的实质是一个对象，一个结构体
```



#### 2、__block修饰的变量为什么能在block里面能改变其值？

```
__block修饰符标记后，block就会访问标记变量本身内存地址，而未标记对象则访问截获拷贝后的变量的内存地址
```



#### 3、block应该用copy关键字还是strong关键字？

```
block 使用 copy 是从 MRC 遗留下来的“传统”

在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区。

在 ARC 中写不写都行

对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
```



#### 4、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的

```
@property = ivar + getter + setter;

“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）

“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。
```



#### 5、用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？

```
用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。

//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。

这里还有一个引申问题：

NSMutableArray 如果用 copy修饰了会出现什么问题?

Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x600000a100c0'

由于使用的是copy属性，本身的可变属性默认有一个不可变的拷贝 NSArray ，所以我们用这个可变数组去添加元素的时候，找不到对应方法而发生crash。

```



#### 6、浅拷贝和深拷贝的区别？

```
浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。

只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制
```



#### 7、@synthesize 和 @dynamic 分别有什么作用？

```
@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。
如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;
// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)
1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。

```



#### 8、如何让自己的类用copy修饰符

```
若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：
    1. 需声明该类遵从 NSCopying 协议
    2. 实现 NSCopying 协议的方法。
        // 该协议只有一个方法: 
        - (id)copyWithZone:(NSZone *)zone;
        // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。

```



#### 9、ViewController生命周期

```
按照执行顺序排列：
1. initWithCoder：通过nib文件初始化时触发。
2. awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      
3. loadView：开始加载视图控制器自带的view。
4. viewDidLoad：视图控制器的view被加载完成。  
5. viewWillAppear：视图控制器的view将要显示在window上。
6. updateViewConstraints：视图控制器的view开始更新AutoLayout约束。
7. viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。
8. viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。
9. viewDidAppear：视图控制器的view已经展示到window上。 
10. viewWillDisappear：视图控制器的view将要从window上消失。
11. viewDidDisappear：视图控制器的view已经从window上消失。
```

#### 10、OC的反射机制

```
1). class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@"student"); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);
2). SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@"setName");  
        [stu performSelector:selector withObject:@"Mike"];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
```

#### 11、self 和 super

```
self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。
上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。

```



#### 12、id 和 NSObject＊的区别

```
id是一个 objc_object 结构体指针，定义是
typedef struct objc_object *id
id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。

NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。

不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。

```



#### 13、NSDictionary的实现原理是什么？

```
一：字典原理

NSDictionary（字典）是使用hash表来实现key和value之间的映射和存储的

方法：- (void)setObject:(id)anObject forKey:(id)aKey;

Objective-C中的字典NSDictionary底层其实是一个哈希表

二：哈希原理

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。

哈希概念:哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。

三：哈希存储过程

1.根据 key 计算出它的哈希值 h。

2.假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。

3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。

在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。

哈希表还有一个重要的属性: 负载因子(load factor)，它用来衡量哈希表的空/满程度，一定程度上也可以体现查询的效率，计算公式为:

负载因子 = 总键值对数 / 箱子个数

负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。

哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。

哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。

基于以上总结，细心的朋友可能会发现哈希表的两个问题:

1.如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。

2.如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。

```



#### 14、你们的App是如何处理本地数据安全的（比如用户名的密码）？

```
AES  DES
```



#### 15、遇到过BAD_ACCESS的错误吗？你是怎样调试的？

90%的错误来源在于对一个已经释放的对象进行release操作, 或者说对一个访问不到的地址进行访问，可能是由于些变量已经被回收了，亦可能是由于使用栈内存的基本类型的数据赋值给了id类型的变量。

例如：

```

id x_id = [self performSelector:@selector(returnInt)];
    
- (int)returnInt { return 5; }

上面通过id去接受int返回值，int是存放在栈里面的，堆内存地址如何找得到，自然就是 EXC_BAD_ACCESS。

```

**处理方法**

1、xcode可以用僵尸模式打印出对象 然后通过对象查找对应的代码位置

```
1、Edit Scheme - Diagnositics - Memory Management 勾选 Zombie Objects 和 Malloc Stack

2、会打印出 
cyuyan[7756:17601127] *** -[UIViewController respondsToSelector:]: message sent to deallocated instance 0x7fe71240d390

这句开启僵尸模式后打出来的输出，包含了我们需要的 进程pid、崩溃地址，终端通过下面命令查看堆栈日志来找到崩溃代码

3、查找日志
sudo malloc_history 7756 0x7fe71240d390
```



2、在 other c flags中加入-D FOR_DEBUG（记住请只在Debug Configuration下加入此标记）。这样当你程序崩溃时，Xcode的console上就会准确地记录了最后运行的object的方法。重写一个object的respondsToSelector方法，打印报错前的

```
#ifdef _FOR_DEBUG_  
-(BOOL) respondsToSelector:(SEL)aSelector {  
    printf("SELECTOR: %s\n", [NSStringFromSelector(aSelector) UTF8String]);  
    return [super respondsToSelector:aSelector];  
}  
#endif
```

3、通过instruments的Zombies



#### 16、如何设计一个通知中心



#### 17、如何去设计一个方案去应对后端频繁更改的字段接口？



#### 18、KVO、KVC的实现原理

**KVC实现**

键值编码

```
1.KVC是基于runtime机制实现的

2、可以访问私有成员变量、可以间接修改私有变量的值


[object setValue:@"134567" forKey:@"uid"];

就会被编译器处理成:
// 首先找到对应sel
SEL sel = sel_get_uid("setValue:forKey:");
// 根据object->isa找到sel对应的IMP实现指针
IMP method = objc_msg_lookup (object->isa,sel);
// 调用指针完成KVC赋值
method(object, sel, @"134567", @"uid");

KVC键值查找原理

setValue:forKey:搜索方式

1、首先搜索setKey:方法.(key指成员变量名, 首字母大写)
2、上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名.(NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)
3、如果没有找到成员变量, 调用setValue:forUnderfinedKey:

valueForKey:的搜索方式

1、首先按getKey, key, isKey的顺序查找getter方法, 找到直接调用. 如果是BOOL、int等内建值类型, 会做NSNumber的转换.
2、上面的getter没找到, 查找countOfKey, objectInKeyAtindex, KeyAtindexes格式的方法. 如果countOfKey和另外两个方法中的一个找到, 那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法.
3、还没找到, 查找countOfKey, enumeratorOfKey, memberOfKey格式的方法. 如果这三个方法都找到, 那么就返回一个可以响应NSSet所有方法的代理集合.
4、还是没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey, key, iskey的顺序搜索成员名.
5、再没找到, 调用valueForUndefinedKey.




当一个对象调用setValue方法时，方法内部会做以下操作：
1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。
2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。
3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。
4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。

```



**KVO实现**

键值观察、观察者模式的一种应用

```
基础

1.KVO是基于runtime机制实现的

2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制

3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person

4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法

5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。

深入

1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：?NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter?方法，setter?方法会负责在调用原?setter?方法之前和之后，通知所有观察对象属性值的更改情况。

2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；

3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。

4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）?因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。

5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath?的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath?的属性值已经变更；之后，?observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter?方法这种继承方式的注入是在运行时而不是编译时实现的。

```



#### 19、category为什么不能添加属性？

```
category 它是在运行期决议的，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。

extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。

但是category则完全不一样，它是在运行期决议的。 
就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的。

那为什么 使用Runtime技术中的关联对象可以为类别添加属性。

其原因是：关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。

如合清理关联对象？

runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。（详见Runtime的源码）
```



#### 20、说一下runloop和线程的关系

```
runloop与线程是一一对应的

runloop是来管理线程的

线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）
```

#### 21、说一下autoreleasePool的实现原理

```
在自动释放池被销毁或耗尽时，会向池中的所有对象发送release消息，释放所有autorelease对象。

ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool

AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage作为结点以双向链表的形式组合而成，会在一个Page空间占满时进行增加，objc_autoreleasePoolPop(哨兵对象)

主线程：

runloop默认开启，每一次运行循环开始，也就是每当事件被触发时都会创建自动释放池。运行循环结束前会释放自动释放池，还有池子满了也会销毁。

子线程：

runloop默认不开启，不会自动创建自动释放池，在需要使用自动释放池的时候，需要我们手动创建、添加自动释放池，此时如果所有的异步代码都写在自动释放池中，也可以理解为当子线程销毁的时候，自动释放池释放
```



#### 22、说一下简单工厂模式，工厂模式以及抽象工厂模式？

```

```



#### 23、如何设计一个网络请求库

```


```



#### 24、说一下多线程，你平常是怎么用的？



#### 25、说一下UITableViewCell的卡顿你是怎么优化的？



#### 26、看过哪些三方库？说一下实现原理以及好在哪里？



#### 27、说一下HTTP协议以及经常使用的code码的含义。

```

```





#### 28、什么是arc？（arc是为了解决什么问题诞生的？）

```
现在有不少程序员是直接从arc上手的，从没接触过mrc，对arc的理解仅仅停留在apple帮助管理内存的层面。这个问题真正想了解的是对内存管理的理解，retain release虽然不用写了，但arc下还是会有内存泄漏野指针crash的bug存在。如果能从retain count这种内存管理策略的角度去阐述arc诞生的意义就算答对了。如果还能扯下其他类型的策略，比如java里的mark and sweep，那就加分点赞。


```

29、请解释以下keywords的区别： assign vs weak, __block vs __weak

```
这道题属于基础语法题，可以网上搜到答案。不过真有不少同学不知道weak在对象释放后会置为nil。__block关键字的理解稍微难点，因为在arc和mrc下含义（对retain count的影响）完全不同。理解了这几个关键字就能应付使用block时引入retain cycle的风险了。这题还在内存管理的范畴之内。
```

20、使用atomic一定是线程安全的吗？

```
看这题的问法不用想答案肯定是NO。有些人说不出所以然，有些人知道通过property的方式使用才能保证安全，还有人知道这个用来做多线程安全会有性能损耗，更有出色的候选人能谈atomic,synchronized,NSLock,pthread mutex,OSSpinLock的差别
```

21、描述一个你遇到过的retain cycle例子。(别撒谎，你肯定遇到过)



22、+(void)load; +(void)initialize；有什么用处？

```

```



23、谈一谈消息发送 或者 对runtime的理解



24、如何高性能的给UIImageView加个圆角？

```
如何高性能的给 UIImageView 加个圆角?

不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。

self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;
正确的解决方案：使用绘图技术

- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}
还有一种方案：使用了贝塞尔曲线"切割"个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。

UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];

```





25、设计一套缓存策略（麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的））

```
内存缓存是个通用话题，每个平台都会涉及到。cache算法会影响到整个app的表现。候选人最好能谈下自己都了解哪些cache策略及各自的特点。常见的有FIFO,LRU,LRU-2,2Q等等。由于NSCache的缓存策略不透明，一些app开发者会选择自己做一套cache机制，其实并不难。
```



26、设计一个检测主线和卡顿的方案



27、说一下runtime，工作是如何使用的？看过runtime源码吗？



28、说几个你在工作中使用到的线程安全的例子



29、用过哪些锁？哪些锁的性能比较高？



30、说一下HTTP和HTTPs的请求过程？



31、说一下TCP和UDP



32、说一下静态库和动态库之间的区别



33、load和initialize方法分别在什么时候调用的？



34、NSNotificationCenter是在哪个线程发送的通知？



35、用过swift吗？如果没有，平常有学习吗？



36、说一下你对架构的理解？



37、为什么一定要在主线程里面更新UI？



38、ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？（把UIImageView放到UITableViewCell里面问更赞）

```
很多同学没有读源码的习惯，别人的轮子拿来只是用用却不知道真正的营养都在源代码里面。这两个经典的framework代码并不复杂，很值得一读。能对一个UIImageView怎么通过url展示一张图片有完整的理解。涉及到的知识点也非常多，UITableViewCell的复用，memory cache, disk cache, 多线程切换，甚至http协议本身都需要有一定的涉及。
```



39、讲讲你用Instrument优化动画性能的经历吧



40、loadView是干嘛用的？



41、viewWillLayoutSubView

```
controller layout触发的时候，开发者有机会去重新layout自己的各个subview。说UI熟悉的一定要知道。
```

42、GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？

```
两种queue，串行和并行。main queue是串行，global queue是并行。有些开发者为了在工作线程串行的处理任务会自己建立一个serial queue。背后是苹果维护的线程池，各种queue要用线程都是这个池子里取的。GCD大家都用过，但很多关键的概念不少人都理解的模凌两可。串行，并行，同步，异步是GCD的核心概念。
```



43、用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？

```
没用过sqlite是说不过去的。用过CoreData的肯定有很多血泪史要说。多谢线程模型你肯定做过比较选择。死锁是啥肯定也是要知道的，没遇到过至少能举个简单的例子来说明。单个线程可以死锁（main thread里dispatch_sync到main queue），多个线程直接也可以死锁（A，B线程互相持有对方需要的资源且互相等待）。
```



44、NSString如何计算字符的个数？

```

```



45、PKI体系当中加密和签名有什么区别？



46、如何自己高效实现NSUserDefault?



47、数据库建表的时候索引有什么用？



48、Full Text Search为什么快？



49、iOS下如何实现指定线程数目的线程池？



50、函数式编程当中的 first-class function是什么意思呢？



51、如何使用runtime hook一个class的某个方法，又如何hook某个instance的方法？



52、谈下Objective C都有哪些锁机制，你一般用哪个？



53、让你设计一种机制检测UIViewController的内存泄漏，你会怎么做？



54、通过[UIImage imageNamed:]生成的对象什么时候被释放？



55、applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。



56、如何终止正在运行的工作线程？



57、穷举iOS下所有的本地持久化方案。



58、项目中网络层如何做安全处理

```
尽量使用https

不要传输明文密码

Post并不比Get安全

不要使用301跳转

http请求都带上MAC

http请求使用临时密钥

AES使用CBC模式

1、尽量使用https

https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。

2、不要传输明文密码

不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh

token去申请新的token。

3、Post并不比Get安全

事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。

4、不要使用301跳转

301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。

5、http请求都带上MAC

所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication

Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request

params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。

6、http请求使用临时密钥

高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES

key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES

key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。

7、AES使用CBC模式

不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。
```





59、**假如Controller太臃肿，如何优化？**

**1.将网络请求抽象到单独的类中**

方便在基类中处理公共逻辑；

方便在基类中处理缓存逻辑，以及其它一些公共逻辑；

方便做对象的持久化。

**2.将界面的封装抽象到专门的类中**

构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。

**3.构造 ViewModel**

借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。

**4.专门构造存储类**

专门来处理本地数据的存取。

**5.整合常量**



**3.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？**

**可能造成tableView卡顿的原因有：**

**1.最常用的就是cell的重用， 注册重用标识符**

如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell

如果有很多数据的时候，就会堆积很多cell。

如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell

**2.避免cell的重新布局**

cell的布局填充等操作 比较耗时，一般创建时就布局好

如可以将cell单独放到一个自定义类，初始化时就布局好

**3.提前计算并缓存cell的属性及内容**

当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度

而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell

**4.减少cell中控件的数量**

尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，

不适用的可以先隐藏

**5.不要使用ClearColor，无背景色，透明度也不要设置为0**

渲染耗时比较长

**6.使用局部更新**

如果只是更新某组的话，使用reloadSection进行局部更

**7.加载网络数据，下载图片，使用异步加载，并缓存**

**8.少使用addView 给cell动态添加view**

**9.按需加载cell，cell滚动很快时，只加载范围内的cell**

**10.不要实现无用的代理方法，tableView只遵守两个协议**

**11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可**

**12.不要做多余的绘制工作。**在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。

**13.预渲染图像。**当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；

**14.使用正确的数据结构来存储数据。**



60、M、V、C相互通讯规则你知道的有哪些？

```
MVC 是一种设计思想，一种框架模式，是一种把应用中所有类组织起来的策略，它把你的程序分为三块，分别是：

M（Model）：实际上考虑的是“什么”问题，你的程序本质上是什么，独立于 UI 工作。是程序中用于处理应用程序逻辑的部分，通常负责存取数据。

C（Controller）：控制你 Model 如何呈现在屏幕上，当它需要数据的时候就告诉 Model，你帮我获取某某数据；当它需要 UI 展示和更新的时候就告诉 View，你帮我生成一个 UI 显示某某数据，是 Model 和 View 沟通的桥梁。

V（View）：Controller 的手下，是 Controller 要使用的类，用于构建视图，通常是根据 Model 来创建视图的。

要了解 MVC 如何工作，首先需要了解这三个模块间如何通信。

MVC通信规则

http://cc.cocimg.com/api/uploads//20171127/1511752329535960.jpg

Controller to Model

可以直接单向通信。Controller 需要将 Model 呈现给用户，因此需要知道模型的一切，还需要有同 Model 完全通信的能力，并且能任意使用 Model 的公共 API。

Controller to View

可以直接单向通信。Controller 通过 View 来布局用户界面。

Model to View

永远不要直接通信。Model 是独立于 UI 的，并不需要和 View 直接通信，View 通过 Controller 获取 Model 数据

View to Controller

View 不能对 Controller 知道的太多，因此要通过间接的方式通信。

Target

action。首先 Controller 会给自己留一个 target，再把配套的 action 交给 View 作为联系方式。那么 View

接收到某些变化时，View 就会发送 action 给 target 从而达到通知的目的。这里 View 只需要发送

action，并不需要知道 Controller 如何去执行方法。

代理。有时候 View 没有足够的逻辑去判断用户操作是否符合规范，他会把判断这些问题的权力委托给其他对象，他只需获得答案就行了，并不会管是谁给的答案。

DataSoure。View 没有拥有他们所显示数据的权力，View 只能向 Controller 请求数据进行显示，Controller 则获取 Model 的数据整理排版后提供给 View。

Model 访问 Controller

同样的 Model 是独立于 UI 存在的，因此无法直接与 Controller 通信，但是当 Model 本身信息发生了改变的时候，会通过下面的方式进行间接通信。

Notification & KVO一种类似电台的方法，Model 信息改变时会广播消息给感兴趣的人 ，只要 Controller 接收到了这个广播的时候就会主动联系 Model，获取新的数据并提供给 View。

从上面的简单介绍中我们来简单概括一下 MVC 模式的优点。

1.低耦合性

2.有利于开发分工

3.有利于组件重用

4.可维护性
```





61、NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?

```
1.不准

2.不准的原因如下：

1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。

2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。

当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。

PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。

方法一：

1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。

self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];

[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];

2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；

- (void)timerMethod2 {
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
[thread start];
}
- (void)newThread
{
@autoreleasepool
{
[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] run];
}
}
总结：

一开始的时候系统就为我们将主线程的main runloop隐式的启动了。

在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop

方法二：

使用示例

使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。

关于数据结构mach_timebase_info的定义如下：

struct mach_timebase_info {uint32_t numer;uint32_t denom;};
#include
#include
static const uint64_t NANOS_PER_USEC = 1000ULL;
static const uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;
static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;
static mach_timebase_info_data_t timebase_info;
static uint64_t nanos_to_abs(uint64_t nanos) {
return nanos * timebase_info.denom / timebase_info.numer;
}
void example_mach_wait_until(int seconds)
{
mach_timebase_info(&timebase_info);
uint64_t time_to_wait = nanos_to_abs(seconds * NANOS_PER_SEC);
uint64_t now = mach_absolute_time();
mach_wait_until(now + time_to_wait);
}
方法三：直接使用GCD替代！
```



**4.一般开始做一个项目，你的架构是如何思考的？**



####  你知道哪些设计模式，并简要叙述？

```
1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。
2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。
3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。
4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。
5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。
6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。
```



####import跟 #include 有什么区别，@class呢，#import<> 跟 #import””有什么区别？

```
1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。
2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3). #import<>用来包含系统的头文件，#import””用来包含用户头文件。
```



tableView的重用机制？



写一个线程安全的单例模式



在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？

```
答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。
```



自定义库



```
抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一
个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个
解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给是
哦难过者，如解压完成、解压出错等。在框架内部去构建对象的关系，
通过抽象让其更为健壮、便于更改。其次是API的说明文档。

```

对于Objective-C，你认为它最大的优点和最大的不足是什么

```
最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲
 突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的
命名冲突，可以使用link命令及flag解决冲突。
```

你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和G.C.D的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。

```
使用NSOperationQueue用来管理子类化的NSOperation对象，控制
其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别
是 NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中
使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中
使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，
是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接
口简单，建议在复杂项目中使用。
项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线
程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议
在简单项目中使用。

```



程序内存分区

```
程序内存分区
以下是比较常用的五分区方式，当然也不排除网上有其他的分区方式。

栈
栈的大小在编译时就已经确定了，一般是2M；栈是一块从高到低地址的连续区域，存放临时变量和执行函数时的内存等。栈内存分配分为动态和静态，静态如自动变量（局部变量）等，动态如alloc等。

堆
堆是从低到高地址的不连续区域，类似链表；用来存放malloc或new申请的内存。

全局/静态
存放静态/全局变量；全局区细分为未初始化/初始化区。

常量
存放常量；程序中使用的常量会到常量区获取。
可以看看这个例子来理解一下。

...int a;//a在全局未初始化区int a = 10;//a在全局初始化区 10在常量区static int a = 10;//a在静态区 10在常量区//程序入口int main(...) {   int a = 10;//a在栈区 10在常量区
   static int a = 10;//a在静态区 10在常量区
   char *a = (char *)malloc(10); //a在栈区 malloc后的内存在堆区
   ...
}
代码
存放二进制代码，运行程序就是执行代码，代码要执行就要加载进内存（RAM运行内存）。


```



### extern的作用

告诉编译器，这个全局变量在本文件找不到就去其他文件去找。如有必要需要使用#import "x.h"这样编译器才知道到哪里去找。使用extern前要保证对应变量被编译过。

```
//.hint age = 10;//error 不能.h此处声明全局非静态变量，.m中可以extern int age = 10;//error 和int age = 10;等价extern static int age = 10;//全局静态变量声明不和extern一起用@interface Class : NSObject...@end//.mextern static int age = 10;//全局静态变量声明不和extern一起用@implementation Class {   int age;//成员变量不能用作extern;}
- (void)test {    extern int age = 10;//error 因为这并不是全局变量
    static int age = 10;//error 因为这并不是全局变量
    extern int age;//error 因为这并不是全局变量}
...@end


```



const



static

http://www.cocoachina.com/ios/20161110/18035.html



### 指针函数/函数指针/Block

###### 指针函数

C语言的概念；本质是函数，返回指针。

```
char *fun() {    char *p = "";    return p;
}
```

###### 函数指针

C语言的概念；本质是指针，指向函数。

```
int fun(int a,int b) {    return a + b;
}int (*func)(int,int);
func = fun;
func(1,2);//3
```

###### Block

OC语言的概念；表示一个代码块，OC中视为对象；挺像C函数指针的。

```
//typedeftypedef int (^SumBlock)(int a,int b);
SumBlock sumBlock = ^(int a,int b) {    return a + b;
};
sumBlock(1,2);//3//普通
 int (^sumBlock)(int a,int b) = ^(int a,int b) {    return a + b;
};
sumBlock(1,2);//3
```



信号量：dispatch_semaphore。



### iOS类和结构体有什么区别

区别还是有很多的，答到核心的就可以了。
1：类指针赋值时只是复制了地址，结构体是复制内容；
2：类不能有同名同参数个数的方法，结构体可以；
3：结构体方法实现编译时就确定了，类方法实现可动态改变；
4：内存分配不一样，结构体在栈，类在堆；
5：结构体可以多重继承，类只能单继承。





### 线程安全方法

线程安全：多线程环境下保证数据的完整性。

###### 队列

把操作放入队列线性执行，可用GCD和NSOperationQueue。

###### 锁/信号量

用锁/信号量形成操作互斥。

###### 让操作原子化

让操作原子执行，系统提供了一些原子执行的方法。

###### 了解更多

[iOS-线程安全](https://juejin.im/entry/59cbbd1f6fb9a00a664a468f)

### NSOperationQueue和GCD区别联系

###### 区别

NSOperationQueue没有串行/并发队列，但可以设置最大并发数；
NSOperationQueue支持方法和block，GCD只支持block；
NSOperationQueue可以暂停/取消操作；
NSOperationQueue支持更多的功能，比如KVO和自定义操作；
NSOperationQueue可以设置操作的优先级，GCD只能设置队列的优先级。

###### 联系

提供的功能是相似的；
NSOperationQueue是GCD的封装。







http://www.cocoachina.com/ios/20180305/22453.html