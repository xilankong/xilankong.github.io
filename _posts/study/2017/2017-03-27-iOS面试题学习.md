## iOS部分

1.你常用的设计模式，讲一讲具体使用细节



2.在开发过程中遇到的困难、问题



3.iOS持有一个对象的原理

retainCount



4.画UML



5.产生循环引用的场景



6.



1.dSYM你是如何分析的？

```
dsym分析根据，分析 log、dsym、app


```







2.多线程有哪几种？你更倾向于哪一种？

```
NSOperation、NSThread、 GCD

倾向于gcd
```





3.单例弊端？

```

```





4.如何把异步线程转换成同步任务进行单元测试？http://blog.csdn.net/u010742414/article/details/78260938

5.介绍下App启动的完成过程？

6.比如App启动过慢，你可能想到的因素有哪些？

7.0x8badf00d表示是什么？

http://www.cnblogs.com/smileEvday/p/Crash1.html

程序启动或者恢复时间过长被watch dog终止 无响应崩溃 don‘t block main thread  否在主线程请求了网络，或者其他耗时的事情卡住了正常初始化流程。

通常系统允许一个App从启动到可以相应用户事件的时间最多为5S，如果超过了5S，App就会被系统终止掉。在Launch，resume，suspend，quit时都会有相应的时间要求。在Highlight Thread里面我们可以看到被终止时调用到的位置，xxxAppDelegate加上行号。 

PS. 在连接Xcode调试时为了便于调试，系统会暂时禁用掉Watchdog，所以此类问题的发现需要使用正常的启动模式。



8.怎么防止反编译？

9.说说你遇到到的技术难点？

10.说说你了解的第三方原理或底层知识？

3面

1.介绍下内存的几大区域？

### 栈区,堆区,静态区(全局变量区),常量区,代码区

1 栈 －－有编译器自动分配释放

 2. 堆 －－ 一般由程序员分配释放，若程序员不释放，程序结束时    可能由OS回收 

 3. 全局区（静态区） －－ 全局变量和静态变量的存储是放在一块 的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。 
 4. 另外还有一个专门放常量的地方。程序结束释放。



2.你是如何组件化解耦的？

route url注册 协议跳转

- 对每个模块间相互调用解耦
- 统一wap与本地调用

蘑菇街App组件化之路

http://limboy.me/tech/2016/03/10/mgj-components.html





3.runtime如何通过selector找到对应的IMP地址

http://blog.csdn.net/dp948080952/article/details/52437451



4.runloop内部实现逻辑？

5.你理解的多线程？

6.GCD执行原理？

7.怎么防止别人动态在你程序生成代码

8.YYAsyncLayer如何异步绘制？

9.优化你是从哪几方面着手？





招聘一个靠谱ios

http://www.cocoachina.com/ios/20150803/12872.html

http://www.cocoachina.com/ios/20150825/13195.html

http://www.cocoachina.com/ios/20171127/21331.html

http://www.jianshu.com/p/dd17bdcff9f7







## ios基础

OC语言特点

```
实例变量
@interface MyViewController :UIViewController
{
    UIButton *myButton;
}

属性
@property (nonatomic, retain) UIButton *myButton;

苹果将默认编译器从GCC转换为LLVM(low level virtual machine)，从此不再需要为属性声明实例变量了，
声明属性会自动生成一个以下划线开头的实例变量。

不想用带下划线的实例变量 
可以在实现中添加 @synthesize myButton = xxx；来改


成员变量，实例变量本质上就是成员变量，实例变量+基本数据类型变量=成员变量

成员变量是定义在｛｝号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量。而属性变量是用于与其他对象交互的变量。

属性的其他：

在@property（描述1 , 描述2 , 描述3）(class *) varName 里面，有3个描述词需要填写（也可以不填写取默认值）
1. nonatomic<-->atomic
2. readwrite<-->readonly
3. retain/copy/assign

retain：他指的是将某个内存区域的指针赋值给变量，同时把该内存区域的引用计数器加1.每执行一次，该内存区域的引用计数器就要加1，当该区域的引用计数器变为0的时候内存区域被释放！
 
copy：它指的是将目标内存区域的值复制一份，然后开辟新的内存区域（新的指针）粘贴这个值。同时变量被赋值为新内存区域的指针！
 
assign：它指的是，仅只把目标内存区域的指针赋值给变量，该内存区域的引用计数器不发生变化！
```



1、扩充C的面向对象编程语言

2、动态语言

```
1、动态类型 id

2、动态绑定 消息发送机制，编译时并未绑定、知道运行时消息发送时才进行绑定

3、动态加载 运行时动态添加代码、动态加载资源
```

3、类别的特点、类别与扩展和匿名类别的区别

```
category 类别

@interface UIView (category)
@property NSString *demo;
@end

@implementation UIView (category)
@end

匿名类别，在.m文件里面我们常用的匿名类别，这里是可以添加实例变量的

@interface UIView() {
    NSString *str;
}

类别中可以添加属性，但是不能添加实例变量，类别中的属性不会自动生成实例变量 @synthesize也不允许在category中使用。相当于提供了一套getter、setter方法。

注意一点，匿名类别(匿名扩展)是可以添加实例变量的，非匿名类别是不能添加实例变量的，只能添加方法，或者属性（其实也是方法）。

extension 扩展

oc的扩展较为简单，就是匿名类别，且扩展中的修改都是私有的
在扩展里面 我们可以更改属性的内部权限，比如对外只读可以修改为内部可读可写
```

4、self和super的区别

```
self 是类的隐藏参数，指向的是当前对象，而super并不是指向当前对象父类的指针，其实super是一个编译器标识符，在运行时与self相同指向同一个消息接受对象。只是self会优先在当前对象类的methodList中查找，而super优先在父类中查找。
```

5、定义一个对象，它的内存大小是多少

class_getInstanceSize(obj);  8个字节

6、ios能不能动态给对象添加属性

```
https://blog.csdn.net/shengyumojian/article/details/44919695
```

7、atomic和nonatomic的区别？

```
atomic：默认是有该属性的，这个属性是为了保证程序在多线程情况下，编译器会自动生成一些互斥加锁代码，避免该变量的读写不同步问题。
nonatomic：如果该对象无需考虑多线程的情况，请加入这个属性，这样会让编译器少生成一些互斥加锁代码，可以提高效率。

atomic的意思就是setter/getter这个函数，是一个原语操作，只对这两个方法处理
```



8、如何保证线程的安全

```
1、@synchronized

@synchronized(obj)指令使用obj为该锁的唯一标示，只有当标示相同时才满足互斥，使用的有优点是不需要手动去创建锁对象，缺点是会自动添加隐式的异常处理，当异常抛出时自动的释放互斥锁。

2、dispatch_semphore
等待时性能消耗低

3、NSLock
NSLock 遵循 NSLocking 协议，lock 方法是加锁，unlock 是解锁，tryLock 是尝试加锁，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。

互斥锁会使得线程阻塞，阻塞的过程又分两个阶段，第一阶段是会先空转，可以理解成跑一个 while 循环，不断地去申请加锁，在空转一定时间之后，线程会进入 waiting 状态，此时线程就不占用CPU资源了，等锁可用的时候，这个线程会立即被唤醒。

4、NSRecursiveLock递归锁
它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。


5、NSConditionLock条件锁

当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：


https://www.jianshu.com/p/cd2e5bfe4d2e
```

9、一下代码输出什么

```
dispatch_async(main_thread) {
      dispatch_sync (main_thread) {
          print("123")
      }
     print("456")
}

dispatch_async(main_thread) {
      dispatch_sync (global_thread) {
          print("123")
      }
     print("456")
}

什么都没有输出，死锁错误
```

10、解释一下runloop



11、说一下远程推送的流程



12、下面两段代码有什么问题吗？

```
//（这道题问的和前一个面试官一个）
@property(nonatomic, strong) NSArray *array;
@property(nonatomic, strong) NSObject *obj;
thread1: self.obj = [NSObject new];
thread2: [self.obj perform....];

[nil perform....];
```

13、编写一个函数，实现以下功能：“Float字符串 -> Float数字”。

14、见过在block外面使用weak属性，然后在里面加strong的吗？为什么呢？

```
在 block 之前定义对 self 的一个弱引用 wself，因为是弱引用，所以当 self 被释放时 wself 会变为 nil；然后在 block 中引用该弱应用，考虑到多线程情况，通过使用强引用 self 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放, 然后在之后的 block 块中使用该强引用 self，注意在使用前要对 self 进行了 nil 检测，因为多线程环境下在用弱引用 wself 对强引用 sself 赋值时，弱引用 wself 可能已经为 nil 了


考虑为什么 strongself retain 了 self之后 在block执行完成之后能正常释放 ？？
```

15、weak的实现原理

```
系统有一个全局的CFMutableDictionary 实例，保存每一个对象的weak指针，因为每个对象都可能有多个weak指针，
所以实例值为CFMutableSet类型

当一个对象的引用计数变为0的时候，字典中的全部对应的weak指针都会置为 nil ，

所以block中使用的weak对象指针的将为nil，给nil发消息不会崩溃，同时也解决了循环引用问题

```

https://blog.csdn.net/u013046795/article/details/50789442





## 基础部分



1、线程与进程的区别

进程是程序执行的实例，是资源分配的最小单位

线程是进程中的一个实例，是运行最小单位



2、打开一个url发生了是么

跟据域名查找ip 涉及到DNS解析

根据ip访问服务器、涉及到握手、涉及到连接建立，通信请求



3、http的请求方式

GET  POST  HEAD  OPTIONS  PUT  DELETE  TRACE  CONNECT



4、http工作过程，http是超文本传输协议，一种通信协议

http是应用层协议，由请求和响应构成，标准的客户端服务器模型，是一个无状态的协议（对事务处理没有记忆能力）

Internet中的TCP / IP协议传输，http协议就是TCP / IP模型中应用层的协议，http承载于TCP协议之上，如果承载于TLS或者SSL协议之上，就成了https

http端口号默认 80是 https端口号默认 443



工作流程：

1、访问超链接，http开始工作

2、建立连接后 客户端发送一个请求给服务器，请求格式为 ：统一资源标识符（URL）、协议版本号、MIME信息 包括请求修饰符、客户端信息和其他内容

3、服务器接受请求后，给予响应信息，格式为一个状态行，包括信息的协议版本号。一个成功或者错误的代码，MIME信息包括服务器信息、实体信息、其他内容

4、客户端接受响应信息后展示，然后断开连接



5、二叉树

