---
layout: post
category: iOS开发基础
title : "网络知识学习整理"
---



## 网络基础知识

### TCP 

TCP的全称是Transmission Control Protocol,传输控制协议。TCP并不是基于UDP协议构建的，和UDP协议一样是基于IP协议构建的。

TCP主要解决下面的三个问题:

- 数据的可靠传输。发送方如何知道发出的数据，接收方已经收到。
- 接收方的流量控制。因为各种原因，接收方可能来不及处理发送方发送的数据，而造成没有及时回应发送方，造成发送方不断的重发数据，最后造成接收方的主机宕机。
- 计算机网络的拥塞控制。数据在计算机网络之上传输，当出现数据拥塞时如何进行处理(有疑问的你，意思是现实生活中不堵车哦?)





更详细内容

### UDP

### 网络通信三要素

```
通过 “IP” 找服务器，通过 “端口” 找进程， 通过 “协议” 确定如何传输数据


IP地址(主机名)

端口号

用于标示进程的逻辑地址，不同进程的标示
有效端口：0~65535
其中 0~1024由系统使用或者保留端口
开发中不要使用 1024 以下的端口
注意 : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.

传输协议

TCP(传输控制协议) 
相当于打电话,必须先建立好链接才能传输数据. 
HTTP协议底层是基于TCP/IP协议的.
UDP(数据报文协议) 
相当于发电报,不用关心对方是否能够收到.不太安全.

HTTP网络传输协议在传输层选择的是TCP/IP协议
```



### UDP（User Datagram Protocol:用户数据报协议）

- 只管发送，不确认对方是否接收到
- 将数据源和目的封装成数据包中，不需要建立连接,是不可靠协议
- 每个数据报的大小限制在64K之内，速度快
- 应用场景：多媒体教室／网络流媒体 / 视频实时共享



### http



### HTTPS 原理详解

https://blog.upyun.com/?p=1347





https://blog.csdn.net/rock_joker/article/details/76769404





iOS开发基础-网络知识学习

在内容复杂的页面，需要实现让用户无感知的数据缓存，两份操作，网络层做一份本地缓存处理，第一次请求，检查本地是否存在缓存，如果存在，马上将本地数据返回，同时再次发起正式网络请求，等到最新数据回来再次返回数据。



+ AFNetworking使用细节整理

    ## 1.单例

    AFNetworking 使用整理，基本原理，使用细则，不常用的点

    ```
    + (instancetype)sharedClient {
        
        static YangHttpClient *_sharedClient = nil;
        
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            _sharedClient = [[YangHttpClient alloc]init];
            
            YangHTTPSessionManager * httpClient = [[YangHTTPSessionManager alloc]initWithBaseURL:[NSURL URLWithString:@"http://baidu.com"]];
            httpClient.requestSerializer = [AFHTTPRequestSerializer serializer];
            httpClient.requestSerializer.timeoutInterval = 300;
            httpClient.responseSerializer = [AFHTTPResponseSerializer serializer];
            httpClient.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"text/json",@"text/javascript", nil];
            _sharedClient.httpClient = httpClient;
            
        });
        
        
        
        return _sharedClient;
    }
    ```

    Q：

    ```
    NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END
    
    Nonnull区域设置(Audited Regions)
    如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。
    例：
    NS_ASSUME_NONNULL_BEGIN
    
    @interface TestNullabilityClass () 
    
    @property (nonatomic, copy) NSArray * items; 
    
    - (id)itemWithName:(nullable NSString *)name; 
    
    @end 
    
    NS_ASSUME_NONNULL_END
    
    在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。
    
    不过，为了安全起见，苹果还制定了几条规则：
    
    typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。
    
    复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用"nullable id * nonnull"。
    
    我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。
    ```

    Q2:

    ```
    网络请求出现Code=-1022解决办法
    
    针对AFNETWorking 更新Xcode7.0后网络请求出现如下error
    
    Error Domain=NSURLErrorDomain Code=-1022
    
    在工程的 info.plist 文件中添加 
    
    App Transport Security Settings
    
    Allow Arbitrary Loads - YES
    ```

    Q3:

    ```
    当 NSURLSessionTask cancle的时候会回调失败block
    ```



    ## iOS中的网络



    ## 2.NSURLSession

    第一步 通过NSURLSession的实例创建task
    第二部 执行task

    ​

    NSURLSessionTask(抽象类)
    ​	NSURLSessionDataTask 
    ​	NSURLSessionUploadTask （NSURLSessionDataTask 子类）
    ​	NSURLSessionDownloadTask

    ​

    AFN(3.1.0)中的封装：

    NSURLSession 目录  

    AFHTTPSessionManager（AFURLSessionManager子类）  处理  NSURLSessionDataTask

    AFURLSessionManager 处理  NSURLSessionUploadTask/NSURLSessionDownloadTask

    AFHTTPSessionManager 属性：

    1.

    @property (readonly, nonatomic, strong, nullable) NSURL *baseURL;

    根URL 比如一个APP的所有请求都是指向一个根路径下面的请求，这个baseURL就是这个根路径，方便外部请求可以直接用相对URL

    2.

    @property (nonatomic, strong) AFHTTPRequestSerializer <AFURLRequestSerialization> * requestSerializer;

    请求解析器

    ```
    httpClient.requestSerializer = [AFHTTPRequestSerializer serializer];
    httpClient.requestSerializer.timeoutInterval = 300;
    //超时时间设置
    //字符串格式设置 默认 NSUTF8StringEncoding
    //请求头设置 HTTPRequestHeaders
    ```

    3.

    @property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;

    响应解析器

    ```
    httpClient.responseSerializer = [AFJSONResponseSerializer serializer];
    httpClient.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"text/json",@"text/javascript", nil];
    // responseSerializer 默认是AFJSONResponseSerializer
    // acceptableContentTypes  允许接收的contentType 类型集合
    ```

    4.

    常见get post 请求方法

    DEPRECATED_ATTRIBUTE 的意思是  废弃属性

    ​

    AF https

    http://www.jianshu.com/p/20d5fb4cd76d

    ​

    ​

    https 抓包

    ​

    http://www.jianshu.com/p/97745be81d64

    ​

    ​

    https://www.jianshu.com/p/fafc67475c73

    ​

    ​

    ** finished with error - code: -1002**

    1002错误代码显示一个无效的URL。也许你的HTTP流媒体播放列表文件结构包含一个无效的URL(例如,失踪的方案,方案除了HTTP / https,等等)?额外的调试、设置环境变量CFNETWORK_DIAGNOSTICS = 1在Xcode项目并重新运行应用程序。一旦你知道URL是失败,这个问题可能会变得更加明显。

    -999错误，https证书信任

    ​

    本地调试https的时候，需要处理证书的信任安装问题

    ​

    https://www.jianshu.com/p/4b5d2d47833d













网络知识学习



tcp、udp、rtmp







客户端、父亲非对称加密流程，数字证书原理：

在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。

RSA是一种公钥密码体制，现在使用得很广泛。如果对RSA本身有兴趣的，后面看我有没有时间写个RSA的具体介绍。

RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。



##### 2、一个加密通信过程的演化

      我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：



###### 2.1 第一回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：？？？？

因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

**“客户”->“黑客”：你好**        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”

**“黑客”->“客户”：你好，我是服务器**

因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：

###### 2.2 第二回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

      **// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的** {你好，我是服务器}[私钥|RSA]  **就表示用私钥对**“你好，我是服务器”**进行加密后的结果。**

为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是男人}[私钥|RSA] 发给客户。

“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由男人发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为用“服务器”用私钥加密后的内容，**由并且只能由**公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。

假设“黑客”想冒充“服务器”：

**“黑客”->“客户”：你好，我是服务器**

**“客户”->“黑客”：向我证明你就是服务器**

**“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]**    //这里黑客无法冒充，因为他不知道**私钥**，无法用**私钥**加密某个字符串后发送给客户去验证。

**“客户”->“黑客”：？？？？**

由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！

到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：

###### 2.3 第三回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]

“服务器”->“客户”：{你的余额是100元}[私钥|RSA]

注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。

这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：



###### 2.4 第四回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。

“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]

在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。

由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。



客户端用服务器的公钥加密了一个随机字符串发送给服务器，服务器收到后用对应私钥加密，然后将加密的字符串发送给客户端。客户端如果使用证书中得到的公钥成功解密，则认为证书的发送方确实是服务器。此时既确定了证书（实际就是公钥内容）没有被修改，也确定了证书发送方确实是服务器。

此时客户端生成一个对称加密密钥（对称加密无所谓公钥私钥），客户端使用服务端的公钥将对称加密算法和密钥发送给服务端，之后客户端和服务端使用该对称加密密钥进行通讯，至此大功告成。

总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：

- **因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。**
- **客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。**

如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)

到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。



但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：

a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。

b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。

但是这个两个方法都有一定的问题，

对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。

对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：

“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息

“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥

“客户”->“黑客”：向我证明你就是服务器

“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”

因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。**这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。** 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。

为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：

- 证书的发布机构 
- 证书的有效期 
- 公钥 
- 证书所有者（Subject） 
- 签名所使用的算法 
- 指纹以及指纹算法

证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，**数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份**。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：

###### 2.5 第五回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：



###### 2.6 完整过程：

**step1**： “客户”向服务端发送一个通信请求

“客户”->“服务器”：你好

  

**step2**： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 



**step3**： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。

“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”->“客户”：{一个随机字符串}[私钥|RSA]



**step4**： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。

“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]

…… //继续其它的通信

###### **2.7 其它问题：**

上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。



【问题1】

上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。

〖解决方法〗

每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。



【问题2】

在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。

〖解决方法〗

可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。 



【问题3】

在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。

〖解决方法〗

在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。



原文：

http://www.blogjava.net/freeman1984/archive/2012/07/24/383817.html



1. - ​

## 2、RTMP 推流



推流，就是将采集到的音频，视频数据通过流媒体协议发送到流媒体服务器。

https://www.jianshu.com/p/66275a44eb83









# HTTPS 原理详解

https://blog.upyun.com/?p=1347









参考

http://strawhatfy.github.io/2015/07/30/TCP-IP-Protocol/