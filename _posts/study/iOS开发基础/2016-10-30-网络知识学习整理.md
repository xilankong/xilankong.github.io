---
layout: post
category: iOS开发基础
title : "网络知识学习整理"
---

## 网络通信三要素

通过 “IP” 找服务器，通过 “端口” 找进程， 通过 “协议” 确定如何传输数据

**IP地址(主机名)**

**端口号**

```
用于标示进程的逻辑地址，不同进程的标示
有效端口：0~65535
其中 0~1024由系统使用或者保留端口
开发中不要使用 1024 以下的端口

注意 : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80
```

**传输协议**

```
TCP(传输控制协议)  相当于打电话,必须先建立好链接才能传输数据.

UDP(数据报文协议) 相当于发电报,不用关心对方是否能够收到，不太安全

HTTP协议底层是基于TCP/IP协议的，网络传输协议在传输层选择的是TCP/IP协议
```

![img](https://xilankong.github.io/resource/tcp_ip_layers_other.png)



## TCP 协议了解

TCP的全称是Transmission Control Protocol,传输控制协议。TCP并不是基于UDP协议构建的，和UDP协议一样是基于IP协议构建的。

**TCP主要解决下面的三个问题:**

```
- 数据的可靠传输。发送方如何知道发出的数据，接收方已经收到。

- 接收方的流量控制。因为各种原因，接收方可能来不及处理发送方发送的数据，而造成没有及时回应发送方，造成发送方不断的重发数据，最后造成接收方的主机宕机。

- 计算机网络的拥塞控制。数据在计算机网络之上传输，当出现数据拥塞时如何进行处理
```

### TCP协议

#### 特性

**1、面向连接的传输协议**

```
应用程序在使用TCP之前，必须先建立TCP传输连接
```

**2、仅支持单播传输**

```
TCP传输连接只能有两个端点，这里的端点指套接字，也就是IP地址和端口号的组合。不支持广播和组播。
```

**3、数据的可靠传输(可靠交付)**

```
现实生活中，我们在打电话的时候，当我们自己根对方说了一句话或者一段话之后，我们都会等待对方的回应，譬如她们会回答"哦"、"嗯"、"知道了"，这时我们就会知道对方已经听到我们自己刚才说的话，如果她们不给予回应则会以为她们没有在听我讲话，也就是没有收到我发送的消息。

TCP可靠传输的实现正是基于这样的例子，对于发送方发送的数据，接收方在接受到数据之后必须要给予确认，确认它收到了数据。如果在规定时间内，没有给予确认则意味着接收方没有接受到数据，然后发送方对数据进行重发。

TCP的可靠传输是通过确认和超时重传的机制来实现的，而确认和超时重传的具体的实现是通过以字节为单位的滑动窗口机制来完成
```

**4、传输单位为数据段**

```
数据段大小受应用层传送的报文大小和所途经网络中的MTU值决定。MSS:最大数据段大小，最小数据段可能仅有21字节，其中20字节头部，1字节数据。
```

**5、支持全双工传输**

```
允许通讯双方的应用程序在任何时候都能发送数据。
```

**6、TCP连接是基于字节流，而非报文流**

```
TCP发送的数据是无界限的，因而在接收的时候需要根据长度来确认数据接收完成。
```

**7、每次发送的TCP数据段大小和数据段数都是可变的**

```
需要根据对方给出的窗口大小和当前网络的拥塞程度来决定。

数据段大小的两个决定因素:

1.每个TCP数据段的大小必须符合IP数据包的65515字节的有效载荷大小限制要求。

2.每个网络都有一个MTU值，因此每个TCP数据段必须符合MTU限制要求。
```



#### 流量控制

```
现实生活中，我们去一些热门的景点或者游乐园的某个娱乐项目时，都会需要进行排队，如果是小长假，则会出现人山人海的场景，这时这些机构就会控制每一次参观该景点的人数。

网络应用程序也是如此，当数据到达主机之后，TCP会将该数据放入相应的队列(又称为缓冲区)(如果让你自己基于UDP实现一个TCP模块供自己的应用程序使用，你也会采用这种方式)，等待监听该端口的应用程序从队列中获取数据，应用程序一次所能处理的数据有限，因此不可能一次性取出队列中的所有数据，当队列已经满了，则无法再存放新的数据，只能将接受到的数据丢弃，因此TCP协议需要提供流量控制的能力，控制发送方每次发送数据的大小。
```



#### 拥塞控制

```
现实生活中，高速公路也会堵车，在一段高速公路上，每辆车都在以很快的速度在运行，彼此并没有慢下来，但是为什么还是会出现堵车呢？通常都是因为每段道路的承载能力不一样，譬如当一段8车道公路上的汽车行驶到4车道公路上时，在这两段道路交汇的地方就会出现堵车。

计算机网络是由无数的数据链路组成的，每一段链路的承载能力不一样，也会出现数据拥堵的情况，这通常是由路由器和交换机的处理能力不同造成的。我们还需要知道，这种情况下的拥塞是不能避免的，因为我们无法要求所有链路的承载能力一样，因此我们只能对拥塞进行控制。TCP协议对拥塞控制也提出了响应的解决方案，这也是为什么TCP叫做传输控制协议而不叫做可靠传输协议的原因吧，同时也解释了为什么在计算机网络可靠性能大大提供的今天，TCP还继续发挥着其作用的原因。
```



#### 慢启动机制

```
慢启动通过逐步增大拥塞窗口的值来控制网络拥塞。

通常在刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段的数值。而在每收到一个对新报文段的确认后，把拥塞窗口增加至多一个MSS数值。

也就是说，第一次时发送1个报文，在收到接收端确认之后，第二次时发送2个报文，同样都确认后，第三次时发送4个报文，2倍指数增长。

它的名字虽然叫慢启动，但实际上一点不慢，因为指数增长是很快的，所以它需要一个上限值，默认为64k。

慢启动的作用就是最大限度使用网络资源。
```





### 连接管理

连接的作用就是让通讯双方知道并准备好通讯。

#### 建立连接，TCP三次握手

客户端与服务端建立一个 TCP 连接共计需要发送 3 个包才能完成，这个过程称为三次握手（Three-way Handshake）。如上面所述，数据段的序号、确认序号以及滑动窗口大小都在这个过程中完成。socket 编程中，客户端执行 connect() 时，将触发三次握手。

![img](https://xilankong.github.io/resource/Three-way_Handshake.png)

> 注：
>
> 1. 1415531521:1415531521(0) 表示分组的序号是 1415531521，而报文的数据字节数为 0。
> 2. WIN:4096 表示发送端通告的窗口大小为 4096，上图中由于没有交换任何数据所以窗口维持在 4096。
> 3. < MSS 1024> 表示由发端指明的最大报文段长度选项为 1024。
> 4. ACK 1415531521 表示确认序号，只在首部 ACK 标志位设置为 1 时才有效。

如上图所示完成 TCP 连接的建立，客户端与服务端共计发送了 3 个报文段：

**1、报文段1：**客户端发送一个 SYN 报文段（握手信号）指明客户打算连接的服务器的端口，以及ISN（Initial Sequence Number 初始序号，这个例子中 ISN=1415531521）。ISN 的实现目前会随着时间的变化而变化，所以每次建立连接时的 ISN 都不同。这一步告诉服务器，我要访问你了。

**1、报文段2：**服务器发回包含服务器的 ISN （初始序号）的 SYN 报文段（这个例子中 ISN=1823083521）作为应答。同时，将确认序号设置为客户的 ISN + 1 以报文段 1 进行确认。一个 SYN 将占用一个序号。服务器告诉客户端，我收到了你的访问请求。



**3、报文段3：**客户必须将确认序号设置为服务器的 ISN+1(1823083522) 以对服务器的 SYN 报文段进行确认，客户端又告诉服务器，我收到了你的确认。

4、连接建立，开始进行数据通信。



**为什么要使用三次握手**

```
为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误

比如：

一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源

问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。
```

**三次握手牵扯到的状态转换**

```
LISTEN 表示socket已经处于listen状态了，可以建立连接

SYN_SENT 表示socket在发出connect连接的时候，会首先发送SYN报文，然后等待另一端发送的确认报文(ACK)，表示这端已经发送完SYN报文了

SYN_RCVD 表示一端已经接收到SYN报文了

ESTABLISHED 表示已经建立连接了，可以发送数据了
```

**超时重传机制**

```
(1) 如果第一个包，A发送给B请求建立连接的报文(SYN)如果丢掉了，A会周期性的超时重传，直到B发出确认(SYN+ACK)；
(2) 如果第二个包，B发送给A的确认报文(SYN+ACK)如果丢掉了，B会周期性的超时重传，直到A发出确认(ACK)；
(3) 如果第三个包，A发送给B的确认报文(ACK)如果丢掉了，

A在发送完确认报文之后，单方面会进入ESTABLISHED的状态，B还是SYN_RCVD状态
如果此时双方都没有数据需要发送，B会周期性的超时发送(SYN+ACK)，直到收到A的确认报文(ACK)，此时B也进入ESTABLISHED状态，双方可以发送数据；
如果A有数据发送，A发送的是(ACK+DATA)，B会在收到这个数据包的时候自动切换到ESTABLISHED状态，并接受数据(DATA)；
如果这个时候B要发送数据，B是发送不了数据的，会周期性的超时重传(SYN+ACK)直到收到A的确认(ACK)B才能发送数据。

```



#### 同时连接

上面所示的是一方主动连接另外一方的情况，实际上 TCP 也允许双方同时主动连接，这种情况下就要求连接双方提前知道对方的端口。实际中很少出现这种需求。这种情况下，要发送 4 个报文段才能建立起连接。

![img](https://xilankong.github.io/resource/simultaneous_open.png)

**附：SYN 洪水攻击**

```
由三次握手可以看出，当服务器收到 SYN 数据报文段后将为连接分配资源，如果服务器没有收到 ACK 报文段就会造成半开连接，浪费服务器资源。SYN 洪水攻击就是利用 TCP 的这个缺陷，通过向服务器发送海量的 SYN 报文段而耗尽服务器资源。
一般有两种方式：
1、客户端恶意不发送 ACK；
2、在发送给服务器的 SYN 报文段中提供虚假的 IP 地址，造成服务器永远收不到 ACK。
```



#### 终止连接，TCP 四次挥手

建立一个连接需要 3 次握手，而终止一个连接要经过 4 次握手。这由 TCP 的半关闭（half-close，连接的一端在结束它的发送后还能接收来自另一端数据的能力。具体的请查阅 TCP 半关闭的相关资料）造成的。 TCP 连接是全双工，因此每个方向必须单独地进行关闭。也就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向连接，当一端收到一个 FIN，它必须通知应用层另一端已经终止了那个方向的数据传送。发送 FIN 通常是应用层进行关闭的结果。

连接双方都可发起这个操作，socket 编程中，任何一方执行 close() 触发挥手操作。

![img](https://xilankong.github.io/resource/Four-way_Handshake.png)

上图的 4 次挥手示意图是接着上面 3 次握手进行的，假设没有应用数据传输，所以报文段4的序号紧接着报文段1的序号（ACK 的发送是没有任何代价的，不会消耗序号）。图中所示的是一方主动关闭（首先发送 FIN 数据报），另一方被动关闭，实际上 TCP 也允许双方同时主动关闭。



#### 同时关闭

![img](https://xilankong.github.io/resource/simultaneous_close.png)



**为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？** 

```
- 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。

- 但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未 必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。 

```



**为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？**  

```
因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态(就好比从SYN_SENT 状态到ESTABLISH 状态那样)，但是我们必须假想网络是不可靠的，你无法保证你(客户端)最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。
```



**关闭TCP连接一定需要4次挥手吗?**

```
- 不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT 状态(如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源)

- 我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接(取代正常的TCP四次握手的终止方式)。但这并不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的

```



#### TCP的有限状态机

| 状态        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| CLOSED      | 呈阻塞，关闭状态，表示当前主机没有活动的传输连接或没有正在进行传输连接 |
| LISTEN      | 呈监听状态，表示服务器正在等待新的传输连接进入               |
| SYNRCVD     | 表示服务器已经收到一个传输连接请求，但尚未确认               |
| SYNSENT     | 表示客户端已经发出一个传输连接请求，等待服务器的确认         |
| ESTABLISHED | 传输连接建立                                                 |
| FIN_WAIT_1  | 主动关闭方的主机已经发送关闭连接请求，等待对方确认           |
| CLOSE_WAIT  | 被动关闭方的主机收到主动关闭方的关闭连接请求，并已确认       |
| FIN_WAIT_2  | 主动关闭方的主机已经收到对方对主动关闭连接请求的确认，等待对方发送关闭传输连接请求 |
| LAST_ACT    | 被动关闭方的主机已经发送关闭连接请求，等到主动方确认         |
| TIME_WAIT   | 主动关闭方的主机收到对方发送的关闭连接请求                   |

更详细内容



## UDP协议了解

UDP（User Datagram Protocol  用户数据报协议）协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议，提供面向事务的简单不可靠信息传送服务。

在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

UDP是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。



### 特点

**1、UDP是无连接的**

```
即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
```

**2、尽最大努力交付**

```
UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表(这里面有许多参数)。
```

**3、面向报文**

```
发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
```

**4、支持一对一、一对多、多对一和多对多的交互通信**

**5、首部开销小** 

```
只有8个字节，比TCP 的20个字节的首部要短
```

**6、没有拥塞控制系统、没有超时重发、所以速度快**

**7、当应用程序使用广播或多播时只能使用UDP协议**



### UDP 和 TCP 的区别

| 特征点     | TCP          | UDP            |
| ---------- | ------------ | -------------- |
| 是否连接   | 面向连接     | 面向非连接     |
| 传输可靠性 | 可靠         | 会丢包，不可靠 |
| 应用场景   | 传输数据量大 | 传输量小       |
| 速度       | 慢           | 快             |

1、TCP协议是提供面向连接的、可靠的字节流服务；传输数据量大，传输速度相对较慢；

2、UDP是提供面向事务的简单不可靠信息传送服务；传输数据量小，传输速度相对较快





## Http协议了解

HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。HTTP是一个基于TCP/IP通信协议来传递数据，可用于将超文本服务器中文本、图片、音视频等内容传输到客户端浏览器。



### 特点

**1、简单快速**

```
客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
```

**2、灵活**

```
HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
```

**3、无连接**

```
无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
```

**4、无状态**

```
无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
```

**5、支持 B/S 和 C/S模式**



### 请求方法

根据HTTP标准，HTTP请求可以使用多种请求方法。
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

```
GET     请求指定的页面信息，并返回实体主体。
HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
DELETE      请求服务器删除指定的页面。
CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
OPTIONS     允许客户端查看服务器的性能。
TRACE     回显服务器收到的请求，主要用于测试或诊断。
```



### URI 和 URL

#### URI 统一资源标识符

**URI（uniform resource identifier，统一资源标识符）**，用来唯一的标识一个资源。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。

Web上可用的资源（HTML文档、图像、适配、代码等等）都是一个URI来定位的，URI 一般由三部分组成：

```
1、访问资源的命名机制

2、存放资源的主机名

3、资源自身的名称，由路径表示，着重强调资源

```

**URL（uniform resource locator，统一资源定位器）**，一种具体的URI，可以标识一个资源，同时还指明了如何定位这个资源。URL 一般由三部分组成：

```
1、协议

2、资源所在主机的IP地址（端口号）

3、资源在主机上的具体地址，目录。

```

**URN（uniform resource name，统一资源命名）**，通过名字来标识资源，比如 

```
mailto:java-net@java.sun.com
```



### 请求消息（Request）

客户端发送的一个Http请求到服务器，请求消息由四个部分组成：

```
请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
```

![img](https://xilankong.github.io/resource/request.png)



下面看两个请求消息的例子，分别是GET 和 POST请求：

```
GET /build/styles.css HTTP/1.1
Host	xilankong.com
Connection	keep-alive
Accept	text/css,*/*;q=0.1
User-Agent	Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Safari/605.1.15
Accept-Language	zh-cn
Referer	http://xilankong.com/
Accept-Encoding	gzip, deflate


POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

**第一部分：请求行，用来说明请求的类型、要访问的资源以及所使用的协议版本**

```
GET说明请求类型为GET， /build/canaro-light-webfont.woff 为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。

POST说明请求类型为POST
```

**第二部分：请求头部，紧接着请求行之后的部分，用来说明服务器要使用的附加信息**

```
从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等

///////GET请求

Host
Connection	
Accept	
User-Agent	
Accept-Language	
Referer	
Accept-Encoding	

///////POST请求

Host
User-Agent
Content-Type
Content-Length
Connection
```

**第三部分：空行，请求头部后需要保证空行**

```
GET请求后续由于没有主体数据了，所以没有展示空行

POST请求 Connection 下面行就是空行
```

**第四部分：请求数据，也叫主体，可以添加任何数据，没有数据就为空** 

```
GET请求没有主体

POST请求最后一行就是主体
```



### 响应消息（Response）

一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。

```
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文
```

看个例子：

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

**第一部分：状态行，由协议版本号、状态码、状态消息构成**

```
（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）
```

**第二部分：消息报头，用来说明客户端需要使用的一些附加信息**

```
第二行和第三行就是消息报头，这里包括了响应日期时间和响应类型以及编码
```

**第三部分：空行，消息报头后面必须空行**

**第四部分：响应正文，服务器返回给客户端的文本信息**

```
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

### 状态码

```
1xx：指示信息--表示请求已接收，继续处理

2xx：成功--表示请求已被成功接收、理解、接受

3xx：重定向--要完成请求必须进行更进一步的操作

4xx：客户端错误--请求有语法错误或请求无法实现

5xx：服务器端错误--服务器未能实现合法的请求

常见的状态码

200 OK                        //客户端请求成功
400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden                 //服务器收到请求，但是拒绝提供服务
404 Not Found                 //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error     //服务器发生不可预期的错误
503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```



### 工作原理

Http协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。Http协议采用了请求/响应模型。客户端向服务器发送一个请求报文，**请求报文包含请求的方法、URL、协议版本、请求头部、请求数据**。服务器以一个状态行作为响应，**响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据**。

#### Http请求 / 响应的步骤

**1、客户端连接到web服务器**

```
一个http客户端(通常是浏览器)与服务器的Http端口(默认 80) 建立一个TCP Socket连接
```

**2、发送Http请求**

```
通过TCP Socket 客户端向服务器发送一个文本的请求报文
```

**3、服务器接受请求并返回Http响应**

```
服务器解析请求，定位请求资源，响应客户端
```



**4、释放连接**

```
若connection模式 为 close 则服务器主动关闭TCP连接，客户端被动关闭连接，若connection模式 为 keep-alive 则连接会保持一段时间，在改时间内可以继续接收请求
```



**5、客户端解析响应数据**

```
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。
```

**整个请求流程如下**

```
1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;

2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;

3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;

4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;

5、释放 TCP连接;

6、浏览器将该 html 文本并显示内容; 　
```



### GET请求和POST请求的区别

```
1、GET请求参数拼接在URL之后，以?分割URL和传输数据，多个参数用&连接；POST提交把提交的数据放置在Http请求包的包体中（主体）。

2、传输数据大小（Http协议本身并没有对传输数据的大小进行限制，协议规范也没有对URL长度进行限制）。在实际的开发中，限制来源于浏览器和服务器对URL的长度限制。由此，GET请求会受到URL长度限制。POST不通过URL传递参数，理论上数据大小不限制，但实际上服务器都会对POST提交有数据大小限制。

3、安全性，相对而言GET请求通过URL拼接参数，如果使用明文的用户名、密码将很不安全，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击

```



### Http请求的缺点

```
1、明文通信，内容能轻易被窃听

2、不验证通信双方的身份，可能遭遇伪装、冒充

3、无法证明报文的完整性，数据可能遭篡改
```



## Https协议了解

Https 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为 Http + TLS / SSL， 即 Http 下加入 SSL 层，Https 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 Http 数据传输。



### TLS / SSL

Http的基础上添加 TLS / SSL 构成了更安全的Https，那么这个TLS / SSL到底是什么？

```
SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。

SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

SSL提供的服务：
1）认证用户和服务器，确保数据发送到正确的客户机和服务器；
2）加密数据以防止数据中途被窃取；
3）维护数据的完整性，确保数据在传输过程中不被改变。

TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议 和 TLS握手协议。

SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。
```



#### SSL的工作流程

**服务器认证阶段：**

```
1、客户端向服务器发送一个开始信息 “hello” 指定SSL协议版本号、随机数、加密算法种类，以及其他信息，以便开始一个新的会话连接；

2、服务器向客户端发送SSL协议版本号、加密算法的种类、随机数、其他信息，同时包含证书；

3、客户根据收到的服务器响应信息，验证服务器的合法性，包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的发行者数字签名，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；

4、如果合法性验证通过，如果服务器要求客户的身份认证(在握手过程中为可选)，客户端随机产生一个用于后续通信的 “对称密码” ，然后用服务器的公钥（服务器提供的证书中有公钥）对其加密，然后将加密后的 “预主密码” 传递给服务器。

```

**客户认证阶段：**

```
1、验证客户证书和签名加密的随机数的合法性，包括：客户的证书是否到期，为客户提供证书的CA是否可靠，发行CA的公钥能否解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。

检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码 ”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主密码）；

2、服务器和客户端生成的相同的主密码 即 “通话密码”。一个对称密钥用于 SSL 协议的安全数据通讯。同时在SSL通信过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。

3、客户端向服务器发出信息，指明后面的数据将使用主密码为对称密钥，同时通知服务器客户端的握手过程结束。

4、服务器向客户端发出信息，指明后面的数据将使用主密码为对称密钥，同时通知客户端服务器的握手过程结束。
```

**通信阶段：**

```
SSL握手部分结束后，SSL 安全通道的数据通讯开始，客户与服务器开始使用相同的对称密钥进行数据通讯
```







## Port 和 Socket了解

### Port（端口）

伴随着传输层诞生的概念。它可以将网络层的IP通信分送到各个通信通道。UDP协议和TCP协议尽管在工作方式上有很大的不同，但它们都建立了从一个端口到另一个端口的通信。

### Socket （套接字）

Socket的作用：提供网络通信的能力

#### Socket是什么

```
Socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP/IP协议栈而已。Socket本身并不是协议，它是应用层与TCP/IP协议族通信的中间软件抽象层（在上图的TCP、IP四层网络模型中，Socket就是介于 应用层和传输层中间的抽象层。），是一组调用接口（TCP/IP网络的API函数）。

TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。 
这个就像操作系统会提供标准的编程接口，比如win32编程接口一样。 

TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口

```



#### Socket的实现原理

```
套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。一个socket句柄（文件描述符）代表两个地址对：本地ip：port -- 远程：port

应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务
```



#### Socket之间是如何通信

```
建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
```



#### iOS中的Socket编程





#### Socket连接和Http连接的区别

```
1、Http 是基于 Tcp 的，而Socket是一套编程接口让我们更方便的使用Tcp/Ip协议

2、Http是基于"请求-响应"的，服务器不能主动向客户端推送数据，只能借助客户端请求到后向客户端推送数据，而Sokcet双方随时可以互发数据

3、Http不是持久连接的，Socket用Tcp是持久连接 (聊天室功能)

4、Http基于Tcp，Socket可以基于Tcp/Udp

5、Http连接是通过Socket实现的

6、Http连接后发送的数据必须满足Http协议规定的格式：请求头、请求头和请求体，而Socket连接后发送的数据没有格式要求
```





### 

https://blog.upyun.com/?p=1347





https://blog.csdn.net/rock_joker/article/details/76769404





iOS开发基础-网络知识学习

在内容复杂的页面，需要实现让用户无感知的数据缓存，两份操作，网络层做一份本地缓存处理，第一次请求，检查本地是否存在缓存，如果存在，马上将本地数据返回，同时再次发起正式网络请求，等到最新数据回来再次返回数据。



+ AFNetworking使用细节整理

    ## 1.单例

    AFNetworking 使用整理，基本原理，使用细则，不常用的点

    ```
    + (instancetype)sharedClient {
        
        static YangHttpClient *_sharedClient = nil;
        
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            _sharedClient = [[YangHttpClient alloc]init];
            
            YangHTTPSessionManager * httpClient = [[YangHTTPSessionManager alloc]initWithBaseURL:[NSURL URLWithString:@"http://baidu.com"]];
            httpClient.requestSerializer = [AFHTTPRequestSerializer serializer];
            httpClient.requestSerializer.timeoutInterval = 300;
            httpClient.responseSerializer = [AFHTTPResponseSerializer serializer];
            httpClient.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"text/json",@"text/javascript", nil];
            _sharedClient.httpClient = httpClient;
            
        });
        
        
        
        return _sharedClient;
    }
    ```

    Q：

    ```
    NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END
    
    Nonnull区域设置(Audited Regions)
    如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。
    例：
    NS_ASSUME_NONNULL_BEGIN
    
    @interface TestNullabilityClass () 
    
    @property (nonatomic, copy) NSArray * items; 
    
    - (id)itemWithName:(nullable NSString *)name; 
    
    @end 
    
    NS_ASSUME_NONNULL_END
    
    在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。
    
    不过，为了安全起见，苹果还制定了几条规则：
    
    typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。
    
    复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用"nullable id * nonnull"。
    
    我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。
    ```

    Q2:

    ```
    网络请求出现Code=-1022解决办法
    
    针对AFNETWorking 更新Xcode7.0后网络请求出现如下error
    
    Error Domain=NSURLErrorDomain Code=-1022
    
    在工程的 info.plist 文件中添加 
    
    App Transport Security Settings
    
    Allow Arbitrary Loads - YES
    ```

    Q3:

    ```
    当 NSURLSessionTask cancle的时候会回调失败block
    ```



    ## iOS中的网络知识



    ## 2.NSURLSession

    第一步 通过NSURLSession的实例创建task
    第二部 执行task

    ​

    NSURLSessionTask(抽象类)
    ​	NSURLSessionDataTask 
    ​	NSURLSessionUploadTask （NSURLSessionDataTask 子类）
    ​	NSURLSessionDownloadTask

    ​

    AFN(3.1.0)中的封装：

    NSURLSession 目录  

    AFHTTPSessionManager（AFURLSessionManager子类）  处理  NSURLSessionDataTask

    AFURLSessionManager 处理  NSURLSessionUploadTask/NSURLSessionDownloadTask

    AFHTTPSessionManager 属性：

    1.

    @property (readonly, nonatomic, strong, nullable) NSURL *baseURL;

    根URL 比如一个APP的所有请求都是指向一个根路径下面的请求，这个baseURL就是这个根路径，方便外部请求可以直接用相对URL

    2.

    @property (nonatomic, strong) AFHTTPRequestSerializer <AFURLRequestSerialization> * requestSerializer;

    请求解析器

    ```
    httpClient.requestSerializer = [AFHTTPRequestSerializer serializer];
    httpClient.requestSerializer.timeoutInterval = 300;
    //超时时间设置
    //字符串格式设置 默认 NSUTF8StringEncoding
    //请求头设置 HTTPRequestHeaders
    ```

    3.

    @property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;

    响应解析器

    ```
    httpClient.responseSerializer = [AFJSONResponseSerializer serializer];
    httpClient.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"text/json",@"text/javascript", nil];
    // responseSerializer 默认是AFJSONResponseSerializer
    // acceptableContentTypes  允许接收的contentType 类型集合
    ```

    4.

    常见get post 请求方法

    DEPRECATED_ATTRIBUTE 的意思是  废弃属性

    ​

    AF https

    http://www.jianshu.com/p/20d5fb4cd76d

    ​

    ​

    https 抓包

    ​

    http://www.jianshu.com/p/97745be81d64

    ​

    ​

    https://www.jianshu.com/p/fafc67475c73

    ​

    ​

    ** finished with error - code: -1002**

    1002错误代码显示一个无效的URL。也许你的HTTP流媒体播放列表文件结构包含一个无效的URL(例如,失踪的方案,方案除了HTTP / https,等等)?额外的调试、设置环境变量CFNETWORK_DIAGNOSTICS = 1在Xcode项目并重新运行应用程序。一旦你知道URL是失败,这个问题可能会变得更加明显。

    -999错误，https证书信任

    ​

    本地调试https的时候，需要处理证书的信任安装问题

    ​

    https://www.jianshu.com/p/4b5d2d47833d













网络知识学习



tcp、udp、rtmp







客户端、父亲非对称加密流程，数字证书原理：

在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。

RSA是一种公钥密码体制，现在使用得很广泛。如果对RSA本身有兴趣的，后面看我有没有时间写个RSA的具体介绍。

RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。



##### 2、一个加密通信过程的演化

      我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：



###### 2.1 第一回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：？？？？

因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

**“客户”->“黑客”：你好**        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”

**“黑客”->“客户”：你好，我是服务器**

因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：

###### 2.2 第二回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

      **// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的** {你好，我是服务器}[私钥|RSA]  **就表示用私钥对**“你好，我是服务器”**进行加密后的结果。**

为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是男人}[私钥|RSA] 发给客户。

“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由男人发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为用“服务器”用私钥加密后的内容，**由并且只能由**公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。

假设“黑客”想冒充“服务器”：

**“黑客”->“客户”：你好，我是服务器**

**“客户”->“黑客”：向我证明你就是服务器**

**“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]**    //这里黑客无法冒充，因为他不知道**私钥**，无法用**私钥**加密某个字符串后发送给客户去验证。

**“客户”->“黑客”：？？？？**

由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！

到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：

###### 2.3 第三回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]

“服务器”->“客户”：{你的余额是100元}[私钥|RSA]

注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。

这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：



###### 2.4 第四回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。

“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]

在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。

由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。



客户端用服务器的公钥加密了一个随机字符串发送给服务器，服务器收到后用对应私钥加密，然后将加密的字符串发送给客户端。客户端如果使用证书中得到的公钥成功解密，则认为证书的发送方确实是服务器。此时既确定了证书（实际就是公钥内容）没有被修改，也确定了证书发送方确实是服务器。

此时客户端生成一个对称加密密钥（对称加密无所谓公钥私钥），客户端使用服务端的公钥将对称加密算法和密钥发送给服务端，之后客户端和服务端使用该对称加密密钥进行通讯，至此大功告成。

总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：

- **因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。**
- **客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。**

如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)

到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。



但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：

a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。

b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。

但是这个两个方法都有一定的问题，

对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。

对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：

“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息

“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥

“客户”->“黑客”：向我证明你就是服务器

“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”

因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。**这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。** 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。

为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：

- 证书的发布机构 
- 证书的有效期 
- 公钥 
- 证书所有者（Subject） 
- 签名所使用的算法 
- 指纹以及指纹算法

证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，**数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份**。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：

###### 2.5 第五回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：



###### 2.6 完整过程：

**step1**： “客户”向服务端发送一个通信请求

“客户”->“服务器”：你好

  

**step2**： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 



**step3**： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。

“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”->“客户”：{一个随机字符串}[私钥|RSA]



**step4**： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。

“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]

…… //继续其它的通信

###### **2.7 其它问题：**

上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。



【问题1】

上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。

〖解决方法〗

每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。



【问题2】

在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。

〖解决方法〗

可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。 



【问题3】

在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。

〖解决方法〗

在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。



原文：

http://www.blogjava.net/freeman1984/archive/2012/07/24/383817.html



1. - ​

## 2、RTMP 推流



推流，就是将采集到的音频，视频数据通过流媒体协议发送到流媒体服务器。

https://www.jianshu.com/p/66275a44eb83









# HTTPS 原理详解

https://blog.upyun.com/?p=1347









参考

http://strawhatfy.github.io/2015/07/30/TCP-IP-Protocol/