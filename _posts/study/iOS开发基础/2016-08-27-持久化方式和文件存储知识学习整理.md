---
layout: post
category: iOS开发基础
title : "持久化方式和文件存储知识学习整理"
---

> iOS持久化方式 有哪些
>
> 1、NSUserDefaults
>
> 2、NSKeyedArchiver
>
> 3、沙盒Document
>
> 4、sqlite3
>
> 5、KeyChain




持久化分为两类：沙盒内和沙盒外。

出于安全考虑，iOS系统的沙盒机制规定每个应用都只能访问当前沙盒目录下面的文件（也有例外，比如在用户授权情况下访问通讯录，相册等），这个规则展示了iOS系统的封闭性。

## 一、沙盒目录结构和各个目录的路径获取方法

![](https://xilankong.github.io/resource/ios_app_file.png)

在应用开发中，如果要保存沙盒中某个文件路径，注意不要保存全路径，只能保存在沙盒中的相对路径，否则会导致路径访问错误。这是因为每次重新编译安装应用时，沙盒目录路径会改变。以下是对每个文件夹的作用进行说明：

```
AppName.app :  应用程序包目录，包含应用程序和所需资源。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。

Documents：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。该路径可通过配置实现iTunes共享文件。会被iTunes同步。

Documents/Inbox：用来存放由外部应用请求当前应用程序打开的文件，会被iTunes同步。

Library：下面有两个目录，该路径下的文件夹，除Caches以外，都会被iTunes备份。

Preferences：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好。结果在目录下面以plist的方式存储

Caches：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。

tmp：用来存放应用再次启动时不需要的临时文件，该目录下的东西随时可能被系统清理掉，不会被iTunes同步。

```

#### 沙盒主目录

```
// 获取沙盒主目录路径
NSString *homeDir = NSHomeDirectory();
```

#### Documents目录

```
// 获取Documents目录路径
NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];

// 存放文件
NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    
NSString *fileName = [path stringByAppendingPathComponent:@"myfile"];

NSString *content = @"测试数据";

NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];

BOOL result = [contentData writeToFile:fileName atomically:YES];

//文件存放在Documents目录
```

#### Library目录

```

// 获取Library的目录路径
NSString *libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject];

// 获取Caches目录路径
NSString *cachesDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];

// 缓存文件存放和Documents目录存放文件一样

//Preferences 通过 NSUserDefault存数据
```

#### tmp目录

```
// 获取tmp目录路径
NSString *tmpDir =  NSTemporaryDirectory();

// 缓存文件存放和Documents目录存放文件一样
```

#### AppBundle目录路径

```
// 获取AppBundle目录路径
NSLog(@"%@",[[NSBundle mainBundle] bundlePath]);

NSString *imagePath = [[NSBundle mainBundle] pathForResource:@"apple" ofType:@"png"];

UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath];
```



## 二、沙盒内的持久化方式

### NSKeyedArchiver 归档

#### 1、什么是归档

```
归档是一种很常用的文件存储方法，可以存储各种类型的对象(以文件的方式保存)。

官方提供了NSKeyedArchiver和NSKeyedUnarchiver两个类以供我们把对象序列化和反序列化，在存储之前使用NSKeyedArchiver进行序列化操作，并且写入本地文件，在使用之前使用NSKeyedUnarchiver进行反序列化的操作，以供提取使用
```

#### 2、使用场景

```
如果是简单的基础数据类型，我们一般使用的是NSUserDefaults 或者 plist文件存储

对于一些量级比较大的，有规律可循的我们一般使用sqlite3数据库、coreData等

但是对于对象级别，轻量级的存储，我们一般可以使用归档来完成。
```

#### 3、归档的使用方法

1、了解NSCoding 和 NSSecureCoding，NSCoding安全性不高，所以iOS6的时候，苹果引入了NSSecureCoding协议，加强安全性。

2、需要序列化的类需要实现 NSCoding 或者 NSSecureCoding 协议（推荐使用NSSecureCoding），并复写方法：

```
- (void)encodeWithCoder:(NSCoder *)coder
- (instancetype)initWithCoder:(NSCoder *)coder
```

3、NSKeyedArchiver 和 NSKeyedUnarchiver，NSKeyedArchiver将自定义的类转换成NSData实例，类里面每一个值对应一个Key；NSKeyedUnarchiver将NSData实例根据key值还原成自定义的类。

```
NSKeyedArchiver 归档操作现在不推荐使用下面两个操作(被苹果废弃)

+ (NSData *)archivedDataWithRootObject:(id)rootObject 
+ (BOOL)archiveRootObject:(id)rootObject toFile:(NSString *)path 

推荐使用

+ (nullable NSData *)archivedDataWithRootObject:(id)object requiringSecureCoding:(BOOL)requiresSecureCoding error:(NSError **)error
```

4、归档、解档

```
NSData * data = [NSKeyedArchiver archivedDataWithRootObject:me requiringSecureCoding:YES error:&error];

Person *newPerson = (Person *)[NSKeyedUnarchiver unarchivedObjectOfClass:Person.class fromData:data error:&error];
    

```

5、例子：

```
@interface Person : NSObject <NSSecureCoding>
@property (nonatomic, strong) NSString *name;
@end

-------------------------------------------

@implementation Person
- (void)encodeWithCoder:(NSCoder *)coder
{
    [coder encodeObject:self.name forKey:@"name"];
}
- (instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super init];
    if (self) {
        self.name = [coder decodeObjectForKey:@"name"];
    }
    return self;
}
+ (BOOL)supportsSecureCoding {
    return true;
}
@end

-------------------------------------------


Person *me = [[Person alloc]init];
me.name = @"小白";
NSString *homeDir = NSHomeDirectory();

NSError *error;
NSData * data = [NSKeyedArchiver archivedDataWithRootObject:me requiringSecureCoding:YES error:&error];

NSLog(@"%@",error);
Person *newPerson = (Person *)[NSKeyedUnarchiver unarchivedObjectOfClass:Person.class fromData:data error:&error];
NSLog(@"%@",error);
NSLog(@"%@",newPerson.name);
```

#### 4、归档文件的存放

```
归档操作生成的data文件，可以通过文件存储的方式，存放到沙盒中
```



### NSUserDefaults



#### 1、存取

```
[NSUserDefaults standardUserDefaults]获取NSUserDefaults对象，以key-value方式进行持久化操作。
存
[[NSUserDefaults standardUserDefaults] setObject:array forKey:@"array"];

取
NSMutableArray *mutableArr = [NSMutableArray arrayWithArray:[defaults objectForKey:@"mutableArr"]];
```

#### 2、应用场景

```
存放一些基础数据、如判断条件等，自动登录信息。
```

#### 3、注意事项

```
1、可以存储的对象有NSString、NSArray、NSDictionary、NSData、NSNumber

2、我们还要注意NSUserDefaults存储的对象全是不可变的，就算你存的时候是可变的，最后都会被转成不可变的

比如 NSMutableArray 存储后取出时NSArray，是不可变的，需要重新构建 NSMutableArray

NSMutableArray *mutableArr = [NSMutableArray arrayWithArray:[defaults objectForKey:@"mutableArr"]];

3、对相同的key赋值等于一次覆盖，所以请保证key的唯一性
```



### Plist存储、文件存储

#### 1、plist

```
可以存储的对象有NSString、NSArray、NSDictionary、NSData、NSNumber

写入使用writeToFile，读取使用xxxWithContentsOfFile；需要指定文件路径。


写入：

NSMutableArray * array = [[NSMutableArray alloc]initWithObjects:@"小白", @"蜡笔小新", nil];

//获取Document目录地址，拼接上文件名称
NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject] stringByAppendingPathComponent:@"data.plist"];

[array writeToFile:path atomically:YES];


读取：

NSMutableArray * new_array = [NSMutableArray arrayWithContentsOfFile:path];

NSLog(@"%@",new_array);
```

#### 2、文件

这里要和plist区分一下，plist方式是字典/数组数据格式写入文件；而这里的文件方式不限数据格式。



### 数据库 sqlite3 （FMDB）

数据库无疑是大量数据最好的持久化方案，数据库目前有：sqlite、CoreData和Realm等。



#### 1、SQLite

SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。

```
1、不需要一个单独的服务器进程或操作的系统（无服务器的）
2、SQLite 不需要配置，这意味着不需要安装或管理
3、一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件
4、SQLite 是非常小的，是轻量级的，完全配置时小于 400KB，省略可选功能配置时小于250KB
5、SQLite 是自给自足的，这意味着不需要任何外部的依赖
6、SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问
```

**SQLite将数据划分为以下几种存储类型：**

```
NULL ： NULL 值
integer : 整型值
real : 浮点值
text : 文本字符串
blob : 二进制数据（比如文件）
没有 Boolean 没有用于存储日期和/或时间的类型，可用其他类型代替
实际上SQLite是无类型的，就算声明为integer类型，还是能存储字符串文本（主键除外）
```



#### 2、SQL 结构化查询语言

```
1、SQL（structured query language）：结构化查询语言
无服务器的、零配置的、事务性的 SQL 数据库引擎

2、常用关键字
select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index等等

3、语句种类

DDL：数据定义语句
create（创建）、alter（修改）、drop(删除)

create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ;
create table t_student (id integer, name text, age integer, score real) ;

ALTER TABLE table_name RENAME TO new_table_naler ;

DROP table if exists 表名 ;
DROP table t_student ;

DML：数据操作语句
包括insert、update、delete等操作
上面的3种操作分别用于添加、修改、删除表中的数据

insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …) ;
insert into t_student (name, age) values (‘mj’, 10) ;

update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … ;
update t_student set name = ‘jack’, age = 20 ;

delete from 表名 ;
delete from t_student ;

DQL：数据库查询语句
关键字select是DQL（也是所有SQL）用得最多的操作

```



#### 3、FMDB使用

**1、什么是FMDB**

```
iOS中使用C语言函数对原生SQLite数据库进行增删改查操作，复杂麻烦，于是，就出现了一系列将SQLite API封装的库，如FMDB

FMDB是针对libsqlite3框架进行封装的三方，它以OC的方式封装了SQLite的C语言的API，使用步骤与SQLite相似
```

**2、FMDB优缺点**

```
FMDB的优点是：
(1) 使用时面向对象，避免了复杂的C语言代码
(2) 对比苹果自带的Core Data框架，更加轻量级和灵活
(3) 提供多线程安全处理数据库操作方法，保证多线程安全跟数据准确性

FMDB缺点：
(1) 因为是OC语言开发，只能在iOS平台上使用，所以实现跨平台操作时存在限制性
```

**3、相关类**

```
FMDatabase：一个FMDatabase对象代表一个单独的SQLite数据库，通过SQLite语句执行数据库的增删改查操作

FMResultSet：使用FMDatabase对象查询数据库后的结果集

FMDatabaseQueue：用于多线程操作数据库，它保证线程安全
```







## 四、沙盒外的持久化方式

### KeyChain

沙盒内的方式在应用被删除后数据都会丢失，如果想要不丢失则需要使用KeyChain。
KeyChain本质是一个sqlite数据库，其保存的所有数据都是加密过的。
KeyChain分为私有和公有，公有则需要指定group，一个group中的应用可以共享此KeyChain。
使用KeyChain过程中要理解下面几个问题：

```
1：自己使用的KeyChain和系统自带的KeyChain数据是隔离的，内部应该是不同数据库文件；

2：KeyChain数据可备份到iCloud中；

3：不需要联网，也不用登陆iCloud账号；一个设备一个sqlite数据库，但是不同应用组不共享数据；

4：要在另一台设备上使用当前设备存储的KeyChain信息，需要当前设备进行数据备份，
再在另一设备上复原数据；比较常用的是iCloud备份方式；

5：系统自带的KeyChain中账号密码分类数据可在系统设置->账号与密码里面看到，
你退出iCloud账号还是存在，只是iCloud会帮你备份如果你设置了的话；这个和照片是一样的道理。
```



