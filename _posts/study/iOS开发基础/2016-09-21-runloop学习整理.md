---
layout: post
category: iOS开发基础
title : "RunLoop学习整理"
---

### 什么是RunLoop？

```
一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：

function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}

这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。

所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息->等待->处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。

iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。
```



其实，工作中的大部分时间，我们是不怎么使用runloop的，了解runloop是怎么一回事，对问题发生后的处理、和对iOS系统的工作会有一个更深的认知。

这里整理一下什么是runloop，应该注意些什么，日常哪里的使用更多，iOS本身用他做了些什么。

为了理解runloop的意义，列举几个最接近日常开发的使用点：

```
1、最熟悉的定时器任务

2、基本都遇见的bug，scrollView滑动的时候计时器不走了

3、自动释放池的工作

4、performSelecter的使用
```

RunLoop的概念前面简单介绍了，平时我们涉及到RunLoop，那么就会涉及到线程，他们之间到底是什么关系?

### RunLoop与线程的关系

苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:

```
/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef
static CFMutableDictionaryRef loopsDic;
/// 访问 loopsDic 时的锁
static CFSpinLock_t loopsLock;
 
/// 获取一个 pthread 对应的 RunLoop。
CFRunLoopRef _CFRunLoopGet(pthread_t thread) {
    OSSpinLockLock(&loopsLock);
    
    if (!loopsDic) {
        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。
        loopsDic = CFDictionaryCreateMutable();
        CFRunLoopRef mainLoop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);
    }
    
    /// 直接从 Dictionary 里获取。
    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));
    
    if (!loop) {
        /// 取不到时，创建一个
        loop = _CFRunLoopCreate();
        CFDictionarySetValue(loopsDic, thread, loop);
        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。
        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);
    }
    
    OSSpinLockUnLock(&loopsLock);
    return loop;
}
 
CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGet(pthread_main_thread_np());
}
 
CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGet(pthread_self());
}
```

所以，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。

### RunLoop 对外的接口

在 CoreFoundation 里面关于 RunLoop 有5个类:

```
CFRunLoopRef
CFRunLoopModeRef
CFRunLoopSourceRef
CFRunLoopTimerRef
CFRunLoopObserverRef
```

其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:

![](https://xilankong.github.io/resource/runLoopOne.png)



一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。

#### CFRunLoopSourceRef是事件产生的地方



#### CFRunLoopTimerRef 是基于时间的触发器

它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。

#### CFRunLoopObserverRef 是观察者

每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：

```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop
};
```

上面的 Source/Timer/Observer 被统称为 mode item。

1、一个 item 可以被同时加入多个 mode，但一个 item 被重复加入同一个 mode 时是不会有效果的。

2、如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。

3、如果mode中只有观察者 也不会进入循环。



### RunLoop的Mode

CFRunLoopMode 和 CFRunLoop 的结构大致如下：

```
struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};
 
struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set<Source/Observer/Timer>
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
```

这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。

**应用场景举例：**

主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。

有时你需要一个 Timer，在两个 Mode 中都能得到回调

```

一种办法就是将这个 Timer 分别加入这两个 Mode。

还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。

```



你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。

苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。

同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。



1、NSTimer的使用:

```
NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(wantTodo) userInfo:nil repeats:YES];

//timerWith开头的方法创建的Timer如果不加下面一句无法运行。
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];
```

2、NSTimer和scrollView的冲突问题

```
把timer加到NSRunLoopCommonModes，那么两个mode都会被分配，这样两种mode下都可以执行了。
[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
```

3、NSTimer和ViewController的循环引用

4、事件源的mode需要和当前runloop的mode 一致才会进入循环。（比如添加一个事件源到UITrackingRunLoopMode，但是runloop默认是NSDefaultRunLoopMode）



### 如何保持一个线程一直运行

```
把runloop开启为常驻

实现测试：

//外部开关
BOOL shouldKeepRunning;
//测试线程
NSThread *myThread;


shouldKeepRunning = YES;
myThread = [[NSThread alloc]initWithBlock:^{
     [self doSth];
}];
[myThread start];
    
//测试线程执行的方法
- (void)doSth {
    
    NSRunLoop *runloop = [NSRunLoop currentRunLoop]; 
    [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
	//while循环来保证不挂掉，runloop执行到永远~
    while (shouldKeepRunning && [runloop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]) {
        NSLog(@"111");
        NSLog(@"%@",[NSThread currentThread]);
    }
}

//等会在测试线程触发这个方法执行，让runloop唤醒
- (void)doOther {
    NSLog(@"22");
}
//按钮事件
- (IBAction)send:(id)sender { 
    [self performSelector:@selector(doOther) onThread:myThread withObject:nil waitUntilDone:nil];
}

当没有操作按钮的时候，并不会打印测试方法中的  111

当按钮点击的时候

2018-12-04 15:26:40.965699+0800 cyuyan[6501:46603228] 111
2018-12-04 15:26:40.966892+0800 cyuyan[6501:46603228] <NSThread: 0x600000942940>{number = 3, name = (null)}

2018-12-04 15:26:49.882592+0800 cyuyan[6501:46603228] 111
2018-12-04 15:26:49.882885+0800 cyuyan[6501:46603228] <NSThread: 0x600000942940>{number = 3, name = (null)}

多次测试，线程为同一线程。
```







### 苹果用 RunLoop 实现的功能

App 启动后 RunLoop 的状态，系统默认注册了5个Mode:

1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。
2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。
3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。
4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。
5. kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。

当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：

```
/// 1. 通知Observers，即将进入RunLoop
/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);
do {

/// 2. 通知 Observers: 即将触发 Timer 回调。
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);

/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);
__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

/// 4. 触发 Source0 (非基于port的) 回调。
__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);
__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);

/// 6. 通知Observers，即将进入休眠
/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);

/// 7. sleep to wait msg.
mach_msg() -> mach_msg_trap();

/// 8. 通知Observers，线程被唤醒
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);

/// 9. 如果是被Timer唤醒的，回调Timer
__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);

/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block
__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);

/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件
__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);

} while (...);

/// 10. 通知Observers，即将退出RunLoop
/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();
__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);
```



#### AutoreleasePool

RunLoop开始的时候，自动释放池创建、对象放入自动释放池，RunLoop进入休眠或者结束的时候 自动释放池释放并创建新的自动释放池，等待下一个循环。

#### 事件响应

UIEvent 的处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是监听回调中完成的，也是runloop。

#### 手势识别

当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。

苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。

当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

#### 界面更新

系统注册的监听者，遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。

#### 定时器

NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。

#### PerformSelecter

当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。

当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。

#### GCD

当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。



#### 网络请求







参考:

[深入理解runloop](https://blog.ibireme.com/2015/05/18/runloop/)

[iOS RunLoop入门小结](https://www.jianshu.com/p/18afd628ac43)

[Objective-C之run loop详解](http://blog.csdn.net/wzzvictory/article/details/9237973 http://www.cocoachina.com/ios/20150601/11970.html)





让App保持后台



申请音频后台播放



https://www.jianshu.com/p/d62c6d3ae8ff







最近在做番茄钟的功能。首先简单介绍一下番茄钟吧，就是25分钟工作番茄工作法。先说一下** 番茄工作法 **：

> 番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。
> 使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。
> 番茄工作法极大地提高了工作的效率，还会有意想不到的成就感。

那么功能就相当于一个25分钟的闹钟，可以播放背景音乐，到点给用户提醒。

功能听起来很简单是不是？其实挺多坑的。

开发过程中遇到了2个问题。

1. 因为番茄钟是25分钟，那么当用户开启番茄钟后很可能在中途就将APP切换到了后台，那么几分钟程序就会被系统kill掉。
2. 当用户开启番茄钟的背景音乐时，APP切换到后台或者锁屏状态时，音乐都会立即停止播放。

OK，下面我们一步一步来分析并解决这两个问题。

** 首先要理解iOS系统的后台机制 **

我们都知道，苹果对APP占用硬件资源管的很严，更不要说应用后台时候的资源占用了。正常情况下，使用应用时，APP从硬盘加载到内存，开始工作；当用户按下home键，APP便被挂起，依然驻留在内存中，这种状态下，不调用苹果已开放的几种后台方法，程序便不会运行；如果在这个时候，使程序继续运行，则为后台状态；如果当前内存将要不够用时，系统会自动把之前挂起状态下的APP请出内存。所以我们看到，有些时候打开APP时，还是上次退出时的那个页面那些数据，有时则是重新从闪屏进入。

iOS系统后台机制大概可以分为5种状态

- Not Running：APP没有启动，也没有后台运行。
- Active：用户正在使用APP，比如说我们聊微信看网页的时候，APP就处于Active状态。
- Inactive：这是一个过渡的状态，APP虽然打开了，但是用户没有跟APP有任何互动操作。
- Background：APP在后台运行，微信会在没有打开的时候接收消息。
- Suspended：APP虽然在后台运行，但是处于休眠状态，只占用一点内存。

** 那么我需要的是Background模式。即APP在后台运行同时保持程序active的状态 **

首先去xCode里面设置。到info.plist中添加以下信息：



![img](https:////upload-images.jianshu.io/upload_images/1501971-0bb9bf6e840a35e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

Snip20170301_13.png

然后到Capabilities里面打开后台模式，并根据项目的要求勾选对应的功能。我这里只需要保持后台运行并且播放背景音乐及通知功能。所以就勾选了第一个和最后一个



![img](https:////upload-images.jianshu.io/upload_images/1501971-91e6c1164e13c3ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

Snip20170301_14.png

以上这两步是告诉系统我这个APP支持后台模式，对应的环境为音频环境。

可是到这一步，APP还是不能长时间运行到后台。

为什么？我们思考一下。我们让程序支持了后台运行的模式。那么我们是不是还需要系统知道我们的程序要在后台运行多久呢？我们需要告诉系统我们期望APP在后台存活的时间。

首先声明一个属性

```
 @property (nonatomic, assign) UIBackgroundTaskIdentifier bgTask;
```

在进入后台的时候通过AppDelegate里面的方法:

```
-(void)applicationDidEnterBackground:(UIApplication *)application{
  [ self comeToBackgroundMode];
}

-(void)comeToBackgroundMode{
    //初始化一个后台任务BackgroundTask，这个后台任务的作用就是告诉系统当前app在后台有任务处理，需要时间
    UIApplication*  app = [UIApplication sharedApplication];
    self.bgTask = [app beginBackgroundTaskWithExpirationHandler:^{
    [app endBackgroundTask:self.bgTask];
    self.bgTask = UIBackgroundTaskInvalid;
    }];
    //开启定时器 不断向系统请求后台任务执行的时间
    self.timer = [NSTimer scheduledTimerWithTimeInterval:25.0 target:self selector:@selector(applyForMoreTime) userInfo:nil repeats:YES];
    [self.timer fire];
}

-(void)applyForMoreTime {
   //如果系统给的剩余时间小于60秒 就终止当前的后台任务，再重新初始化一个后台任务，重新让系统分配时间，这样一直循环下去，保持APP在后台一直处于active状态。
    if ([UIApplication sharedApplication].backgroundTimeRemaining < 60) {
    [[UIApplication sharedApplication] endBackgroundTask:self.bgTask];
    self.bgTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
        [[UIApplication sharedApplication] endBackgroundTask:self.bgTask];
        self.bgTask = UIBackgroundTaskInvalid;
    }];
    }
}
```

现在就可以让我们的APP一直运行在后台啦！总结下来的思路就是：通过一个后台任务（这个任务我们也不用管，它存在的意义就是和系统去请求后台运行的一定的时间），这个时间我们不知道也不用去管，我们可以通过该时间还剩下多少判断是否继续请求时间，如此循环，我们就可以不断的请求时间来保持我们的app一直运行在后台。

接下来解决音乐在后台模式（切换到后台或者锁屏状态）下停止播放的问题。

其实很简单。

```
//设置后台模式和锁屏模式下依然能够播放
[[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionMixWithOthers error:nil];
[[AVAudioSession sharedInstance] setActive: YES error: nil];

//初始化播放器和两个音频（一个有声 一个无声）
NSURL *urlSound = [[NSURL alloc]initWithString:[[NSBundle mainBundle]pathForResource:@"pomodoSound" ofType:@"m4a"]];
playerSound = [[AVAudioPlayer alloc] initWithContentsOfURL:urlSound error:&playerError];
NSURL *urlNoSound = [[NSURL alloc]initWithString:[[NSBundle mainBundle]pathForResource:@"backSound" ofType:@"mp3"]];
playerNoSound = [[AVAudioPlayer alloc] initWithContentsOfURL:urlNoSound error:&playerError];

playerSound.numberOfLoops = -1;
playerNoSound.numberOfLoops = -1;

player = playerSound;
[player play];
```

下面解释一下AVAudioSession的一些设置参数

- NSString *const AVAudioSessionCategoryAmbient;
  静音模式或者锁屏下不再播放音乐，和其他app声音混合。
- NSString *const AVAudioSessionCategorySoloAmbient;
  默认模式，静音模式或者锁屏下不再播放音乐，不和其他app声音混合。
- NSString *const AVAudioSessionCategoryPlayback;
  表示对于用户切换静音模式或者锁屏 都不理睬，继续播放音乐。并且不播放来自其他app的音乐
- NSString *const AVAudioSessionCategoryRecord;
  不播放音乐，锁屏状态继续录音
- NSString *const AVAudioSessionCategoryPlayAndRecord;
  播放音乐，并录音