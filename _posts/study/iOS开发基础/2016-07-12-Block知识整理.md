---
layout: post
category: iOS开发基础
title:  "block知识整理" 
---

### 什么是block

在iOS 4.0之后，block横空出世，它本身封装了一段代码并将这段代码当做变量，通过block()的方式进行回调。

自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用

法总结如下：

### 1、如何声明一个block变量

我们通过^符号来声明block类型，形式如下：

```
(1) 标准声明与定义
return_type (^blockName)(var_type) = ^return_type (var_type varName) { // ... };
blockName(var);

(2) 当返回类型为void
void (^blockName)(var_type) = ^void (var_type varName) { // ... };
blockName(var);
可省略写成
void (^blockName)(var_type) = ^(var_type varName) { // ... };
blockName(var);

(3) 当参数类型为void
return_type (^blockName)(void) = ^return_type (void) { // ... };
blockName();
可省略写成
return_type (^blockName)(void) = ^return_type { // ... };
blockName();

(4) 当返回类型和参数类型都为void
void (^blockName)(void) = ^void (void) { // ... };
blockName();
可省略写成
void (^blockName)(void) = ^{ // ... };
blockName();

(5) 匿名Block
Block实现时，等号右边就是一个匿名Block，它没有blockName，称之为匿名Block：
^return_type (var_type varName)
{ //... };
2.2 typedef简化Block的声明
利用typedef简化Block的声明：

声明
typedef return_type (^BlockTypeName)(var_type);

例子1：作属性
//声明 typedef void(^ClickBlock)(NSInteger index); //block属性 @property (nonatomic, copy) ClickBlock imageClickBlock;

例子2：作方法参数
//声明 typedef void (^handleBlock)(); //block作参数 - (void)requestForRefuseOrAccept:(MessageBtnType)msgBtnType messageModel:(MessageModel *)msgModel handle:(handleBlock)handle{
  ...
```

### 2、block的常见用法

```
1 局部位置声明一个Block型的变量

位置
return_type (^blockName)(var_type) = ^return_type (var_type varName) { // ... };
blockName(var);

例子
void (^globalBlockInMemory)(int number) = ^(int number){ 
	printf("%d \n",number);
};
globalBlockInMemory(90);

2 @interface位置声明一个Block型的属性

位置
@property(nonatomic, copy)return_type (^blockName) (var_type);

例子
//按钮点击Block @property (nonatomic, copy) void (^btnClickedBlock)(UIButton *sender);

3 在定义方法时，声明Block型的形参

用法
- (void)yourMethod:(return_type (^)(var_type))blockName;

例子
- (void)addClickedBlock:(void(^)(id obj))clickedAction;

4 在调用如上方法时，Block作实参

例子
- (void)addClickedBlock:(void(^)(id obj))clickedAction{
	self.clickedAction = clickedAction; // :先判断当前是否有交互事件，如果没有的话。。。所有gesture的交互事件都会被添加进gestureRecognizers中 
	if (![self gestureRecognizers]) { 
		self.userInteractionEnabled = YES; // :添加单击事件 
		UITapGestureRecognizer *tap = 
		[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];
        [self addGestureRecognizer:tap];
    }
}

- (void)tap{ 
	if (self.clickedAction) { 
		self.clickedAction(self);
   	}
}



```

### 3、block的少见用法

```
1 Block的内联用法

这种形式并不常用，匿名Block声明后立即被调用：

^return_type (var_type varName)
{ //... }(var);

2 Block的递归调用

Block内部调用自身，递归调用是很多算法基础，特别是在无法提前预知循环终止条件的情况下。注意：由于Block内部引用了自身，这里必须使用__block避免循环引用问题。

__block return_type (^blockName)(var_type) = [^return_type (var_type varName)
{ if (returnCondition)
    {
        blockName = nil; return;
    } // ... // 【递归调用】 blockName(varName);
} copy];

【初次调用】
blockName(varValue);

3 Block作为返回值

方法的返回值是一个Block，可用于一些“工厂模式”的方法中：

用法：
- (return_type(^)(var_type))methodName
{ return ^return_type(var_type param) { // ... };
}
```



### 4、block中访问对象的微妙关系

1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的：

```
- (void)viewDidLoad {
    [super viewDidLoad];
    int tem=2;
    block1 = ^(int a,int b){
        int count= tem+1;
        return count;
    };
    NSLog(@"%d",block1(1,1));
}
```

2、如果在block块中直接修改变量，编译器会报错：

```
 block1 = ^(int a,int b){
        tem+=1;
        return tem+1;
 };
为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点：

- (void)setUp {
    int i = 1;
     NSLog(@"%p + out",&i);
    self.block = ^(int a,int b){
        NSLog(@"%p + inside",&i);
        return 1;
    };
    self.block(2,3);
}
打印结果如下：
2017-03-06 11:11:07.657 SwiftDemo[7890:9947536] 0x7fff535bba7c + out
2017-03-06 11:11:07.657 SwiftDemo[7890:9947536] 0x7fff535bba78 + inside

可以看出，变量的地址已经改变。
```

3、block在捕获变量的时候只会保存变量被捕获时的状态（对象变量除外），之后即便变量再次改变，block中的值也不会发生改变。

4、如何对外部变量进行修改，__block 做了什么

为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明：

```
- (void)setUp {
    __block int i = 1;
     NSLog(@"%p + out",&i);
    self.block = ^(int a,int b){
        NSLog(@"%p + inside",&i);
        return 1;
    };
    self.block(2,3);
}

结果：
2017-03-06 11:17:16.438 SwiftDemo[8088:9950943] 0x7fff51ef0a78 + out
2017-03-06 11:17:16.439 SwiftDemo[8088:9950943] 0x7fff51ef0a78 + inside

由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。
```



5、关于引用计数  

```
在block中访问的对象，会默认retain：

- (void)setUp {
    UIImage *image = [UIImage new];
    NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)(image)));
    
    self.block = ^(int a,int b){
        NSLog(@"%ld",CFGetRetainCount((__bridge CFTypeRef)(image)));
    };
    self.block(2,3);
}
结果如下：
2017-03-06 11:27:47.856 SwiftDemo[8494:9958586] 1
2017-03-06 11:27:47.856 SwiftDemo[8494:9958586] 3

而添加__block的对象不会被retain;

2017-03-06 13:41:02.850 SwiftDemo[8747:9968324] 1
2017-03-06 13:41:02.850 SwiftDemo[8747:9968324] 1

注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被retain，最常见的是在block中直接使用self会有warning：

! Capturing 'self' strongly in this block is likely to lead to a retain cycle

循环引用

block在iOS开发中被视作是对象，因此其生命周期会一直等到持有者的生命周期结束了才会结束。另一方面，由于block捕获变量的机制，使得持有block的对象也可能被block持有，从而形成循环引用，导致两者都不能被释放。导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。

解决办法

系统提供给我们__weak的关键字用来修饰对象变量，声明这是一个弱引用的对象
__weak typeof(*&self) weakSelf = self;


所有的Block里面的self必须要weak一下？

很显然答案不都是，有些情况下是可以直接使用self的，比如调用系统的方法：

[UIView animateWithDuration:0.5 animations:^{ 
	NSLog(@"%@", self);
}];
因为这个block存在于静态方法中，虽然block对self强引用着，但是self却不持有这个静态方法，所以完全可以在block内部使用self。
```



### 5、block与内存管理

http://www.cocoachina.com/ios/20180424/23147.html

```


```

