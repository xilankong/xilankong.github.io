---
layout: post
category: iOS开发基础
title : "iOS常用算法"
---



///插入排序

```
var array = [22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70]
func insertion_sort(array: inout [Int]) {
    for i in 1..<array.count {
        let temp = array[i]
        for j in 0..<i {
            let p = i - j
            if temp < array[p - 1] {
               array[p] = array[p - 1]
               array[p - 1] = temp
            }
        }
    }
}
```

///选择排序

```
func selection_sort(array: inout [Int]) {
      var temp: Int = 0
      for i in 0..<array.count - 1 {
          var min = i
          //假定最小现在是array[i]
          for j in (i + 1)..<array.count {
              if array[j] < array[min] {
                  min = j
                  temp = array[i]
                  array[i] = array[j]
                  array[j] = temp
              }
          }
      }
  }

```

///冒泡排序

```
func bubble_sort(array: inout [Int]) {
      var temp: Int = 0
      for i in 0..<(array.count - 1) {
          for j in 0..<(array.count - 1 - i) {
              if array[j] > array[j + 1] {
                  temp = array[j]
                  array[j] = array[j + 1]
                  array[j + 1] = temp
              }
          }
      }
  }
```

折半查找（二分查找）

```
/**
 *  折半查找：优化查找时间（不用遍历全部数据）
 *
 *  折半查找的原理：
 *   1> 数组必须是有序的
 *   2> 必须已知min和max（知道范围）
 *   3> 动态计算mid的值，取出mid对应的值进行比较
 *   4> 如果mid对应的值大于要查找的值，那么max要变小为mid-1
 *   5> 如果mid对应的值小于要查找的值，那么min要变大为mid+1
 *
 */ 

// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 
int findKey(int *arr, int length, int key) {
    int min = 0, max = length - 1, mid;
    while (min <= max) {
        mid = (min + max) / 2; //计算中间值
        if (key > arr[mid]) {
            min = mid + 1;
        } else if (key < arr[mid]) {
            max = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}

```







不用中间变量,用两种方法交换A和B的值

```
// 1.中间变量
void swap(int a, int b) {
   int temp = a;
   a = b;
   b = temp;
}

// 2.加法
void swap(int a, int b) {
   a = a + b;
   b = a - b;
   a = a - b;
}

// 3.异或（相同为0，不同为1. 可以理解为不进位加法）
void swap(int a, int b) {
   a = a ^ b;
   b = a ^ b;
   a = a ^ b;
}
```

求最大公约数

```
/** 1.直接遍历法 */
int maxCommonDivisor(int a, int b) {
    int max = 0;
    for (int i = 1; i <=b; i++) {
        if (a % i == 0 && b % i == 0) {
            max = i;
        }
    }
    return max;
}
/** 2.辗转相除法 */
int maxCommonDivisor(int a, int b) {
    int r;
    while(a % b > 0) {
        r = a % b;
        a = b;
        b = r;
    }
    return b;
}


// 扩展：最小公倍数 = (a * b)/最大公约数

```

















  常见hash算法



http://www.cnblogs.com/mengfanrong/p/4034950.html







