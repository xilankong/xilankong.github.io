---
layout: post
category: iOS性能优化
title : "iOS底层实现逻辑"
---



### 一、AutoreleasePool  和 AutoreleasePoolPage

我们都知道  AutoreleasePool 是通过 AutoreleasePoolPage双向链表实现的，那具体的实现逻辑和自动释放时机是什么时候呢？

#### 1、AutoreleasePool

AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage作为结点以双向链表的形式组合而成。

Runtime源码，整个链表以堆栈的形式运作。

```c
void * objc_autoreleasePoolPush(void) {
		return AutoreleasePoolPage::push();
}

void * objc_autoreleasePoolPop(void *ctxt) {
		return AutoreleasePoolPage::pop(ctxt);
}

1、每一个指针代表一个加入到释放池的对象 或者是哨兵对象，哨兵对象是在 @autoreleasepool{} 构建的时候插入的

2、当自动释放池 pop的时候，所有哨兵对象之后的对象都会release

3、链表会在一个Page空间占满时进行增加，一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。
```

#### 2、AutoreleasePoolPage

结构

```
class AutoreleasePoolPage
{
		magic_t const magic;
		id *next;
		pthread_t const thread;
		AutoreleasePoolPage * const parent;
		AutoreleasePoolPage *child;
		uint32_t const depth;
		uint32_t hiwat
}
```

1、id *next 指向了下一个能存放autorelease对象地址的区域

2、parent 父节点 指向前一个page

3、child 子节点 指向下一个page

![](https://xilankong.github.io/resource/autoreleasepoolpage.jpg)



4、`POOL_BOUNDARY` 是一个边界对象 nil,之前的源代码变量名是 `POOL_SENTINEL`哨兵对象,用来区别每个page即每个 `AutoreleasePoolPage`边界

AutoreleasePoolPage::push()
调用push方法会将一个`POOL_BOUNDARY`入栈，并且返回其存放的内存地址.
push就是压栈的操作,先加入边界对象,然后添加`person1`对象,然后是`person2`对象...以此类推

AutoreleasePoolPage::pop(ctxt)
调用pop方法时传入一个`POOL_BOUNDARY`的内存地址，会从最后一个入栈的对象开始发送`release`消息，直到遇到这个`POOL_BOUNDARY`(因为是双向链表,所以可以向上寻找)

5、释放时机

关联runloop，可以看runloop的介绍，一般是即将进入休眠的时候会调用`objc_autoreleasePoolPop()`和`objc_autoreleasePoolPush()`方法. 系统会根据情况从最新加入的对象一直往前清理直到遇到`POOL_BOUNDARY`标志
而在即将退出RunLoop时会调用`objc_autoreleasePoolPop()`方法释放自动释放池内对象。

