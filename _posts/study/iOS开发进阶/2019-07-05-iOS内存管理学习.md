---
layout: post
category: iOS开发进阶
title : "iOS内存管理学习"
---



### 一、为什么要管理iOS内存

有了ARC之后为什么还需要学习内存管理？

对于我们的 App 所依赖的设备而言，内存资源是有限的。降低 App 所使用的内存可以提高性能和体验，相反，过大的内存占用可能会导致 App 被系统强制退出。所以每个 iOS 开发者都应该关注内存问题。特别是涉及到App的崩溃以及性能优化的时候就逃不开内存管理的学习。

1、为什么要减少内存

可以有更好的用户体验：更快的启动速度，不会因为内存过大而导致 Crash，可以让 App 存活更久等。



### 二、认识iOS开发中的内存知识

内存是由系统管理，一般以页为单位来划分。在 iOS 上，每一页包含 16KB 的空间。一段数据可能会占用多页内存，所占用页总数乘以每页空间得到的就是这段数据使用的总内存。

![](https://xilankong.github.io/resource/iOS-memory-1.png)

#### 1、iOS中的内存分类

通常情况下，我们所说的内存占用是指 `Dirty Memory` 、 `Compressed Memory`、`Clean Memory`。

#### 2、低内存通知

在可用物理内存较少时，iOS 会给各应用发出低内存广播通知，如果此后可用内存仍然低于特定值，则会杀死优先级较低的进程。

#### 3、没有内存交换机制、iOS 压缩内存机制

当内存不足的时候，系统会按照一定策略来腾出更多空间供使用，比较常见的做法是将一部分低优先级的数据挪到磁盘上，这个操作称为 `Page Out`。之后当再次访问到这块数据的时候，系统会负责将它重新搬回内存空间中，这个操作称为 `Page In`。

然而对于移动设备而言，频繁对磁盘进行IO操作会降低存储设备的寿命。从 iOS7 开始，系统开始采用压缩内存的办法来释放内存空间，被压缩的内存称为 `Compressed Memory`。

当内存吃紧的时候，系统会将不使用的内存进行压缩，直到下一次访问的时候进行解压。

例如，当我们使用 `Dictionary` 去缓存数据的时候，假设现在已经使用了 3 页内存，当不访问的时候可能会被压缩为 1 页，再次使用到时候又会解压成 3 页。

#### 4、使用虚拟机内存机制





### 三、iOS开发中可以通过哪些方式检查内存状态



#### 1、Xcode Memory Gauge

在 Xcode 中，你可以通过 `Memory Gauge` 工具，很方便快速的查看 App 运行时的内存情况，包括内存最高占用、最低占用，以及在所有进程中的占用比例等。如果想要查看更详细的数据，就需要用到 `Instruments` 了。

![](https://xilankong.github.io/resource/iOS-memory-9.png)

#### 2、Xcode Instruments

在 `Instruments` 中，你可以使用 `Allocations`、`Leaks`、`VM Tracker` 和 `Virtual Memory Trace` 对 App 进行多维度分析。

#### 3、Xcode Debug Memory Graph / 内存图

![](https://xilankong.github.io/resource/iOS-memory-10.png)

通过这个工具，可以很直观地查看内存中所有对象的内存使用情况，以及相互之间的依赖关系，对定位那些因为循环引用导致的内存泄露问题十分有帮助。

你也可以通过 `File->Export Memory Graph` 将其导出为 `memgraph` 文件，在命令行中使用 `Developer Tool` 对其进行分析。使用这种方式，你可以在任何时候对过去某时的 App 内存使用进行分析。





### 四、如何去管理和优化iOS中的内存





### 五、开发过程中的内存问题



#### 5、Memory Warnings

并非所有内存警告都是由 App 造成的，例如在内存较小的设备上，当你接听电话的时候也有可能发生内存警告。按照以往的习惯，你可能会在收到内存警告通知的时候去做一些释放内存的事情。然而内存压缩机制会使事情变得复杂。

当我们内存警告的时候如果去释放一份压缩状态的内存，会先展开内存，就会导致释放之前内存反而占用更多的情况。



我们对数据进行缓存的目的是想减少 CPU 的压力，但是过多的缓存又会占用过大的内存。由于内存压缩机制的存在，我们需要根据缓存数据大小以及重算这些数据的成本，在 CPU 和内存之间进行权衡。

在一些需要缓存数据的场景下，可以考虑使用 `NSCache` 代替 `NSDictionary`，因为 `NSCache` 可以自动清理内存，在内存吃紧的时候会更加合理。



### 六、参考

[理解iOS的内存管理](http://blog.devtang.com/2016/07/30/ios-memory-management/)

[WWDC 2018：iOS 内存深入研究](https://juejin.im/post/5b23dafee51d4558e03cbf4f)











野指针

https://img-blog.csdn.net/20150530183820304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGVuY2VudF9CdWdseQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center



整理引用计数等问题，释放池工作原理等

内存如何优化等



2、objective-c  runtime运行机制和内存管理机制



3、swift带来的影响、混编影响



4、ios底层实现机制



autoreleasePool实现原理

https://www.jianshu.com/p/0d32ba68fe72





### 关于内存五大分区

- **BSS段:**
  - BSS段( *bss segment* )通常是指用来存放程序中`未初始化的全局变量和静态变量` 的一块内存区域。
  - 这里注意一个问题:一般的书上都会说全局变量和静态变量是会自动初始化的,那么哪来的未初始化的变量呢?变量的初始化可以分为显示初始化和隐式初始化,全局变量和静态变量如果程序员自己不初始化的话的确也会被初始化,那就是不管什么类型都初始化为0,这种没有显示初始化的就 是我们这里所说的未初始化。`既然都是0那么就没必要把每个0都存储起来,从而节省磁盘空间,这是BSS的主要作用`
  - BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。 BSS节不包含任何数据,只是简单的维护开始和结束的地址,即总大小。以便内存区能在运行时分配并被有效地清零。BSS节在应用程序的二进制映象文件中并不存在,即不占用 磁盘空间 而只在运行的时候占用内存空间 ,`所以如果全局变量和静态变量未初始化那么其可执行文件要小很多`。
- **数据段(data segment)**
  - 通常是指用来存放程序中已经`初始化的全局变量和静态变量`的一块内存区域。数据段属于静态内存分配,可以分为`只读数据段`和`读写数据段`。字符串常量等,但一般都是放在只读数据段中。
- **代码段(code segment/text segment)**
  - 通常是指用来存放`程序执行代码的一块内存区域`。这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读, 某些架构也允许代码段为可写,即允许修改程序。在代码段中,也有可能包含一些只读的常数变量,例如字符串常量等,但一般都是放在只读数据段中 。
- **堆(heap)**
  - 堆是用于存放进程运行中被`动态分配的内存段`,它的大小并不固定,可动态扩张或 缩减。当进程调用malloc等函数分配内存时,新分配的内存就被动态添加到堆上(堆被扩张); 当利用free等函数释放内存时,被释放的内存从堆中被剔除(堆被缩减)
- **栈 (stack heap)**
  - 栈又称堆栈, 是`用户存放程序临时创建的局部变量`,也就是说我们函数括弧“{}” 中定义的变量(但不包括static声明的变量,static意味着在`数据段`中存放变量)。除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中,并且待到调用结束后,函数的返回值 也会被存放回栈中。由于栈的后进先出特点,所以 栈特别方便用来保存/恢复调用现场。从这个意义上讲,我们可以把堆栈看成一个寄存、交换临时数据的内存区。