---
layout: post
category: 2016年
title : "iOS开发常用基础知识"
---

## 基础知识部分

http://blog.csdn.net/kuangdacaikuang/article/details/53445960

### Class、Method、SEL、IMP概念

class 是指向类结构体的指针，该类结构体含有一个指向其父类的类结构体的指针，该类的方法链表，该类的方法的缓存等, NSObject 的class方法，返回的就是这样一个类结构体的指针，类结构体如下：

```
struct objc_class {
    Class isa;  //指向父类或者元类
    Class super_class  ;    //父类
    const char *name  ;     //类名
    long version   ;    //版本
    long info  ;    //信息
    long instance_size  ;    //实例变量的大小
    struct objc_ivar_list *ivars  ;    //成员变量列表
    struct objc_method_list **methodLists  ;    //方法链表,存储的是Method类型的方法
    struct objc_cache *cache   ;    //调用过的方法的缓存
    struct objc_protocol_list *protocols   ;    //要遵守的协议列表
} ;
```

#### isa 、super_class

isa就是一个class类型结构体指针，指向该对象的类结构体，通过这个指针可以访问它对应的类以及相应的父类

如下图：

![](https://xilankong.github.io/resource/runtime-isa.png)

1、isa指向对象对应的类，这个类本身也是对象，这个类对象的isa指向元类，而元类的isa指向自己

2、类对象的super_class指向其父类，一直到NSObject，NSObject的super_class是 nil

3、NSObject 的元类的父类指向NSObject

```
@interface NSObject (Sark)
+ (void)foo;
@end
@implementation NSObject (Sark)
- (void)foo {
    NSLog(@"IMP: -[NSObject (Sark) foo]");
}
@end
// 测试代码
[NSObject foo];
[[NSObject new] foo];

执行结果：编译运行正常，两行代码都执行-foo。 [NSObject foo]方法查找路线为 NSObject meta class –super-> NSObject class，和第二题知识点很相似。
```

4、这里注意，类方法的查找路线和实例方法的查找方式的查找路线分别是 ？？？？

```
类方法查找路线: 

实例方法查找路线
```



Method 

```
struct objc_method {
    SEL _Nonnull method_name           //方法名称 也就是selector
    char * _Nullable method_types      //方法的参数类型
    IMP _Nonnull method_imp            //函数指针，指向方法的具体实现
}    
// IMP 和 SEL是在运行时才配对的，一对一，通过selector去查找IMP，找到执行方法的地址，才能确定具体的执行代码
```



SEL 指向objc_selector的指针，表示方法的名字

```
typedef struct objc_selector *SEL;

当不同类的实例对象 performSelector相同的selector的时候，会在各自的方法链表，根据SEL查找对应的IMP，然后执行，不同类可以有相同selector


```

IMP 函数指针，指向方法的实现

```
typedef id (*IMP)(id, SEL, ...)

IMP 函数指针，包含一个接受消息的对象id，调用方法的方法名 SEL，以及参数个数，并返回一个id
IMP 是消息最终调用的代码
```



消息调用过程

```
[Person run];
```

对run方法的调用,编译器通过插入一些代码,将之转换为对方法具体实现IMP的调用,在Person类结构体中的方法链表中查找名称为run的SEL对象的具体方法实现找到.

```
消息函数objc_msgSend

编译器会将消息转换为对消息函数的调用 (编译器会自动参入调用该消息函数)

id objc_msgSend(id self, SEL op, ...)

消息接收者，方法名，消息参数

 [person run]; --> objc_msgSend(person, @selector(run));
 
 objc_msgSend消息函数做了动态绑定所需要的一切工作：
 
 1、找到SEL对应的方法实现IMP，不同的类对同一个方法名会有不同的实现
 2、将消息接收者对象(指向对象的指针) 以及方法中指定的参数传递给方法实现IMP
 3、最后，将方法实现的返回值作为该函数的返回值返回
 
找到对应的方法实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，他还将传递两个隐藏参数，消息接受者 以及方法名SEL，（消息接受者去调用对应的方法实现）
 
 
```



消息转发过程







类结构体中，有一个成员:  struct objc_cache *cache   ;    //调用过的方法的缓存

每个类都有一份独立的缓存，同时包括继承的方法和在该类中定义的方法。

```
//下面来剖析一段苹果官方运行时源码:
static Method look_up_method(Class cls, SEL sel, BOOL withCache, BOOL withResolver) {

    // 1. 声明IMP
    Method meth = NULL;

    // 2. 从cache中查找
    if (withCache) {
        meth = _cache_getMethod(cls, sel,&_objc_msgForward_internal);
        if (meth == (Method)1) {
            // cache中包含了这个方法的话,就停止搜索
            // Cache contains forward:: . Stop searching.
            return NULL;
        }
}

    // Ivar class_getInstaceMethod(Class cls, SEL name);
    // Ivar class_getClassMethod(Class cls, SEL name);
    // 3. 如果找不到从方法列表中查找(包括类方法列表和对象方法列表)
    if (!meth) meth = _class_getMethod(cls, sel);

    // 4. 将找到的方法缓存到cache中
    if (!meth  &&  withResolver) meth = _class_resolveMethod(cls, sel);
    return meth;

```



1，首先去该类的方法 cache 中查找，如果找到了就返回它;

2，如果没有找到，就去该类的方法列表中查找。如果在该类的方法列表中找到了，则将 IMP 返回，并将 它加入 cache中缓存起来。根据最近使用原则，这个方法再次调用的可能性很大，缓存起来可以节省下次 调用再次查找的开销。

3，如果在该类的方法列表中没找到对应的 IMP，在通过该类结构中的 super_class指针在其父类结构的方法列表中去查找，直到在某个父类的方法列表中找到对应的 IMP，返回它，并加入 cache 中;

4，如果在自身以及所有父类的方法列表中都没有找到对应的 IMP，则看是不是可以进行动态方法决议(后 面有专文讲述这个话题);

5，如果动态方法决议没能解决问题，进入下面要讲的消息转发流程。



向上查询方法的原理：









# iOS  + initialize 与 +load

https://www.jianshu.com/p/9368ce9bb8f9

1.load方法的调用时机，main函数之前，先调用类中的，再调用类别中的（类别中如果有重写）；
2.initialize方法的调用时机，当向该类发送第一个消息（一般是类消息首先调用，常见的是alloc）的时候，先调用类中的，再调用类别中的（类别中如果有重写）；如果该类只是引用，没有调用，则不会执行initialize方法。

main函数之前都发生了什么

http://blog.sunnyxx.com/2014/08/30/objc-pre-main/

巧用 class extention

http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/



## UI部分

UIApplication

https://www.jianshu.com/p/cda083e44abd

UIWindow 的理解



UIControl



UIButton

1、图文位置、按钮内部布局

```
contentEdgeInsets、titleEdgeInsets、imageEdgeInsets
文案方向：contentVerticalAlignment、contentHorizontalAlignment  属于UIControl属性
```



UITextField

1、placeholder颜色修改

2、文案显示位置修改

```
1、attributedPlaceholder 或者 kvc [textField1 setValue:[UIColor greenColor] forKeyPath:@"_placeholderLabel.textColor"];
2、重写方法、可以修改边框、文字位置、placeholder位置、编辑光标位置、删除按钮位置等
- (CGRect)borderRectForBounds:(CGRect)bounds;
- (CGRect)textRectForBounds:(CGRect)bounds;
- (CGRect)placeholderRectForBounds:(CGRect)bounds;
- (CGRect)editingRectForBounds:(CGRect)bounds;
- (CGRect)clearButtonRectForBounds:(CGRect)bounds;
- (CGRect)leftViewRectForBounds:(CGRect)bounds;
- (CGRect)rightViewRectForBounds:(CGRect)bounds;

```



UIScrollView

1、scrollview的自动布局

2、引导页制作、图片浏览器制作

3、scrollview代理实现的交互

```
1、scrollview本身可以根据内容自适应contensize，只需要内部容器做好自动布局即可
2、引导页： scrollView.pagingEnabled
图片放大缩小：maximumZoomScale zooming代理
3、scrolled代理
```





UITableView

1、复用、性能

2、cell个性化

3、cell编辑（删除、添加、选中）



UICollectionView

1、使用



UIToolbar



UIImage

#### 不用layer.cornerRadius:

```
/** * @brief clip the cornerRadius with image, UIImageView must be setFrame before, no off-screen-rendered */
- (void)zy_cornerRadiusWithImage:(UIImage *)image cornerRadius:(CGFloat)cornerRadius rectCornerType:(UIRectCorner)rectCornerType { 
    CGSize size = self.bounds.size; 
    CGFloat scale = [UIScreen mainScreen].scale; 
    CGSize cornerRadii = CGSizeMake(cornerRadius, cornerRadius);     
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ 
        UIGraphicsBeginImageContextWithOptions(size, YES, scale); 
        if (nil == UIGraphicsGetCurrentContext()) { 
            return; 
        } 
        UIBezierPath *cornerPath = [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:rectCornerType cornerRadii:cornerRadii]; 
        [cornerPath addClip]; 
        [image drawInRect:self.bounds]; 
        id processedImageRef = (__bridge id _Nullable)(UIGraphicsGetImageFromCurrentImageContext().CGImage); 
        UIGraphicsEndImageContext(); 
        dispatch_async(dispatch_get_main_queue(), ^{ 
            self.layer.contents = processedImageRef; 
        }); 
    });
}
```

对图片进行了切角处理后，将得到的含圆角UIImage通过-setImage传给了



1、图片截取、防止失真





