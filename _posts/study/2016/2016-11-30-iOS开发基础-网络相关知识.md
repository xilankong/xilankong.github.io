iOS开发基础-网络相关知识

在内容复杂的页面，需要实现让用户无感知的数据缓存，两份操作，网络层做一份本地缓存处理，第一次请求，检查本地是否存在缓存，如果存在，马上将本地数据返回，同时再次发起正式网络请求，等到最新数据回来再次返回数据。



+ AFNetworking使用细节整理

    ## 1.单例

    AFNetworking 使用整理，基本原理，使用细则，不常用的点

    ```
    + (instancetype)sharedClient {
        
        static YangHttpClient *_sharedClient = nil;
        
        static dispatch_once_t onceToken;
        dispatch_once(&onceToken, ^{
            _sharedClient = [[YangHttpClient alloc]init];
            
            YangHTTPSessionManager * httpClient = [[YangHTTPSessionManager alloc]initWithBaseURL:[NSURL URLWithString:@"http://baidu.com"]];
            httpClient.requestSerializer = [AFHTTPRequestSerializer serializer];
            httpClient.requestSerializer.timeoutInterval = 300;
            httpClient.responseSerializer = [AFHTTPResponseSerializer serializer];
            httpClient.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"text/json",@"text/javascript", nil];
            _sharedClient.httpClient = httpClient;
            
        });
        
        
        
        return _sharedClient;
    }
    ```

    Q：

    ```
    NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END

    Nonnull区域设置(Audited Regions)
    如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。
    例：
    NS_ASSUME_NONNULL_BEGIN

    @interface TestNullabilityClass () 

    @property (nonatomic, copy) NSArray * items; 

    - (id)itemWithName:(nullable NSString *)name; 

    @end 

    NS_ASSUME_NONNULL_END

    在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。

    不过，为了安全起见，苹果还制定了几条规则：

    typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。

    复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用"nullable id * nonnull"。

    我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。
    ```

    Q2:

    ```
    网络请求出现Code=-1022解决办法

    针对AFNETWorking 更新Xcode7.0后网络请求出现如下error

    Error Domain=NSURLErrorDomain Code=-1022

    在工程的 info.plist 文件中添加 

    App Transport Security Settings

    Allow Arbitrary Loads - YES
    ```

    Q3:

    ```
    当 NSURLSessionTask cancle的时候会回调失败block
    ```

    ​

    ## 2.NSURLSession

    第一步 通过NSURLSession的实例创建task
    第二部 执行task

    ​

    NSURLSessionTask(抽象类)
    ​	NSURLSessionDataTask 
    ​	NSURLSessionUploadTask （NSURLSessionDataTask 子类）
    ​	NSURLSessionDownloadTask

    ​

    AFN(3.1.0)中的封装：

    NSURLSession 目录  

    AFHTTPSessionManager（AFURLSessionManager子类）  处理  NSURLSessionDataTask

    AFURLSessionManager 处理  NSURLSessionUploadTask/NSURLSessionDownloadTask

    AFHTTPSessionManager 属性：

    1.

    @property (readonly, nonatomic, strong, nullable) NSURL *baseURL;

    根URL 比如一个APP的所有请求都是指向一个根路径下面的请求，这个baseURL就是这个根路径，方便外部请求可以直接用相对URL

    2.

    @property (nonatomic, strong) AFHTTPRequestSerializer <AFURLRequestSerialization> * requestSerializer;

    请求解析器

    ```
    httpClient.requestSerializer = [AFHTTPRequestSerializer serializer];
    httpClient.requestSerializer.timeoutInterval = 300;
    //超时时间设置
    //字符串格式设置 默认 NSUTF8StringEncoding
    //请求头设置 HTTPRequestHeaders
    ```

    3.

    @property (nonatomic, strong) AFHTTPResponseSerializer <AFURLResponseSerialization> * responseSerializer;

    响应解析器

    ```
    httpClient.responseSerializer = [AFJSONResponseSerializer serializer];
    httpClient.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/html",@"text/json",@"text/javascript", nil];
    // responseSerializer 默认是AFJSONResponseSerializer
    // acceptableContentTypes  允许接收的contentType 类型集合
    ```

    4.

    常见get post 请求方法

    DEPRECATED_ATTRIBUTE 的意思是  废弃属性

    ​

    AF https

    http://www.jianshu.com/p/20d5fb4cd76d

    ​

    ​

    https 抓包

    ​

    http://www.jianshu.com/p/97745be81d64

    ​

    ​

    https://www.jianshu.com/p/fafc67475c73

    ​

    ​

    ** finished with error - code: -1002**

    1002错误代码显示一个无效的URL。也许你的HTTP流媒体播放列表文件结构包含一个无效的URL(例如,失踪的方案,方案除了HTTP / https,等等)?额外的调试、设置环境变量CFNETWORK_DIAGNOSTICS = 1在Xcode项目并重新运行应用程序。一旦你知道URL是失败,这个问题可能会变得更加明显。

    -999错误，https证书信任

    ​

    本地调试https的时候，需要处理证书的信任安装问题

    ​

    https://www.jianshu.com/p/4b5d2d47833d













网络知识学习



tcp、udp、rtmp







客户端、父亲非对称加密流程，数字证书原理：

在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。前面所说的公钥密码体制就是一种非对称加密算法，他的公钥和是私钥是不能相同的，也就是说加密使用的密钥和解密使用的密钥不同，因此它是一个非对称加密算法。

RSA是一种公钥密码体制，现在使用得很广泛。如果对RSA本身有兴趣的，后面看我有没有时间写个RSA的具体介绍。

RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。



##### 2、一个加密通信过程的演化

      我们来看一个例子，现在假设“服务器”和“客户”要在网络上通信，并且他们打算使用RSA(参看前面的RSA简介)来对通信进行加密以保证谈话内容的安全。由于是使用RSA这种公钥密码体制，“服务器”需要对外发布公钥(算法不需要公布，RSA的算法大家都知道)，自己留着私钥。“客户”通过某些途径拿到了“服务器”发布的公钥，客户并不知道私钥。“客户”具体是通过什么途径获取公钥的，我们后面再来说明，下面看一下双方如何进行保密的通信：



###### 2.1 第一回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：？？？？

因为消息是在网络上传输的，有人可以冒充自己是“服务器”来向客户发送信息。例如上面的消息可以被黑客截获如下：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

**“客户”->“黑客”：你好**        // 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”

**“黑客”->“客户”：你好，我是服务器**

因此“客户”在接到消息后，并不能肯定这个消息就是由“服务器”发出的，某些“黑客”也可以冒充“服务器”发出这个消息。如何确定信息是由“服务器”发过来的呢？有一个解决方法，因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。因此通信过程可以改进为如下：

###### 2.2 第二回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

      **// 注意这里约定一下，{} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密，后面的示例中都用这种表示方式，例如上面的** {你好，我是服务器}[私钥|RSA]  **就表示用私钥对**“你好，我是服务器”**进行加密后的结果。**

为了向“客户”证明自己是“服务器”， “服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。对于这里的例子来说，就是把字符串 “你好，我是服务器”和这个字符串用私钥加密后的内容 {你好，我是男人}[私钥|RSA] 发给客户。

“客户”收到信息后，她用自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由男人发过来的。也就是说“客户”把 {你好，我是服务器}[私钥|RSA] 这个内容用公钥进行解密，然后和“你好，我是服务器”对比。因为用“服务器”用私钥加密后的内容，**由并且只能由**公钥进行解密，私钥只有“服务器”持有，所以如果解密出来的内容是能够对得上的，那说明信息一定是从“服务器”发过来的。

假设“黑客”想冒充“服务器”：

**“黑客”->“客户”：你好，我是服务器**

**“客户”->“黑客”：向我证明你就是服务器**

**“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]**    //这里黑客无法冒充，因为他不知道**私钥**，无法用**私钥**加密某个字符串后发送给客户去验证。

**“客户”->“黑客”：？？？？**

由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！

到这里为止，“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。为什么无法保密呢？通信过程不是可以用公钥、私钥加密吗？其实用RSA的私钥和公钥是不行的，我们来具体分析下过程，看下面的演示：

###### 2.3 第三回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]

“服务器”->“客户”：{你的余额是100元}[私钥|RSA]

注意上面的的信息 {你的余额是100元}[私钥]，这个是“服务器”用私钥加密后的内容，但是我们之前说了，公钥是发布出去的，因此所有的人都知道公钥，所以除了“客户”，其它的人也可以用公钥对{你的余额是100元}[私钥]进行解密。所以如果“服务器”用私钥加密发给“客户”，这个信息是无法保密的，因为只要有公钥就可以解密这内容。然而“服务器”也不能用公钥对发送的内容进行加密，因为“客户”没有私钥，发送个“客户”也解密不了。

这样问题就又来了，那又如何解决呢？在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：



###### 2.4 第四回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]    //蓝色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。

“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]

在上面的通信过程中，“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。注意，由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。

由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。



客户端用服务器的公钥加密了一个随机字符串发送给服务器，服务器收到后用对应私钥加密，然后将加密的字符串发送给客户端。客户端如果使用证书中得到的公钥成功解密，则认为证书的发送方确实是服务器。此时既确定了证书（实际就是公钥内容）没有被修改，也确定了证书发送方确实是服务器。

此时客户端生成一个对称加密密钥（对称加密无所谓公钥私钥），客户端使用服务端的公钥将对称加密算法和密钥发送给服务端，之后客户端和服务端使用该对称加密密钥进行通讯，至此大功告成。

总结一下，RSA加密算法在这个通信过程中所起到的作用主要有两个：

- **因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。**
- **客户端通过RSA的掩护，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。**

如果这里您理解了为什么不用RSA去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，那么就说明前面的内容您已经理解了。(如果不清楚，再看下2.3和2.4，如果还是不清楚，那应该是我们说清楚，您可以留言提问。)

到这里，“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。的确，好像通信的过程是比较安全了。



但是这里还留有一个问题，在最开始我们就说过，“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？我们第一反应可能会想到以下的两个方法：

a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。

b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。

但是这个两个方法都有一定的问题，

对于a)方法，“客户”无法确定这个下载地址是不是“服务器”发布的，你凭什么就相信这个地址下载的东西就是“服务器”发布的而不是别人伪造的呢，万一下载到一个假的怎么办？另外要所有的“客户”都在通信前事先去下载公钥也很不现实。

对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。示意如下：

“客户”->“黑客”：你好           //黑客截获“客户”发给“服务器”的消息

“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥

“客户”->“黑客”：向我证明你就是服务器

“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]      //客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”

因此“黑客”只需要自己生成一对公钥和私钥，然后把公钥发送给“客户”，自己保留私钥，这样由于“客户”可以用黑客的公钥解密黑客的私钥加密的内容，“客户”就会相信“黑客”是“服务器”，从而导致了安全问题。**这里问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。** 如果能够确定公钥到底是谁的，就不会有这个问题了。例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。

为了解决这个问题，数字证书出现了，它可以解决我们上面的问题。先大概看下什么是数字证书，一个证书包含下面的具体内容：

- 证书的发布机构 
- 证书的有效期 
- 公钥 
- 证书所有者（Subject） 
- 签名所使用的算法 
- 指纹以及指纹算法

证书的内容的详细解释会在后面详细解释，这里先只需要搞清楚一点，**数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份**。也就是说，我们拿到一个数字证书，我们可以判断出这个数字证书到底是谁的。至于是如何判断的，后面会在详细讨论数字证书时详细解释。现在把前面的通信过程使用数字证书修改为如下：

###### 2.5 第五回合：

“客户”->“服务器”：你好

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书        //这里用证书代替了公钥

“客户”->“服务器”：向我证明你就是服务器

“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

注意，上面第二次通信，“服务器”把自己的证书发给了“客户”，而不是发送公钥。“客户”可以根据证书校验这个证书到底是不是“服务器”的，也就是能校验这个证书的所有者是不是“服务器”，从而确认这个证书中的公钥的确是“服务器”的。后面的过程和以前是一样，“客户”让“服务器”证明自己的身份，“服务器”用私钥加密一段内容连同明文一起发给“客户”，“客户”把加密内容用数字证书中的公钥解密后和明文对比，如果一致，那么对方就确实是“服务器”，然后双方协商一个对称加密来保证通信过程的安全。到这里，整个过程就完整了，我们回顾一下：



###### 2.6 完整过程：

**step1**： “客户”向服务端发送一个通信请求

“客户”->“服务器”：你好

  

**step2**： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 



**step3**： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。

“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串     //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”->“客户”：{一个随机字符串}[私钥|RSA]



**step4**： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。

“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]

…… //继续其它的通信

###### **2.7 其它问题：**

上面的过程已经十分接近HTTPS的真实通信过程了，完全可以按照这个过程去理解HTTPS的工作原理。但是我为了方便解释，上面有些细节没有说到，有兴趣的人可以看下这部分的内容。可以跳过不看，无关紧要。



【问题1】

上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。

〖解决方法〗

每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个hash计算，加密这个字符串的hash值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个hash值并自己计算字符串的hash值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个hash值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的hash值，然后再把“服务器”发送过来的加密的hash值和自己计算的进行对比，同样也能确定对方是否是“服务器”。



【问题2】

在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。

〖解决方法〗

可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。 



【问题3】

在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。

〖解决方法〗

在每次发送信息时，先对信息的内容进行一个hash计算得出一个hash值，将信息的内容和这个hash值一起加密后发送。接收方在收到后进行解密得到明文的内容和hash值，然后接收方再自己对收到信息内容做一次hash计算，与收到的hash值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。



原文：

http://www.blogjava.net/freeman1984/archive/2012/07/24/383817.html





## 1、TCP-UDP

### 网络通信三要素

```
通过 “IP” 找服务器，通过 “端口” 找进程， 通过 “协议” 确定如何传输数据


IP地址(主机名)

端口号

用于标示进程的逻辑地址，不同进程的标示
有效端口：0~65535
其中 0~1024由系统使用或者保留端口
开发中不要使用 1024 以下的端口
注意 : 跟HTTP相关的端口一定是80.服务器上有个进程是专门处理HTTP请求的,端口号是80.

传输协议

TCP(传输控制协议) 
相当于打电话,必须先建立好链接才能传输数据. 
HTTP协议底层是基于TCP/IP协议的.
UDP(数据报文协议) 
相当于发电报,不用关心对方是否能够收到.不太安全.

HTTP网络传输协议在传输层选择的是TCP/IP协议
```



### UDP（User Datagram Protocol:用户数据报协议）

- 只管发送，不确认对方是否接收到
- 将数据源和目的封装成数据包中，不需要建立连接,是不可靠协议
- 每个数据报的大小限制在64K之内，速度快
- 应用场景：多媒体教室／网络流媒体 / 视频实时共享

### TCP（Transmission Control Protocol:传输控制协议）

- 建立连接，形成传输数据的通道
- 在连接中进行大数据传输（数据大小不受限制）
- 通过三次握手完成连接，四次分手结束连接,是可靠协议，安全送达
- 必须建立连接，效率会稍低,TCP协议的传输速度比UDP协议慢
- 提供超时重发，丢弃重复数据，检验数据，流量控制等功能

### TCP三次握手建立连接

- 要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。
- 当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。
- TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。
- ACK表示Acknowledgment Number字段有意义 
  PSH表示Push功能，RST表示复位TCP连接 
  SYN表示SYN报文（在建立TCP连接的时候使用,发起一个新连接） 
  FIN表示没有数据需要发送了（在关闭TCP连接的时候使用）

TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

位码即tcp标志位,有6种标示:

SYN(synchronous建立联机)

ACK(acknowledgement 确认)

PSH(push传送)

FIN(finish结束)

RST(reset重置)

URG(urgent紧急)

Sequence number(顺序号码)

Acknowledge number(确认号码)



各个状态的意义如下：

LISTEN - 侦听来自远方TCP端口的连接请求；  
SYN-SENT -在发送连接请求后等待匹配的连接请求；  
SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；  
ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；  
FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； 
FIN-WAIT-2 - 从远程TCP等待连接中断请求；  
CLOSE-WAIT - 等待从本地用户发来的连接中断请求；  
CLOSING -等待远程TCP对连接中断的确认；  
LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；  
TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；  
CLOSED - 没有任何连接状态；



第一次握手：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 

第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进 入SYN_RECV状态； 

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 连接状态，完成三次握手，客户端与服务器开始传送数据.

```
握手过程中传送的包里”不包含数据 “，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。
```



![png](https://xilankong.github.io/resource/tcp.png)



如上：

### TCP四次挥手断开连接

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN 来终止这个方向的发送通道。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 

（ 1 ）客户端 A 发送一个 FIN ，用来关闭客户 A 到服务器 B 的数据传送。 
（ 2 ）服务器 B 收到这个 FIN ，它返回一个 ACK ，确认序号为收到的序号加 1 。和 SYN 一样，一个FIN 将占用一个序号。 
（ 3 ）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A 。 
（ 4 ）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1 ,客服端关闭与服务器的连接。



### 拓展

1. 为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？ 
   - 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。
   - 但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未 必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。 
2. 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？  
   因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态(就好比从SYN_SENT 状态到ESTABLISH 状态那样)，但是我们必须假想网络是不可靠的，你无法保证你(客户端)最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。
3. 关闭TCP连接一定需要4次挥手吗?
   - 不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT 状态(如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源)
   - 我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接(取代正常的TCP四次握手的终止方式)。但这并不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的

## 2、RTMP 推流



推流，就是将采集到的音频，视频数据通过流媒体协议发送到流媒体服务器。

https://www.jianshu.com/p/66275a44eb83



