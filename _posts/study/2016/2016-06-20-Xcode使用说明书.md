---
layout: post
category: 2016年
title : "Xcode使用说明书"
---

> ​	作为iOS开发，我绝大部分时间都在与Xcode打交道，把自己遇到的或别人遇到的各种坑，各种开发小知识在这里做一个整理。更好、更高效的使用Xcode才能更快速的进行开发工作。



## Xcode的使用

### 1.Xcode 操作面板

![](https://xilankong.github.io/resource/gs_main_window.png)



- #### 工具栏（Toolbar）

  你选择工作视图,运行app, 在不同布局界面切换的工具栏

  ![](https://xilankong.github.io/resource/XC_O_Toolbar.png)

  从左到右分别是：

  运行、停止按钮、Scheme列表、模拟器列表、活动查看器、编辑器模式配置按钮组、切换界面布局按钮组

  ​

- #### 导航区（Navigator area）

  导航你整个工程、警告、报错、搜索等的地方

  ![](https://xilankong.github.io/resource/gs_navigator_area.png)

  从左到右八个按钮分别是：

  ```
  项目导航：检索项目源代码和资源文件

  符号导航：显示代码中得类、对象、函数、变量、属性等元素

  搜索导航：全工程搜索器

  事件导航：显示工作区找到的事件，如编译错误、语法错误等错误、异常提示信息

  测试导航：显示单元测试用例以及测试结果

  调试导航：显示程序在调试状态下得资源占用状态以及堆栈信息

  断点导航：显示开发过程中在工程中打的断点信息

  日志导航：显示日志信息，编译、分析、调试方面的日志
  ```

  ​

- #### 编辑区（Editor area）

  所有奇迹诞生的地方

  跳转栏：显示当前编辑器编辑的文件路径，还可以直接跳转到项目任意层次任意文件

  编辑区域：源代码编辑器、辅助编辑器、界面生成器、版本编辑器等等

  ​

- #### 工具区（Utilities area）

  包含检查器和一些库

  ![](https://xilankong.github.io/resource/gs_utilities_area.png)

  检查器：查看更改编辑器选中元素的相关特性

  库导航栏：资源库导航（文件模板、代码片段、对象、媒体文件）

  ​

- #### 调试区（Debug area）

  包括调试窗口和变量检测器

  断点执行、位置模拟、输出控制台、调试功能区。具体后面 ”Xcode项目调试“ 有详细描述。

  ​

- #### Xcode系统工具条

  常用菜单：Product 

  ```
  Run 运行app

  Test 运行单元测试

  Build 编译

  Clean 清空缓存

  Scheme 修改编译运行需要的一些 Configuration
  ```



### 2.Xcode 创建项目

1. 新建项目流程 

   Xcode File  -  New - Project

   ![](https://xilankong.github.io/resource/qs_choose_template.png)

   ​

2. 设置 Project Options

   ![](https://xilankong.github.io/resource/qs_choose_options.png)

   ```
   Product Name ：项目名称

   Team ：开发者信息

   Organization Name ：一般是反转域名方式保证唯一性

   Organization Identifier ： 一般是反转域名方式保证唯一性

   Bundle Identifier ：Organization Identifier 再加上 "." 再加上 Product Name

   Language ：开发语言 （Objective-C、Swift）

   Devices ：设备支持 （Universal、iPhone、iPad）

   Use Core Data : 是否使用数据持久化

   Include Unit Tests ：是否包含单元测试Target

   Include UI Tests : 是否包含UI测试Target
   ```

   ​

3. 项目目录结构(swift)

   ```
   demo
   --demo
   ----AppDelefate.swift
   ----ViewController.swift
   ----Main.storyboard
   ----Assets.xcassets
   ----LaunchScreen.storyboard
   ----Info.plist
   ----demo.xcdatamodeld //勾选了 Use Core Data 才有
   --demoTests //勾选了 Include Unit Tests 才有
   --demoUITests //勾选了 Include UI Tests 才有
   --Products
   --Frameworks //添加了第三方库才有
   ```

   ​

### 3.Xcode 配置分析

详细分析传送门

1. #### PROJECT 和 TARGETS

   project就是一个工程，一个project可以对应多个target (创建一个project，xcode会默认生成一个target)。

   targets之间完全没有关系。但target和project有关系，target的setting会从project settings中继承一部分。

   targets : 一个target对应一个新的product(基于同一份代码的情况下)。

   虽然代码是同一份, 但编译设置(比如编译条件), 以及包含的资源文件却可以有很大的差别. 于是即使同一份代码, 产出的product也可能大不相同。例如我们一份代码需要做出不同应用环境的 app 这个时候target的作用就出来了。  

   每个target单独会有一份 info.plist。

   Manage Schemes 可以管理变更target。

2. #### PROJECT 部分 - Info

   Deployment  Target ：运行应用需要的最低操作系统版本

   configurations ：编译环境 

   Localizations : 语言本地化

3. #### PROJECT 部分 - Build Settings

   刚接触IOS开发比较少需要更改

4. #### TARGET 部分 - Info

   Custom iOS Target Properties

   ```
   Bundle versions string, short : 是正式的版本号，跟itunes上的版本号一致，Bundle Version 可用作内部版本时使用，当Bundle Version String缺省时，Bundle Version替代Bundle Version String的功能，同时也继承他的限制(比如格式，位数等)，需与itunes上的版本号保持一致。

   Bundle identifier ：app标识，一般按反域名的方式写，默认使用创建项目的时候填写的内容。

   Main storyboard file base name : 主 storyboard 文件名字。

   Bundle version：内部版本号，不对外公开。

   Launch screen interface file base name ： 启动图 storyboard 文件名字。

   Executable file ：$(EXECUTABLE_NAME) 执行程序名，默认与 Product Name 一致。

   Bundle name：目标项目的名字(TARGETS下面的名字)，默认使用创建项目的时候填写的 Product Name。

   Bundle display name : 显示在手机屏幕上的应用名字。

   Supported interface orientations ：横竖屏支持。

   Localization native development region ： 本地开发默认地区。

   Required device capabilities ： 设备运行环境、比如有的静态库不支持某些指令集（CPU决定）。

   当我们需要使用某些系统权限和对应的提示文案也是配置在这里：

   Privacy - Photo Library Usage Description : 照片库权限弹窗说明。

   Privacy - Camera Usage Description ： 相机权限弹窗说明。
   ```

   URL Types

   ```
   iOS的App 可以注册自己的URL Scheme，URL Scheme是为方便App之间互相调用而设计的。我们可以通过系统的OpenURL来打开该App，并可以传递一些参数。

   URL Identifier是自定义的 URL Scheme 的名字，一般采用反转域名的方法保证该名字的唯一性。
   URL Scheme 用于外部唤起
   如：
   URL Identifier ：com.yang.XcodeProjectDemo
   URL Scheme ：yang

   然后我们在浏览器输入 yang:// 就会收到提示询问是否跳转到demo App了
   ```

   ​

5. #### TARGET 部分 - General

   Identity

   ```
   Display Name : 显示在手机屏幕上的应用名字。

   Bundle Identifier : App标识，一般按反域名的方式写，默认使用创建项目的时候填写的内容。

   Version ：正式的版本号

   Build : 内部版本号，不对外公开。
   ```

   Signing

   ```
   Automatically manage signing ：Xcode新增的证书自动管理，Xcode会自动选择合适证书

   Team : 对应的开发者账号 Apple ID

   Provisioning Profile : 配置文件

   Signing Certificate : 签名证书
   ```

   Deployment Info

   ```
   Deployment Target ：运行应用需要的最低操作系统版本

   Devices ：设备支持（Universal、Iphone、Ipad）

   Main Interface ：主界面对应文件。

   Devices Orientation ：横竖屏支持。

   Status Bar Style ：顶部状态栏类型。
   ```

   App Icons and Launch Images

   App 图标 和 启动图配置

   Linked Frameworks and Libraries

   需要引入的 frameworks  或者 libraries 列表

6. #### TARGET 部分 - Capabilities

   功能配置、一部分是绑定开发账号的，如 Push Notifications 推送

7. #### TARGET 部分 - Build Phases

   Target Dependencies ：Target依赖,某些Target可能依赖某个Target。

   Compile Sources : 已编译文件

   Link Binary With Libraries ：第三方类库

   Copy Bundle Resources ：资源文件

8. #### Scheme部分 - Info （Product-Scheme-Edit Scheme）

   Build Configuration ： 配置当前target使用 Debug 或者 Release 编译环境

   ​

### 4.Xcode 资源内容

- #### 图片资源

  1.图片集

  Assets.xcassets 以 Image Set (图片集)的方式存储图片。

  IOS 初始化图片 : let image = UIImage(named: "xxx")

  一个图片集包括 @1x、@2x、@3x 三个规格的图片，分别对应不同的scale（分辨率）。

  同时，也可以针对不同设备设置图片(比如同一个名字的图片集，iphone和ipad要用不一样的图片)。

  通常上面初始化方法中的 “xxx” 就是图片集的名字, 在图片集里面放两张不一样的@2x和@3x图片，在iPhone6和iPhone6 Plus加载出来的会不一样。

  2.AppIcon

  AppIcon 表示 应用图标的图片集

  3.LaunchImage

  LaunchImage表示启动页那张图的图片集，也可以通过 LaunchScreen.storyboard 配图。

  4.Slicing

  例如微信聊天气泡图片的处理，slicing可以自动拉伸图片并且不影响气泡边角。


- #### 代码片段

  常用的代码封装成代码片段

  ![](https://xilankong.github.io/resource/xcodeCode.png)

  ```
  图中从上到下的含义依次是：
  Title
  代码片段的标题

  Summary
  代码片段的描述文字

  Platform
  可以使用代码片段的平台

  Language
  可以在哪些语言中使用该代码片段

  Completion Shortcut
  代码片段的快捷方式，比如本文开头用到的dowhile，在这里，把属性设置的快捷方式设为property

  Completion Scopes
  可以在哪些文件中使用当前代码片段，比如全部位置，头文件中等，当然可以添加多个支持的位置。
  最后的一个大得空白区域是对代码片段的效果预览。
  一切设置完成以后，点击该菜单右下角的Done按钮，新建工作就结束了。

  代码片段存放地址:~/Library/Developer/Xcode/UserData/CodeSnippets
  ```

  ​    

### 5.Xcode 项目调试

- #### 单元测试

  1、写完代码以后：想要验证一下自己写的代码是否有问题。

  2、写代码之前：就是写代码之前所有的功能分模块的设计好，测试通过了再写。

  3、修复某个bug后：一般修复完某个bug，为了确保修复是成功的，可以写测试。

  4、检查方法执行时间，也可以写单元测试。

- #### 断点调试

  1.运行App、并在需要的位置设置断点

  ![](https://xilankong.github.io/resource/gs_debug_breakpoint.png)

  ​

  2.断点调试区域也是大多数IDE 都有的调试方式，开启关闭断点、进入断点，下一步、跳入、跳出

  ![](https://xilankong.github.io/resource/da_debug_bar.png)

  ​

  3.视图调试 ：上图中的Debug view graph 用于视图调试，可以看到当前控制器的每一层视图。

  ​

  4.导航条-调试导航 ：管理全局断点，还可以添加一些特殊类型断点，例如全局异常断点

  ![](https://xilankong.github.io/resource/gs_breakpoint_navigator.png)

  ​

  ​


- #### LLDB调试

  ![](https://xilankong.github.io/resource/gs_debug_area.png)

  ​

  在控制台输入命令进行调试, 详细说明 :  [LLDB调试](https://xilankong.github.io/2016年/2016/11/29/问题处理(xcode代码调试).html)

  ​

#### IOS模拟器调试

1.选择 Scheme 和  选择模拟器

![](https://xilankong.github.io/resource/moni_1.png)



2.模拟器列表，可以选择真机、模拟器，可以添加或者下载更多模拟器

![](https://xilankong.github.io/resource/moni_2.png)

​

3.模拟器菜单操作（Hardware菜单 包括 旋转、锁屏、回到主页面等等）

![](https://xilankong.github.io/resource/moni_3.png)

​

#### IOS真机调试 （模拟器毕竟是模拟器）

需要一个普通的AppleID，使用Xcode自动证书即可

如果之前使用过证书，需要在新项目使用证书，删除keychain中得你这个appleID中得证书，关开一下自动使用xcode证书，然后会自动生成对应的签名证书



## Xcode常用快捷



1.自动排版  选中 右键 structure -> re-indent  或者  Control + I

2.代码左右移动，Command + [  或者 Command + ]

3.OC .h/.m 文件快速切换  Control + Command + up、dowm

4.快速打开 Command + Shift + O

5.快速文档 Command + Shift + 0（零）

6.快速定位文件在nav中的位置 Command + Shift + J

7.快速在文件中查找指定方法 Control + 6 、然后根据名称进行搜索

8.查找文件相关联文件、调用者、头文件包含在哪些地方

![](https://xilankong.github.io/resource/xcode-111.gif)











3.Xcode 符号含义  E ：枚举 、f ：函数、 # ：#define指令 、m ：方法、c ：类

4.代码片段





xcode general 

signing  ： 

team

provisioning profile

signing certificate 



http://blog.csdn.net/phunxm/article/details/42685597/





Google搜索关键字Difference between UUID and UDID，在stackoverflow看见解释，我翻译过来，如下所述。

UUID（Universally Unique IDentifier）是基于iOS设备上面某个单个的应用程序，只要用户没有完全删除应用程序，则这个UUID在用户使用该应用程序的时候一直保持不变。如果用户删除了这个应用程序，然后再重新安装，那么这个UUID已经发生了改变。通过调用[[UIDevice currentDevice] identifierForVendor];方法可以获取UUID。UUID不好的地方就是用户删除了你开发的程序以后，基本上你就不可能获取之前的数据了。

UDID（Unique Device Identifier）是一串由40位16进制数组成的字符串，用以标识唯一的设备，现在想通过代码获取是不可能的了，如果你想看看你设备的UDID，可以通过iTunes来查看。苹果从iOS5开始就移除了通过代码访问UDID的权限，所以码农啊，想知道用户设备的UDID，是不行的喽。



http://www.jianshu.com/p/2741f0124cd3

我们可以获取到UUID，然后把UUID保存到KeyChain里面。

这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。

但是刷机或重装系统后uuid还是会改变





## IOS 唤起其他APP

http://blog.csdn.net/jiang314/article/details/52268523

 UIApplication.shared.openURL(URL(string: "schemes://identifier")!)



唤起一个app  并回来  应用不存在报错情况



1、URL Scheme 是什么？
iOS有个特性就是应用将其自身”绑定”到一个自定义 URL  scheme 上，该 scheme用于从浏览器或其他应用中启动本应用。常见的分享到第三方之间的跳转都是基于Scheme的。

2、通过对比网页链接来理解iOS 上的 URL
 Schemes，应该就容易多了。

URL，我们都很清楚，http://www.apple.com就是个URL，我们也叫它链接或网址；
Schemes，表示的是一个 URL 中的一个位置——最初始的位置，即 ://之前的那段字符。比如 http://www.apple.com这个网址的Schemes是 http。
根据我们上面对URL Schemes的使用，我们可以很轻易地理解，在以本地应用为主的 iOS 上，我们可以像定位一个网页一样，用一种特殊的 URL 来定位一个应用甚至应用里某个具体的功能。而定位这个应用的，就应该这个应用的URL
 的 Schemes 部分，也就是开头儿那部分。比如短信，就是 sms:



3、项目中关键的配置： target -》info-》URL Types (或者项目plist文件中也有),表示可以被哪些带前缀Url打开,而不是可以打开以这些前缀开头的app。

URL identifier只是一个标示符，随意填写，建议写成：com.*.*反转域名的方法保证该名字的唯一性。
URL Scheme就是你用来通信的命令前缀,用来定位一个应用。



被唤起者

```
接收到唤起如何处理
在代理方法-
 (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation中判断唤起的来源source
 app,根据Url所携带的参数进行不同的操作。比如跳转到制定的页面，相关的逻辑处理等等.

- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url 
        sourceApplication:(NSString *)sourceApplication annotation:(id)annotation 
{ 
  NSLog(@"Calling Application Bundle ID: %@", sourceApplication); 
  NSLog(@"URL scheme:%@", [url scheme]); 
  NSLog(@"URL query: %@", [url query]); 

// Customer Code
  return YES; 
}
以上配置是在被唤起应用中配置的。
```



唤起者

```
一般情况下，唤起端可以直接调用appDelegate的代理方法去唤醒其他应用。

- (void)awakeOtherApp
{ 
  NSString *customURL = @"otherApp://"; 

  if ([[UIApplication sharedApplication] 
    canOpenURL:[NSURL URLWithString:customURL]]) 
  { 
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]]; 
  } 
  else 
  { 
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"URL error" 
                          message:[NSString stringWithFormat: 
                            @"No custom URL defined for %@", customURL] 
                          delegate:self cancelButtonTitle:@"Ok" 
                          otherButtonTitles:nil]; 
    [alert show]; 
  } 
}

这里需要注意一下在iOS9以后，唤起端需要配置一下
LSApplicationQueriesSchemes.iOS9之后需要，iOS9之后提高了app的安全性，需要给出一个类似白名单的东西，在白名单里面的才能打开app。不然报错： 

-canOpenURL: failed for URL: "OpenAppTest://mark?id=007" - error: "This app is not allowed to query for scheme OpenAppTest"

```



注意事项
通过上面的方法可以唤醒其他的应用，简单总结下一些注意事项。

URL Scheme 其实就是一个app应用的唯一标志。通过它来确定打开那个应用。
一定要分清哪些配置在哪方配置，被唤醒与唤醒。
iOS9之后需要在唤起端加入LSApplicationQueriesSchemes千万不能忘。

LSApplicationQueriesSchemes 类型是数组，里面放置的是string类型的字符串 配的是目标工程的schemes



还有一个问题还没解决，如何再次回到唤醒应用的界面。这个需要参考下官方的XCallbackURL。听说有些复杂，有空再看看。

IOS 唤醒另一个APP（app之间互相通信）   
实现一个app怎么唤醒另一个app，以及让两个app之间互相通信。。。
测试工程操作如下

1.新建一个app1，在Info.plist文件的信息属性列表里新建一组，类型是URL types    设置如下

这里最关键的部分在于URL Schemes数组里的Item 0，后面的填写的字符串就是你用来通信的命令前缀“achao”，URL identifier只是一个标示符，随意填写
然后再AppDelegate里处理重载下面的回调方法
-(BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url
{

```
if ([[url scheme] isEqualToString:@"achao"])
{
    NSLog(@"%@",url);
}
return YES;
```

}
可以看见[url scheme]这个命令是为了拿到url的scheme，就是命令前缀“achao”

2.新建app2，这个app什么都不用操作，只需要去唤醒app1即可，于是我们在viewDidLoad里写上这一句
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"achao://hello"]];
"achao"就是app1里的url scheme，我叫它命令前缀（我怀疑apple的应用程序装上过后有个像通知中心一样的应用程序来统一管理，而每个应用程序的url scheme都会在那里被记录，以供其他app来调用该app，至于url scheme属于哪个应用程序，当然是和app的Bundle identifier相关的），格式采用“前缀://..."

3.我们关闭app1，app2，然后再启动app2，发现app2启动过后唤醒了app1，并且成功跳转；我们再关闭app1，app2，然后我们打开app1进行监测，发现app1被启动后，进入了

这就实现了两个app之间的唤醒和通信

4.当然这时候你可能才想到，那不是很多应用程序都会被其他垃圾程序调用了，查找资料过后，原来还有后续
我们重载这个方法
-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
{

```
if ([sourceApplication isEqualToString:@"AC.achao.com"])
{
    NSLog(@"%@", sourceApplication);    //来源于哪个app（Bundle identifier）
    NSLog(@"scheme:%@", [url scheme]);  //url scheme
    NSLog(@"query: %@", [url query]);   //查询串  用“?...”格式访问
    return YES;
}
else 
    return NO;
```

}
这就满足我们的需求了，我们可以通过sourceApplication来判断来自哪个app以决定要不要唤醒自己的app，也可以通过[url query]来获得查询串，这个时候我们需要更改app2的访问方式才能获得这个参数
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"achao://hello?name=achao-AC"]];
我们也可以直接在safari离输入"achao://hello?name=achao-AC"来访问我们的app1，这个时候sourceApplication就是@"com.apple.mobilesafari"

总结：类似下面的方法
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"http://www.baidu.com"]];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"sms://158********"]];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://158********"]];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"mailto://362****@qq.com"]];
我们用过很多，估计也是程序内部设置了类似的url scheme来供其他应用程序操作的







IOS 常用宏



```
//字符串是否为空
#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] < 1 ? YES : NO )
//数组是否为空
#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)
//字典是否为空
#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)
//是否是空对象
#define kObjectIsEmpty(_object) (_object == nil \
|| [_object isKindOfClass:[NSNull class]] \
|| ([_object respondsToSelector:@selector(length)] && [(NSData *)_object length] == 0) \
|| ([_object respondsToSelector:@selector(count)] && [(NSArray *)_object count] == 0))
 
//获取屏幕宽度与高度
#define kScreenWidth \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.width)
#define kScreenHeight \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.height)
#define kScreenSize \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale) : [UIScreen mainScreen].bounds.size)
 
//一些缩写
#define kApplication        [UIApplication sharedApplication]
#define kKeyWindow          [UIApplication sharedApplication].keyWindow
#define kAppDelegate        [UIApplication sharedApplication].delegate
#define kUserDefaults       [NSUserDefaults standardUserDefaults]
#define kNotificationCenter [NSNotificationCenter defaultCenter]
 
//APP版本号
#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]
//系统版本号
#define kSystemVersion [[UIDevice currentDevice] systemVersion]
//获取当前语言
#define kCurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])
//判断是否为iPhone
#define kISiPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
//判断是否为iPad
#define kISiPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
 
//获取沙盒Document路径
#define kDocumentPath [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
//获取沙盒temp路径
#define kTempPath NSTemporaryDirectory()
//获取沙盒Cache路径
#define kCachePath [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]
 
//判断是真机还是模拟器
#if TARGET_OS_IPHONE
//真机
#endif
 
#if TARGET_IPHONE_SIMULATOR
//模拟器
#endif
 
//开发的时候打印，但是发布的时候不打印的NSLog
#ifdef DEBUG
#define NSLog(...) NSLog(@"%s 第%d行 \n %@\n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])
#else
#define NSLog(...)
#endif
 
//颜色
#define kRGBColor(r, g, b)     [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]
#define kRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]
#define kRandomColor  KRGBColor(arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0)
 
#define kColorWithHex(rgbValue) \
[UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16)) / 255.0 \
green:((float)((rgbValue & 0xFF00) >> 8)) / 255.0 \
blue:((float)(rgbValue & 0xFF)) / 255.0 alpha:1.0]
 
//弱引用/强引用
#define kWeakSelf(type)   __weak typeof(type) weak##type = type;
#define kStrongSelf(type) __strong typeof(type) type = weak##type;
 
//由角度转换弧度
#define kDegreesToRadian(x)      (M_PI * (x) / 180.0)
//由弧度转换角度
#define kRadianToDegrees(radian) (radian * 180.0) / (M_PI)
 
//获取一段时间间隔
#define kStartTime CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();
#define kEndTime   NSLog(@"Time: %f", CFAbsoluteTimeGetCurrent() - start)
```

iphone 的 屏幕宽度 、像素比、scale

|  设备  |    尺寸    |  逻辑分辨率  |   设备分辨率   | scale |
| :--: | :------: | :-----: | :-------: | :---: |
|  4S  | 3.5 INCH | 320*480 |  640*960  |   2   |
|  5S  |  4 INCH  | 320*568 | 640*1136  |   2   |
|  6   | 4.7 INCH | 375*667 | 750*1334  |   2   |
|  6+  | 5.5 INCH | 414*736 | 1080*1920 |   3   |
|  7   | 4.7 INCH | 375*667 | 750*1334  |   2   |
|  7+  | 5.5 INCH | 414*736 | 1080*1920 |   3   |

PPI = （（根号 （宽平方 + 高平方））/尺寸）





高效的使用xcode



xcode中得其他调试工具简析

