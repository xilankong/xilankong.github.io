---
layout: post
category: 2016年
title : "Xcode使用说明书"
---

> ​	作为iOS开发，我绝大部分时间都在与Xcode打交道，把自己遇到的或别人遇到的各种坑，各种开发小知识在这里做一个整理。更好、更高效的使用Xcode才能更快速的进行开发工作。



## Xcode配置文件分析

1、TARGETS , PROJECT 区别

1.project就是一个项目，或者说工程，一个project可以对应多个target(你看看上面的图)

2.targets之间完全没有关系。但target和project有关系，target的setting会从project settings中继承一部分 (Build Settings)

3.Target指定了哪些内容?

Build Phases

Target Dependencies Target依赖,某些Target可能依赖某个Target输出的值,这里设置依赖
Copy Bundle Resources 是指生成的product的.app内将包含哪些资源文件
Compile Sources 是指将有哪些源代码被编译
Link Binary With Libraries 是指编译过程中会引用哪些库文件

Info

这个Info.plist文件内定义了一个iPhone项目的很多关键性内容, 比如程序名称, 最终生成product的全局唯一id等等.每一个Target都能设置不同的



创建一个target

Duplicate （command +D）





http://www.jianshu.com/p/0509b438e84e



## Xcode常用快捷



1.自动排版  选中 右键 structure -> re-indent  或者  Control + I

2.代码左右移动，Command + [  或者 Command + ]

3.Xcode 符号含义  E ：枚举 、f ：函数、 # ：#define指令 、m ：方法、c ：类

4.代码片段





xcode general 

signing  ： 

team

provisioning profile

signing certificate 



http://blog.csdn.net/phunxm/article/details/42685597/





Google搜索关键字Difference between UUID and UDID，在stackoverflow看见解释，我翻译过来，如下所述。

UUID（Universally Unique IDentifier）是基于iOS设备上面某个单个的应用程序，只要用户没有完全删除应用程序，则这个UUID在用户使用该应用程序的时候一直保持不变。如果用户删除了这个应用程序，然后再重新安装，那么这个UUID已经发生了改变。通过调用[[UIDevice currentDevice] identifierForVendor];方法可以获取UUID。UUID不好的地方就是用户删除了你开发的程序以后，基本上你就不可能获取之前的数据了。

UDID（Unique Device Identifier）是一串由40位16进制数组成的字符串，用以标识唯一的设备，现在想通过代码获取是不可能的了，如果你想看看你设备的UDID，可以通过iTunes来查看。苹果从iOS5开始就移除了通过代码访问UDID的权限，所以码农啊，想知道用户设备的UDID，是不行的喽。



http://www.jianshu.com/p/2741f0124cd3

我们可以获取到UUID，然后把UUID保存到KeyChain里面。

这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。

但是刷机或重装系统后uuid还是会改变





## IOS 唤起其他APP

http://blog.csdn.net/jiang314/article/details/52268523

 UIApplication.shared.openURL(URL(string: "schemes://identifier")!)



唤起一个app  并回来  应用不存在报错情况



1、URL Scheme 是什么？
iOS有个特性就是应用将其自身”绑定”到一个自定义 URL  scheme 上，该 scheme用于从浏览器或其他应用中启动本应用。常见的分享到第三方之间的跳转都是基于Scheme的。

2、通过对比网页链接来理解iOS 上的 URL
 Schemes，应该就容易多了。

URL，我们都很清楚，http://www.apple.com就是个URL，我们也叫它链接或网址；
Schemes，表示的是一个 URL 中的一个位置——最初始的位置，即 ://之前的那段字符。比如 http://www.apple.com这个网址的Schemes是 http。
根据我们上面对URL Schemes的使用，我们可以很轻易地理解，在以本地应用为主的 iOS 上，我们可以像定位一个网页一样，用一种特殊的 URL 来定位一个应用甚至应用里某个具体的功能。而定位这个应用的，就应该这个应用的URL
 的 Schemes 部分，也就是开头儿那部分。比如短信，就是 sms:



3、项目中关键的配置： target -》info-》URL Types (或者项目plist文件中也有),表示可以被哪些带前缀Url打开,而不是可以打开以这些前缀开头的app。

URL identifier只是一个标示符，随意填写，建议写成：com.*.*反转域名的方法保证该名字的唯一性。
URL Scheme就是你用来通信的命令前缀,用来定位一个应用。



被唤起者

```
接收到唤起如何处理
在代理方法-
 (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation中判断唤起的来源source
 app,根据Url所携带的参数进行不同的操作。比如跳转到制定的页面，相关的逻辑处理等等.

- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url 
        sourceApplication:(NSString *)sourceApplication annotation:(id)annotation 
{ 
  NSLog(@"Calling Application Bundle ID: %@", sourceApplication); 
  NSLog(@"URL scheme:%@", [url scheme]); 
  NSLog(@"URL query: %@", [url query]); 

// Customer Code
  return YES; 
}
以上配置是在被唤起应用中配置的。
```



唤起者

```
一般情况下，唤起端可以直接调用appDelegate的代理方法去唤醒其他应用。

- (void)awakeOtherApp
{ 
  NSString *customURL = @"otherApp://"; 

  if ([[UIApplication sharedApplication] 
    canOpenURL:[NSURL URLWithString:customURL]]) 
  { 
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]]; 
  } 
  else 
  { 
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"URL error" 
                          message:[NSString stringWithFormat: 
                            @"No custom URL defined for %@", customURL] 
                          delegate:self cancelButtonTitle:@"Ok" 
                          otherButtonTitles:nil]; 
    [alert show]; 
  } 
}

这里需要注意一下在iOS9以后，唤起端需要配置一下
LSApplicationQueriesSchemes.iOS9之后需要，iOS9之后提高了app的安全性，需要给出一个类似白名单的东西，在白名单里面的才能打开app。不然报错： 

-canOpenURL: failed for URL: "OpenAppTest://mark?id=007" - error: "This app is not allowed to query for scheme OpenAppTest"

```



注意事项
通过上面的方法可以唤醒其他的应用，简单总结下一些注意事项。

URL Scheme 其实就是一个app应用的唯一标志。通过它来确定打开那个应用。
一定要分清哪些配置在哪方配置，被唤醒与唤醒。
iOS9之后需要在唤起端加入LSApplicationQueriesSchemes千万不能忘。

LSApplicationQueriesSchemes 类型是数组，里面放置的是string类型的字符串 配的是目标工程的schemes



还有一个问题还没解决，如何再次回到唤醒应用的界面。这个需要参考下官方的XCallbackURL。听说有些复杂，有空再看看。

IOS 唤醒另一个APP（app之间互相通信）   
实现一个app怎么唤醒另一个app，以及让两个app之间互相通信。。。
测试工程操作如下

1.新建一个app1，在Info.plist文件的信息属性列表里新建一组，类型是URL types    设置如下

这里最关键的部分在于URL Schemes数组里的Item 0，后面的填写的字符串就是你用来通信的命令前缀“achao”，URL identifier只是一个标示符，随意填写
然后再AppDelegate里处理重载下面的回调方法
-(BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url
{

```
if ([[url scheme] isEqualToString:@"achao"])
{
    NSLog(@"%@",url);
}
return YES;
```

}
可以看见[url scheme]这个命令是为了拿到url的scheme，就是命令前缀“achao”

2.新建app2，这个app什么都不用操作，只需要去唤醒app1即可，于是我们在viewDidLoad里写上这一句
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"achao://hello"]];
"achao"就是app1里的url scheme，我叫它命令前缀（我怀疑apple的应用程序装上过后有个像通知中心一样的应用程序来统一管理，而每个应用程序的url scheme都会在那里被记录，以供其他app来调用该app，至于url scheme属于哪个应用程序，当然是和app的Bundle identifier相关的），格式采用“前缀://..."

3.我们关闭app1，app2，然后再启动app2，发现app2启动过后唤醒了app1，并且成功跳转；我们再关闭app1，app2，然后我们打开app1进行监测，发现app1被启动后，进入了

这就实现了两个app之间的唤醒和通信

4.当然这时候你可能才想到，那不是很多应用程序都会被其他垃圾程序调用了，查找资料过后，原来还有后续
我们重载这个方法
-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
{

```
if ([sourceApplication isEqualToString:@"AC.achao.com"])
{
    NSLog(@"%@", sourceApplication);    //来源于哪个app（Bundle identifier）
    NSLog(@"scheme:%@", [url scheme]);  //url scheme
    NSLog(@"query: %@", [url query]);   //查询串  用“?...”格式访问
    return YES;
}
else 
    return NO;
```

}
这就满足我们的需求了，我们可以通过sourceApplication来判断来自哪个app以决定要不要唤醒自己的app，也可以通过[url query]来获得查询串，这个时候我们需要更改app2的访问方式才能获得这个参数
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"achao://hello?name=achao-AC"]];
我们也可以直接在safari离输入"achao://hello?name=achao-AC"来访问我们的app1，这个时候sourceApplication就是@"com.apple.mobilesafari"

总结：类似下面的方法
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"http://www.baidu.com"]];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"sms://158********"]];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://158********"]];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"mailto://362****@qq.com"]];
我们用过很多，估计也是程序内部设置了类似的url scheme来供其他应用程序操作的







IOS 常用宏



```
//字符串是否为空
#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] < 1 ? YES : NO )
//数组是否为空
#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)
//字典是否为空
#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)
//是否是空对象
#define kObjectIsEmpty(_object) (_object == nil \
|| [_object isKindOfClass:[NSNull class]] \
|| ([_object respondsToSelector:@selector(length)] && [(NSData *)_object length] == 0) \
|| ([_object respondsToSelector:@selector(count)] && [(NSArray *)_object count] == 0))
 
//获取屏幕宽度与高度
#define kScreenWidth \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.width)
#define kScreenHeight \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.height)
#define kScreenSize \
([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale) : [UIScreen mainScreen].bounds.size)
 
//一些缩写
#define kApplication        [UIApplication sharedApplication]
#define kKeyWindow          [UIApplication sharedApplication].keyWindow
#define kAppDelegate        [UIApplication sharedApplication].delegate
#define kUserDefaults       [NSUserDefaults standardUserDefaults]
#define kNotificationCenter [NSNotificationCenter defaultCenter]
 
//APP版本号
#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]
//系统版本号
#define kSystemVersion [[UIDevice currentDevice] systemVersion]
//获取当前语言
#define kCurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])
//判断是否为iPhone
#define kISiPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
//判断是否为iPad
#define kISiPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
 
//获取沙盒Document路径
#define kDocumentPath [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]
//获取沙盒temp路径
#define kTempPath NSTemporaryDirectory()
//获取沙盒Cache路径
#define kCachePath [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]
 
//判断是真机还是模拟器
#if TARGET_OS_IPHONE
//真机
#endif
 
#if TARGET_IPHONE_SIMULATOR
//模拟器
#endif
 
//开发的时候打印，但是发布的时候不打印的NSLog
#ifdef DEBUG
#define NSLog(...) NSLog(@"%s 第%d行 \n %@\n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])
#else
#define NSLog(...)
#endif
 
//颜色
#define kRGBColor(r, g, b)     [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]
#define kRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]
#define kRandomColor  KRGBColor(arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0)
 
#define kColorWithHex(rgbValue) \
[UIColor colorWithRed:((float)((rgbValue & 0xFF0000) >> 16)) / 255.0 \
green:((float)((rgbValue & 0xFF00) >> 8)) / 255.0 \
blue:((float)(rgbValue & 0xFF)) / 255.0 alpha:1.0]
 
//弱引用/强引用
#define kWeakSelf(type)   __weak typeof(type) weak##type = type;
#define kStrongSelf(type) __strong typeof(type) type = weak##type;
 
//由角度转换弧度
#define kDegreesToRadian(x)      (M_PI * (x) / 180.0)
//由弧度转换角度
#define kRadianToDegrees(radian) (radian * 180.0) / (M_PI)
 
//获取一段时间间隔
#define kStartTime CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();
#define kEndTime   NSLog(@"Time: %f", CFAbsoluteTimeGetCurrent() - start)
```

iphone 的 屏幕宽度 、像素比、scale

|  设备  |    尺寸    |  逻辑分辨率  |   设备分辨率   | scale |
| :--: | :------: | :-----: | :-------: | :---: |
|  4S  | 3.5 INCH | 320*480 |  640*960  |   2   |
|  5S  |  4 INCH  | 320*568 | 640*1136  |   2   |
|  6   | 4.7 INCH | 375*667 | 750*1334  |   2   |
|  6+  | 5.5 INCH | 414*736 | 1080*1920 |   3   |
|  7   | 4.7 INCH | 375*667 | 750*1334  |   2   |
|  7+  | 5.5 INCH | 414*736 | 1080*1920 |   3   |

PPI = （（根号 （宽平方 + 高平方））/尺寸）





高效的使用xcode



xcode中得其他调试工具简析

