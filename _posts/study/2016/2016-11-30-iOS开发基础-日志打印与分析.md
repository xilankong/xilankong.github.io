---
layout: post
category: 2016年
title : "iOS开发基础-日志打印与分析"
---



> 在iOS开发中经常需要靠记录日志来调试应用程序、解决崩溃问题等，整理常用的日志输出和崩溃日志分析。



## 日志打印

开发过程中需要打印的东西，日志，请求





CocoaLumberjack









## 崩溃日志获取

iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。崩溃日志上有很多有用的信息，包括应用是什么情况下闪退的。通常，上面有每个正在执行线程的完整堆栈跟踪信息，所以你能从中了解到闪退发生时各线程都在做什么，并分辨出闪退发生在哪个线程上。

有几种方法可以从设备上获取崩溃日志：

1、iOS设备可以直接查看

```
路径：
ios 10之后：设置 -> 隐私 -> 分析 -> 数据分析
ios 10之前：设置 -> 隐私 -> 诊断与用量
```

2、链接设备到电脑 Itunes同步后，日志会保存在电脑上

```
mac路径：~/Library/Logs/CrashReporter/MobileDevice/
可以看到所有和该电脑同步过的设备的崩溃日志(.crash文件)
为什么有部分crash无法收集到？
```

3、xcode获取

```
xcode查看设备日志并导出日志  Window - Devices - 选择设备 - 点击View Device Logs -> All logs可以看到所有的崩溃日志。
```

4、iTC 获取



5、三方获取、如Bugly



## 崩溃日志产生原因

**什么情况下会产生崩溃日志?**

两种主要情况会产生崩溃日志:

**1.应用违反操作系统规则。**

**2.应用中有Bug。**

违反iOS规则包括在启动、恢复、挂起、退出时watchdog超时、用户强制退出和低内存终止。让我们详细了解一下吧。

**Watchdog 超时机制**

从iOS 4.x开始，退出应用时，应用不会立即终止，而是退到后台。但是，如果你的应用响应不够快，操作系统有可能会终止你的应用，并产生一个崩溃日志。这些事件与下列UIApplicationDelegate方法相对应:

application:didFinishLaunchingWithOptions:

applicationWillResignActive:

applicationDidEnterBackground:

applicationWillEnterForeground:

applicationDidBecomeActive:

applicationWillTerminate:

上面所有这些方法，应用只有有限的时间去完成处理。如果花费时间太长，操作系统将终止应用。

注意: 如果你没有把需要花费时间比较长的操作(如网络访问）放在后台线程上就很容易发生这种情况。关于如果避免这种情况的信息，请参考我们的另外两篇教程： Grand Central Dispatch 和 NSOperations。

**用户强制退出**

iOS 4.x开始支持多任务。如果应用阻塞界面并停止响应， 用户可以通过在主屏幕上双击Home按钮来终止应用。此时，操作应用将生成一个崩溃日志。

注意: 双击Home按钮后，你将看到运行过的所有应用。那些应用不一定是正在运行，也不一定是被挂起。

通常，用户点击Home按钮时，应用将在后台保留约10分钟，然后操作系统自动将其终止。 所以双击Home按钮显示的应用列表只是表明那是一系列过去打开过的应用。删除那些应用的图标不会产生任何崩溃日志。

**低内存终止**

子类化UIViewController时,你或许已经注意到didReceiveMemoryWarning方法。

在前台运行的应用拥有访问和使用内存的最高优化级。然而，这并不意味着该应用能使用设备的所有可用内存 ——每个应用只能使用一部分可用内存。

当内存使用达到一定程度时，操作系统将发出一个 UIApplicationDidReceiveMemoryWarningNotification 通知。同时,调用 didReceiveMemoryWarning 方法。

此时，为了让应用继续正常运行，操作系统开始终止在后台的其他应用以释放一些内存。所有后台应用被终止后，如果你的应用还需要更多内存，操作系统会将你的应用也终止掉，并产生一个崩溃日志。而在这种情况下被终止的后台应用，不会产生崩溃日志。

**注意:** 低内存日志也会自动导入，只是”Process”和”Type”属性都被标为Unknown(未知)。

另外，值得一提的是在极短时间内分配一大块内存将给系统内存带来巨大负担。这样，也会产生内存警告的通知。

**应用中有Bug**

如你所想，大多数闪退都是由于应用中有Bug，因此大多数崩溃日志的产生都是因为应用中的Bug。Bug的种类的有很多。 

## 崩溃日志分析

### 崩溃日志的实例

下面是一份测试过程产生的崩溃日志

```
//进程信息
Incident Identifier: 3C3F8BF8-3099-4E82-92E1-8690212E8FF9
CrashReporter Key:   bb5f9839ae661ab755f25eff65fee8fd41369628
Hardware Model:      iPod5,1
Process:             demo [973]
Path:                /private/var/containers/Bundle/Application/0D3657DE-DE1E-4FF0-A0F7-C09EBC002763/demo.app/demo
Identifier:          com.yanghuang.demo
Version:             17 (1.1.9)
Code Type:           ARM (Native)
Parent Process:      launchd [1]
//基本信息
Date/Time:           2017-08-22 16:11:49.49 +0800
Launch Time:         2017-08-22 16:11:40.40 +0800
OS Version:          iOS 9.3.5 (13G36)
Report Version:      104
//异常
Exception Type:  EXC_BREAKPOINT (SIGTRAP)
Exception Codes: 0x0000000000000001, 0x00000000e7ffdefe
Triggered by Thread:  0

Filtered syslog:
None found
//线程回溯
Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libswiftCore.dylib              0x0033788c 0x1ac000 + 1620108
1   ...wiftSwiftOnoneSupport.dylib  0x009b4830 0x9ac000 + 34864
2   demo                            0x00029288 0x24000 + 21128
3   demo                            0x00029414 0x24000 + 21524
4   UIKit                           0x25cd2754 0x25c87000 + 309076
5   UIKit                           0x25cd26e0 0x25c87000 + 308960
6   UIKit                           0x25cba6d2 0x25c87000 + 210642
7   UIKit                           0x25cd2004 0x25c87000 + 307204
8   UIKit                           0x25cd1c7e 0x25c87000 + 306302
9   UIKit                           0x25cca68e 0x25c87000 + 276110
10  UIKit                           0x25c9b124 0x25c87000 + 82212
11  UIKit                           0x25c996d2 0x25c87000 + 75474
12  CoreFoundation                  0x216e1dfe 0x21626000 + 769534
13  CoreFoundation                  0x216e19ec 0x21626000 + 768492
14  CoreFoundation                  0x216dfd5a 0x21626000 + 761178
15  CoreFoundation                  0x2162f228 0x21626000 + 37416
16  CoreFoundation                  0x2162f014 0x21626000 + 36884
17  GraphicsServices                0x22c1fac8 0x22c16000 + 39624
18  UIKit                           0x25d03188 0x25c87000 + 508296
19  demo                            0x0002ff48 0x24000 + 48968
20  libdyld.dylib                   0x212d7872 0x212d5000 + 10354

Thread 1 name:  Dispatch queue: com.apple.libdispatch-manager
Thread 1:
0   libsystem_kernel.dylib          0x213ac2f8 0x21396000 + 90872
1   libdispatch.dylib               0x212a1d60 0x2128b000 + 93536
2   libdispatch.dylib               0x212a1abe 0x2128b000 + 92862

... 省略部分内容

//二进制映像
Binary Images
0x24000 - 0x33fff demo armv7  <aa31c8c1f8cb333596dbfe056b120673> /var/containers/Bundle/Application/0D3657DE-DE1E-4FF0-A0F7-C09EBC002763/demo.app/demo
0x140000 - 0x15bfff Masonry armv7  <9615e97c54d335f7821568396c65d324> /var/containers/Bundle/Application/0D3657DE-DE1E-4FF0-A0F7-C09EBC002763/demo.app/Frameworks/Masonry.framework/Masonry
```

(1) 进程信息

第一部分是闪退进程的相关信息。

**Incident Identifier** 是崩溃报告的唯一标识符。

**CrashReporter Key** 是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到100个崩溃日志的CrashReporter Key值都是相同的，或者只有少数几个不同的CrashReport值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。

**Hardware Model** 标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是iPhone 4s。

**Process** 是应用名称。中括号里面的数字是闪退时应用的进程ID。

(2) 基本信息

这部分给出了一些基本信息，包括闪退发生的日期和时间，设备的iOS版本。如果有很多崩溃日志都来自iOS 6.0，说明问题只发生在iOS 6.0上。

(3) 异常

在这部分，你可以看到闪退发生时抛出的异常类型。还能看到异常编码和抛出异常的线程。根据崩溃报告类型的不同，在这部分你还能看到一些另外的信息。

**Exception Type** 异常类型，可以根据一些常见的异常类型判断问题

**Exception Code** 异常编码，可以根据一些常见的异常编码判断问题

(4) 线程回溯

这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。看下面这行日志:

```
2   demo     0x00029288 0x24000 + 21128
```

 它包括四列:

帧编号—— 此处是2。

二进制库的名称 ——此处是 demo.

调用方法的地址 ——此处是 0x00029288.

第四列分为两个子列，一个基本地址和一个偏移量。此处是0×0x24000 + 21128, 第一个数字指向文件，第二个数字指向文件中的代码行。

(5) 二进制映像

这部分列出了闪退时已经加载的二进制文件。



### 符号化Symbolication

第一次看到崩溃日志上的回溯时，你或许会觉得它没什么意义。我们习惯使用方法名和行数，而非像这样的神秘位置:

```
2   demo     0x00029288 0x24000 + 21128
```

将这些十六进制地址转化成方法名称和行数的过程称之为符号化。

从Xcode的Organizer窗口获取崩溃日志后过几秒钟，崩溃日志将被自动符号化。上面那行被符号化后的版本如下 :

```
2   demo     0x00029288 ViewController.crashAction(Any) -> () (ViewController.swift:36)
```

Xcode符号化崩溃日志时，需要访问与App Store上对应的应用二进制文件以及生成二进制文件时产生的 .dSYM 文件。必需完全匹配才行。否则，日志将无法被完全符号化。 

所以，保留每个分发给用户的编译版本非常重要。提交应用前进行归档时，Xcode将保存应用的二进制文件。可以在Xcode Organizer的Archives标签栏下找到所有已归档的应用文件。

在发现崩溃日志时，如果有相匹配的.dSYM文件和应用二进制文件，Xcode会自动对崩溃日志进行符号化。如果你换到别的电脑或创建新的账户，务必将所有二进制文件移动到正确的位置，使Xcode能找到它们。

**注意:** 你必需同时保留应用二进制文件和.dSYM文件才能将崩溃日志完整符号化。每次提交到iTunes Connect的构建都必需归档。 .dSYM文件和二进制文件是特定绑定于每一次构建和后续构建的，即使来自相同的源代码文件，每一次构建也与其他构建不同，不能相互替换。如果你使用Build 和 Archive 命令,这些文件会自动放在适当位置。 如果不是使用Build 和 Archive命令，放在Spotlight能够搜索到的位置（比如Home目录）即可。

```
xcode debug方式打包默认没有DSYM文件，只需要修改对应的build options即可

build settings -> build options
把debug 项改成 DWARF with dSYM File 即可
```



#### 如何通过.crash文件反编译得到明文的crash文件

需要文件：

1、demo.app

2、demo.app.dSYM

3、demo.crash (已获得)

4、symbolicatecrash

##### 步骤如下:

1、首先我们找到Archives目录(/Users/用户名/Library/Developer/Xcode/Archives/2017-08-22/demo)

2、找到对应app目录、对应的Archives文件、显示包内容打开。在dSYMs文件夹中找到demo.app.dSYM 
在Products->Applications文件夹中找到 demo.app

3、找到symbolicatecrash

```
find /Applications/Xcode.app -name symbolicatecrash -type f
//终端输入上面命令、得到一个路径，这个路径就是symbolicatecrash的路径
拷贝到和上面文件同一目录
```

3: 在终端中输入以下命令

```
./symbolicatecrash -v demo.crash demo.app.dSYM

如果出现Error: "DEVELOPER_DIR" is not defined 再执行下面一句后再次执行

export DEVELOPER_DIR="/Applications/XCode.app/Contents/Developer"
```

然后用控制台打开你的demo.crash文件, 你就会看到编译后的crash文件,  同Xcode看到的崩溃日志一致。通过查看崩溃日志，可以轻易的找到崩溃原因并修正。

```
Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libswiftCore.dylib            	0x0033788c 0x1ac000 + 1620108
1   ...wiftSwiftOnoneSupport.dylib	0x009b4830 0x9ac000 + 34864
2   demo                          	0x00029288 ViewController.crashAction(Any) -> () (ViewController.swift:36)
3   demo                          	0x00029414 @objc ViewController.crashAction(Any) -> () (ViewController.swift:0)
4   UIKit                         	0x25cd2754 -[UIApplication sendAction:to:from:forEvent:] + 80
5   UIKit                         	0x25cd26e0 -[UIControl sendAction:to:forEvent:] + 64
6   UIKit                         	0x25cba6d2 -[UIControl _sendActionsForEvents:withEvent:] + 466
7   UIKit                         	0x25cd2004 -[UIControl touchesEnded:withEvent:] + 604
8   UIKit                         	0x25cd1c7e -[UIWindow _sendTouchesForEvent:] + 646
9   UIKit                         	0x25cca68e -[UIWindow sendEvent:] + 642
10  UIKit                         	0x25c9b124 -[UIApplication sendEvent:] + 204
11  UIKit                         	0x25c996d2 _UIApplicationHandleEventQueue + 5010
12  CoreFoundation                	0x216e1dfe __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 14
13  CoreFoundation                	0x216e19ec __CFRunLoopDoSources0 + 452
14  CoreFoundation                	0x216dfd5a __CFRunLoopRun + 794
15  CoreFoundation                	0x2162f228 CFRunLoopRunSpecific + 520
16  CoreFoundation                	0x2162f014 CFRunLoopRunInMode + 108
17  GraphicsServices              	0x22c1fac8 GSEventRunModal + 160
18  UIKit                         	0x25d03188 UIApplicationMain + 144
19  demo                          	0x0002ff48 main (AppDelegate.swift:13)
20  libdyld.dylib                 	0x212d7872 start + 2
```



### 低内存闪退

因为低内存崩溃日志与普通崩溃日志略有不同。

iOS设备检测到低内存时，虚拟内存系统发出通知请求应用释放内存。这些通知发送到所有正在运行的应用和进程，试图收回一些内存。

如果内存使用依然居高不下，系统将会终止后台线程以缓解内存压力。如果可用内存足够，应用将能够继续运行而不会产生崩溃报告。否则，应用将被iOS终止，并产生低内存崩溃报告。

低内存崩溃日志上没有应用线程的堆栈回溯。相反，上面显示的是以内存页数为单位的各进程内存使用量。

被iOS因释放内存页终止的进程名称后面你会看到jettisoned 字样。如果看到它出现在你的应用名称后面，说明你的应用因使用太多内存而被终止了。 

低内存崩溃日志看起来像这样：

![img](http://www.cocoachina.com/cms/uploads/allimg/130725/4196_130725163754_1.png)

 

当应用发生低内存闪退时，你必需看看应用中内存使用的方式，以及是如何处理低内存警告的。你可以使用Instruments工具中使用Allocations 和 Leaks来发现内存分配问题和内存泄漏问题。如果你不知道如何利用 Instruments 检查内存问题，可以看看这个教程 。

 

还有，别忘记虚拟内存！ Instruments工具的Leaks 和 Allocations 不能跟踪显存使用情况。必需使用 VM Tracker 才能查看显存使用情况。

VM Tracker 默认是关闭的。打开Instrument,手动 选中Automatic Snapshotting 标志或者按下Snapshot Now 按钮。

本教程后面将会学习如何研究低内存崩溃日志。

 这个一个来自iOS 6的低内存崩溃日志。正如我们前面所说的，低内存崩溃日志与其他类型的崩溃日志很不一样，它们不指向特定的文件和代码行。相反，它们画出了闪退时设备上的内存使用情况的图表。

至少，头部还是跟其他崩溃日志很像的:  提供了 Incident Identifier, CrashReporter Key, Hardware Model, OS Version等信息。

接下来部分是低内存崩溃日志特有的:

Free pages 指可用内存页数。每页大小约是4KB, 上面的日志中，可用内存约为3,872 KB (或者说 3.9 MB)。

Purgeable pages 是那部分可被清除或重用的内存。在上面的日志中，是0KB。

Largest process是闪退时使用大部分内存的应用名称，在上面的日志中，正是你的应用!

Processes显示了闪退时各进程列表，还包含内存使用量。包含进程名 (第一列), 进程唯一标识符(第二名), 进程使用的内存页数(第三列)。最后一列是每个应用的状态。通常，发生闪退的应用的状态是 frontmost。 这里是 Rage Masters, 使用28591 页 (or 114.364 MB) 内存——这内存太多了!

通过，最大进程和frontmost状态的应用是相同的， 而且也是引起低内存闪退的应用进程。但是也可能看到最大进程和 frontmost状态应用不同的例子。比如，如果最大进程是SpringBoard, 忽略它 , 因为 SpringBoard 进程是显示主屏幕的应用，出现在你双击home按钮等情况，而且它是一直活动的。 

低内存发生时，iOS向活动的应用发出低内存警告并终止后台应用。如果前台应用仍然继续增长内存，iOS将终止它。

### 异常编码

通常，异常编码以一些文字开头，紧接着是一个或多个十六进制值，此数值正是说明闪退根本性质的所在。  从这些编码中，可以区分出闪退是因为程序错误、非法内存访问或者是其他原因。

下面是一些常见的异常编码:

0x8badf00d: 该编码表示应用是因为发生watchdog超时而被iOS终止的。  通常是应用花费太多时间而无法启动、终止或响应用系统事件。

0xbad22222: 该编码表示 VoIP 应用因为过于频繁重启而被终止。

0xdead10cc: 该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。

0xdeadfa11: 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面。

SIGABRT: 通常,  SIGABRT 异常是由于某个对象接收到未实现的消息引起的。 或者，用简单的话说，在某个对象上调用了不存在的方法。

 

**注意:** 在后台任务列表中关闭已挂起的应用不会产生崩溃日志。 一旦应用被挂起，它何时被终止都是合理的。所以不会产生崩溃日志。



## 程序崩溃时手动捕捉到崩溃

   当我们debug的时候, 发生崩溃后可以在控制台上看到崩溃的堆栈信息和崩溃日志。上面三种方法都是我们获取.crash文件后解析的办法, 那么如果用户不发送崩溃日志到iTunes Connect时，我们如何获取崩溃信息呢？那我们是否也可以在程序崩溃时，将崩溃信息写入本地，APP再次启动时，将崩溃信息上传到我们的服务器。这里就要用到apple的一个函数:NSSetUncaughtExceptionHandler。

```
//application didFinishLaunchingWithOptions中调用 [self catchCrashLogs];

- (void)catchCrashLogs{
    NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler);
}
void UncaughtExceptionHandler(NSException *exception){
    if (exception ==nil)return;
    NSArray *array = [exception callStackSymbols];
    NSString *reason = [exception reason];
    NSString *name  = [exception name];
    NSDictionary *dict = @{@"appException":@{@"exceptioncallStachSymbols":array,@"exceptionreason":reason,@"exceptionname":name}};
    if([SDFileToolClass writeCrashFileOnDocumentsException:dict]){
        NSLog(@"Crash logs write ok!");
    }
}
```



```
SIGSEGV：访问了无效地址，没有物理内存对应该地址，通常由于重复释放对象导致。
```

## Bugly的使用





http://www.jianshu.com/p/09b6084bcd01

[符号化](http://www.jianshu.com/p/12a2402b29c2)

[官方文档](https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION)

[参考文档](http://www.cocoachina.com/industry/20130725/6677.html)