---
layout: post
category: 2016年
title:  "iOS多线程知识整理" 
---

iOS中提供了四套多线程方案、一种一种来看。

```
Pthreads (不做介绍)
NSThread
GCD
NSOperation & NSOperationQueue
```



## 1、NSThread

> 苹果封装、面向对象的、可以直接操控线程对象，非常直观和方便。但是，它的生命周期还是需要我们手动管理。

### 创建并启动

1、先创建线程类，再启动

```
//1 创建NSThread 并启动
NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];
    
[thread start];
```

2、创建并自动启动

```
[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];
 ////// 
__weak typeof(self) weakself = self;
[NSThread detachNewThreadWithBlock:^{
  	[weakself run];
}];
```

3、使用 NSObject 的方法创建并自动启动

```
[self performSelectorInBackground:@selector(run) withObject:nil];
```



但是在Swift中没有这个方法：

> Note: The performSelector: method and related selector-invoking methods are not imported in Swift because they are inherently unsafe.



```
//共同执行的方法\两种锁
- (void)run {
//    [lock lock];
//    NSLog(@"111111");
//    NSLog(@"---%@",NSThread.currentThread);
//    [lock unlock];
    
    @synchronized (self) {
        NSLog(@"111111%@",NSThread.currentThread);
        NSLog(@"---%@",NSThread.currentThread);
    }
}

执行结果：
2017-11-09 10:55:34.196040+0800 MultithreadingDemo[96041:6103178] 111111<NSThread: 0x604000273200>{number = 5, name = (null)}
2017-11-09 10:55:34.196457+0800 MultithreadingDemo[96041:6103178] ---<NSThread: 0x604000273200>{number = 5, name = (null)}
2017-11-09 10:55:34.197956+0800 MultithreadingDemo[96041:6103177] 111111<NSThread: 0x604000273100>{number = 3, name = (null)}
2017-11-09 10:55:34.198510+0800 MultithreadingDemo[96041:6103177] ---<NSThread: 0x604000273100>{number = 3, name = (null)}
2017-11-09 10:55:34.200726+0800 MultithreadingDemo[96041:6103179] 111111<NSThread: 0x604000273140>{number = 4, name = (null)}
2017-11-09 10:55:34.201170+0800 MultithreadingDemo[96041:6103179] ---<NSThread: 0x604000273140>{number = 4, name = (null)}
```



### 其他方法

除了创建启动外，NSThread 还以很多方法，下面是一些常见的方法

```
//取消线程
- (void)cancel;

//启动线程
- (void)start;

//判断某个线程的状态的属性
@property (readonly, getter=isExecuting) BOOL executing;
@property (readonly, getter=isFinished) BOOL finished;
@property (readonly, getter=isCancelled) BOOL cancelled;

//获取当前线程信息
+ (NSThread *)currentThread;

//获取主线程信息
+ (NSThread *)mainThread;

//使当前线程暂停一段时间，或者暂停到某个时刻
+ (void)sleepForTimeInterval:(NSTimeInterval)time;
+ (void)sleepUntilDate:(NSDate *)date;
```



## 2、GCD

Grand Central Dispatch，是libdispatch的市场名称，而libdispatch是Apple的一个库，其为并发代码在iOS和OS X的多核硬件上执行提供支持。确切地说GCD是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程生命周期（创建线程、调度任务、销毁线程）问题。同时自动合理地利用更多的CPU内核（比如双核、四核）。

### GCD 优点

**易用:** GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱,而且因为基于block，它能极为简单得在不同代码作用域之间传递上下文。

**灵活:** GCD 具有在常见模式上(比如锁、单例)，用更高性能的方法优化代码，而且GCD能提供更多的控制权力以及大量的底层函数。

**性能:** GCD 能自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。

### GCD 概念

#### 1.Dispatch Object

GCD被组建成面向对象的风格。GCD对象被称为 dispatch object, 所有的 dispatch object 都是OC对象.，就如其他OC对象一样，当开启了 ARC 时,dispatch object 的retain和release都会自动执行。而如果是MRC的话，dispatch objects会使用dispatch_retain和dispatch_release这两个方法来控制引用计数。

在 iOS 6.0 dispatch_release 已被废弃。内部被改成对象释放（release）所以 arc 后都不再使用
#### 2.Serial & Concurrent

串行任务就是每次只有一个任务被执行，并发任务就是在同一时间可以有多个任务被执行。

#### 3.Synchronous & Asynchronous

Synchronous（同步函数）意思是在完成了它预定的任务后才返回，在任务执行时会阻塞当前线程。而 Asynchronous（异步函数）则是任务会完成但不会等它完成，所以异步函数不会阻塞当前线程，会继续去执行下去。

#### 4.Concurrency & Parallelism

Concurrency （并发）的意思就是同时运行多个任务。这些任务可能是以在单核 CPU 上以分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。然后为了使单核设备也能实现这一点，并发任务必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。Parallelism（并行）则是真正意思上的多任务同时运行。

#### 5.Context Switch

Context Switch即上下文切换，一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。

#### 6.Dispatch Queues

GCD dispatch queues 是一个强大的执行多任务的工具。Dispatch queue 是一个对象，它可以接受任务，并将任务以先进先出(FIFO)的顺序来执行。Dispatch queue 可以并发的或串行的执行任意一个代码块，而且并发任务会像 NSOperationQueue 那样基于系统负载来合适地并发进行，串行队列同一时间则只执行单一任务。Dispatch queues 内部使用的是线程，GCD 管理这些线程，并且使用 Dispatch queues 的时候，我们都不需要自己创建线程。Dispatch queues相对于和线程直接通信的代码优势是：使用起来特别方便，执行任务更加有效率。

#### 7.Queue Types

*    main queue  :  主队列  （主线程）


```
一般使用 main queue, 都是在该线程中操作 UI 相关的.也就是说, 在 main queue 中执行的任务会在主线程中执行.主线程只有一个, main queue 是与主线程相关的，所以 main queue 是串行队列.

//Returns the default queue that is bound to the main thread.
                                                                                                                                                                       dispatch_get_main_queue(void)
{
	return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);                                                                                   
}
```



*    global queue  :  全局队列 （有多个线程）


```
dispatch_get_global_queue(long identifier, unsigned long flags);                                                        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 
常写作 dispatch_get_global_queue(0, 0);

global queue 是并发队列.可以设置其优先级.  ？？？优先级问题
//@param identifier  优先级
- A quality of service class defined in qos_class_t or a priority defined in  
                                                                                                                                                   - dispatch_queue_priority_t.
 //@param flags  备用参数
- Reserved for future use. Passing any value other than zero may result in
- a NULL return value.
//@result  返回一个全局队列
- Returns the requested global queue or NULL if the requested global queue
- does not exist.
```



*    custom queue  : 自定义队列  （串行：单线程 ，并行：有多个线程）


```
这些队列是可以是串行的, 也可以是并行的。默认是串行的.
dispatch_queue_attr_t设置成NULL的时候默认代表串行。
串行队列可以保证任务是串行的, 保证了执行顺序.类似锁机制.
   
dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);
                                                                                           
//@param label  队列名称 尽量别重名
- A string label to attach to the queue.
- This parameter is optional and may be NULL.
//@param attr   队列类型  默认 DISPATCH_QUEUE_SERIAL
- A predefined attribute such as DISPATCH_QUEUE_SERIAL,
- DISPATCH_QUEUE_CONCURRENT, or the result of a call to
- a dispatch_queue_attr_make_with_* function.
//@result
- The newly created dispatch queue.
```



### GCD的具体使用

#### 1.添加任务到队列

GCD有两种方式来把任务添加到队列中：异步和同步。

异步方式添加任务到队列的情况：

**1.自定义串行队列**：按添加进队列的先后顺序 顺序执行（不管同步异步线程）

```
我们接着上面的run方法来写一个串行队列

第一步，写两个异步线程和一个同步线程加入队列执行：其中第一个线程执行任务之前睡眠1秒
[self run];
__weak typeof(self) weakself = self;
dispatch_queue_t queue = dispatch_queue_create("串行队列", DISPATCH_QUEUE_SERIAL);
dispatch_async(queue, ^{
    sleep(1);
    [weakself run];
});
dispatch_async(queue, ^{
    [weakself run];
});

dispatch_sync(queue, ^{
    [weakself run];
});

结果：
2017-11-09 14:00:22.642407+0800 MultithreadingDemo[97236:6195716] ---<NSThread: 0x604000069240>{number = 1, name = main}
2017-11-09 14:00:23.643340+0800 MultithreadingDemo[97236:6195829] ---<NSThread: 0x604000275300>{number = 3, name = (null)}
2017-11-09 14:00:23.643547+0800 MultithreadingDemo[97236:6195829] ---<NSThread: 0x604000275300>{number = 3, name = (null)}
2017-11-09 14:00:23.643776+0800 MultithreadingDemo[97236:6195716] ---<NSThread: 0x604000069240>{number = 1, name = main}

包括主线程在内，整个队列里面有两条线程，但是执行结果却被第一个sleep阻塞1秒。所以串行队列是一个个任务完成后再执行后面的任务

第二步，写一个异步线程包裹一个同步线程，并在同步线程中执行run
[self run];
__weak typeof(self) weakself = self;
dispatch_queue_t queue = dispatch_queue_create("串行队列", DISPATCH_QUEUE_SERIAL);
dispatch_async(queue, ^{
    [weakself run];
});
dispatch_async(queue, ^{  //1号任务
    [weakself run];
    dispatch_sync(queue, ^{  //2号任务
        [weakself run];
    });
});
结果：
2017-11-09 14:08:03.335534+0800 MultithreadingDemo[97291:6200400] ---<NSThread: 0x60000006f580>{number = 1, name = main}
2017-11-09 14:08:03.335846+0800 MultithreadingDemo[97291:6200500] ---<NSThread: 0x60000046a9c0>{number = 3, name = (null)}
2017-11-09 14:08:03.336308+0800 MultithreadingDemo[97291:6200500] ---<NSThread: 0x60000046a9c0>{number = 3, name = (null)}

崩溃在 dispatch_sync 这一行，所以我们只看到了一条主线程run的记录
分析一下：
1、我们使用了同步线程，而且是串行队列，
2、1号任务没有结束、2号任务是无法执行的
3、当任务走到同步线程开启的时候，线程会被阻塞，直到2号任务block内的任务执行完成才会释放
4、可是同步线程把任务加入queue队列之后才发现，自己要执行的这个任务前面还卡着一个1号任务
5、线程被阻塞，1号任务无法完成，1号任务没完成 2号任务就不能执行
6、造成死锁

所以改一下，只要把同步任务换个队列执行，就可以避免死锁了：
dispatch_async(queue, ^{
    [weakself run];
    dispatch_sync(dispatch_get_main_queue(), ^{
        [weakself run];
    });
});
```

**2.主队列：**顺序执行、串行队列  一般更新UI都在主线程。

```
//主队列中的任务一定会回到主线程去执行、如下方式去执行，同步任务在主线程、主队列执行，主队列是串行队列，又会出现死锁
dispatch_sync(dispatch_get_main_queue(), ^{
    [weakself run];
});
改成：
dispatch_async(dispatch_get_main_queue(), ^{
    [weakself run];
});
```

**3.并发队列：**非顺序执行，随机、同步执行并发队列一样会卡住主线程

```
如串行队列所写，在并行队列写相同代码执行结果会如何：
[self run];
__weak typeof(self) weakself = self;
dispatch_queue_t queue = dispatch_queue_create("并行队列", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    [weakself run];
});
dispatch_async(queue, ^{
    [weakself run];
    dispatch_sync(queue, ^{
        [weakself run];
    });
});

结果：
2017-11-09 14:34:15.075513+0800 MultithreadingDemo[97572:6219452] ---<NSThread: 0x60000007dbc0>{number = 1, name = main}
2017-11-09 14:34:15.075965+0800 MultithreadingDemo[97572:6219573] ---<NSThread: 0x60000046bdc0>{number = 4, name = (null)}
2017-11-09 14:34:15.075967+0800 MultithreadingDemo[97572:6219574] ---<NSThread: 0x60000046ae00>{number = 3, name = (null)}
2017-11-09 14:34:15.076703+0800 MultithreadingDemo[97572:6219573] ---<NSThread: 0x60000046bdc0>{number = 4, name = (null)}

可以看到执行结果是正常的，并未出现死锁，那是因为并行队列是可以多个任务并行执行的，正因为允许多个任务同时执行，所以执行结束时间并不是按着添加入队列的顺序来的。
```

**4.全球队列：**并行队列、异步线程常用队列



#### 2.并发执行迭代循环

在开发中，并发队列能很好地提高效率，特别是当我们需要执行一个数据庞大的循环操作时。打个比方来说吧，我们需要执行一个for循环，每一次循环操作如下：

```
for (i = 0; i < count; i++) {
   NSLog("%d",i);
}
```


GCD提供了一个简化方法叫做dispatch_apply，当我们把这个方法放到并发队列中执行时，这个函数会调用单一block多次，并平行运算，然后等待所有运算结束。

**代码示例：**

```
dispatch_queue_t queue = w(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_apply(count, queue, ^(size_t i) {
   NSLog("%d",i);
});

但是dispatch_apply函数是没有异步版本的。只能将整个dispatch_apply 置于异步中。

直接在主线程调用dispatch_apply 会阻塞主线程，如果使用了并发队列 队列任务会被放置在异步线程中执行，但是主线程依然被阻塞。
```



#### 3.挂起和恢复队列

有时候，我们不想让队列中的某些任务马上执行，这时我们可以通过挂起操作来阻止一个队列中将要执行的任务。当需要挂起队列时，使用**dispatch_suspend**方法；恢复队列时，使用**dispatch_resume**方法。调用**dispatch_suspend**会增加队列挂起的引用计数，而调用**dispatch_resume**则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。

> 执行挂起操作不会对已经开始执行的任务起作用，它仅仅只会阻止将要进行但是还未开始的任务。

```
dispatch_queue_t myQueue;

myQueue = dispatch_queue_create("队列", NULL);
//挂起队列
dispatch_suspend(myQueue);
//恢复队列
dispatch_resume(myQueue);

如下：

__weak typeof(self) weakself = self;
dispatch_queue_t queue = dispatch_queue_create("并行队列", DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    [weakself run];
});
dispatch_async(queue, ^{
    dispatch_suspend(queue);
    [weakself run];
    dispatch_sync(queue, ^{
        [weakself run];
    });
});

结果 只有两条run语句，同步线程因为队列被挂起，所以并未执行
2017-11-09 14:43:22.593056+0800 MultithreadingDemo[97644:6225319] ---<NSThread: 0x60000027e0c0>{number = 9, name = (null)}
2017-11-09 14:43:22.592831+0800 MultithreadingDemo[97644:6226170] ---<NSThread: 0x600000271a40>{number = 8, name = (null)}

```



#### 4.dispatch_after 的使用

延迟一段时间把一项任务提交到队列中执行，返回之后就不能取消

```
dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);

一般我们在做一些延时任务的时候使用的多
```



#### 5.dispatch_once 的使用

保证在APP运行期间，block中的代码只执行一次

```
static Demo *demo;
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    demo = [Demo new];
});

单例常用
```



#### 6.Dispatch Groups 的使用

**Dispatch groups**是阻塞线程直到一个或多个任务完成的一种方式。在那些需要等待任务完成才能执行某个处理的时候，你可以使用这个方法。Group会在整个组的任务都完成时通知你，这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时， Group可以用同步的或者异步的方式通知你。当group中所有的任务都完成时，GCD 提供了两种通知方式。

**dispatch_group_wait**。它会阻塞当前线程，直到队列里面所有的任务都完成或者等到某个超时发生。

代码示例：

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
// 添加队列到组中
dispatch_group_async(group, queue, ^{
// 一些异步操作 或者耗时操作
});

//如果在所有任务完成前超时了，该函数会返回一个非零值。
//你可以对此返回值做条件判断以确定是否超出等待周期；
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

NSLog(@"123"); //被阻塞,因为dispatch_group_wait  所以这一句代码只会在队列任务都完成后执行
```


**dispatch_group_notify**。它以异步的方式工作，当 Dispatch Group中没有任何任务时，它就会执行其代码，那么 completionBlock便会运行。可以用于在并行队列中待所有任务都完成之后再调起执行。

代码示例：

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();

// 添加队列到组中
dispatch_group_async(group, queue, ^{
    NSLog(@"one---%@",NSThread.currentThread);
});
dispatch_group_async(group, queue, ^{
    // 一些延时操作
    sleep(2);
    NSLog(@"two---%@",NSThread.currentThread);
});
dispatch_group_async(group, queue, ^{
    // 一些延时操作
    sleep(3);
    NSLog(@"three---%@",NSThread.currentThread);
});
dispatch_group_async(group, queue, ^{
    NSLog(@"four---%@",NSThread.currentThread);
});

dispatch_group_notify(group, queue, ^{
    NSLog(@"我会一直等到现在");
});
NSLog(@"123");

结果
2017-11-09 15:21:48.480021+0800 MultithreadingDemo[98195:6255855] 123
2017-11-09 15:21:48.480192+0800 MultithreadingDemo[98195:6255916] one---<NSThread: 0x600000466800>{number = 3, name = (null)}
2017-11-09 15:21:48.480321+0800 MultithreadingDemo[98195:6255917] four---<NSThread: 0x600000466840>{number = 4, name = (null)}
2017-11-09 15:21:50.483266+0800 MultithreadingDemo[98195:6255918] two---<NSThread: 0x604000462e80>{number = 5, name = (null)}
2017-11-09 15:21:51.483851+0800 MultithreadingDemo[98195:6255922] three---<NSThread: 0x60400027dd40>{number = 6, name = (null)}
2017-11-09 15:21:51.484084+0800 MultithreadingDemo[98195:6255922] 我会一直等到现在

对这一段代码，并行队列执行，最后一行不会阻塞，其余加入group中的任务执行完成后才会执行notify中的任务。
常用于需要等待某些异步线程执行完成后统一处理的场景，比如多个接口数据拼装模型
```



#### 7.dispatch_barrier_async 的使用

在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 

dispatch_barrier_async 函数会等待追加到并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。

注意：使用 dispatch_barrier_async，该函数只能搭配自定义并行队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。 



## 3、NSOperation

NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。

我们要做的就是：

1.将要执行的任务封装到一个NSOperation对象中

2.将此任务添加到一个NSOperationQueue对象中

#### 创建添加

NSOperation有两个子类：NSBlockOperation 和 NSInvocationOperation （或者自行自定义Operation ）

**NSBlockOperation**：（OC 代码、Swift也有）

```
+ (instancetype)blockOperationWithBlock:(void (^)(void))block;
- (void)addExecutionBlock:(void (^)(void))block;

__weak typeof(self) weakself = self;
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    [weakself run];
}];
[operation start];

结果
2017-11-09 15:53:29.765058+0800 MultithreadingDemo[98518:6280532] ---<NSThread: 0x604000073e80>{number = 1, name = main}

1、直接执行创建的operation 默认是当前线程
2、NSBlockOperation 还有一个添加执行block的方法，它会在当前线程和其他多个线程执行这些block中的任务
[operation addExecutionBlock:^{
    [weakself run];
}];

结果
2017-11-09 15:53:29.765058+0800 MultithreadingDemo[98518:6280532] ---<NSThread: 0x604000073e80>{number = 1, name = main}
2017-11-09 15:53:29.765055+0800 MultithreadingDemo[98518:6280642] ---<NSThread: 0x60400026ea40>{number = 3, name = (null)}

注意：当NSOperation开始执行后不能再添加任务

```

**NSInvocationOperation：**  (Swift 不允许使用)

```
- (nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;
- (instancetype)initWithInvocation:(NSInvocation *)inv NS_DESIGNATED_INITIALIZER;

//1.创建NSInvocationOperation对象
NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];

//2.开始执行
[operation start];

```

#### 队列

上面例子中的任务执行，不管是多线程还是单线程都必然会在当前线程执行一个任务

NSOperation的队列和GCD不同，不存在串行、并行之分，他们只有主队列和其他队列：

**主队列：**

```
NSOperationQueue *queue = [NSOperationQueue mainQueue];
```



**其他队列：**（注意：其他队列的任务会在其他线程并行执行）

```
所有的非主队列就是其他队列，也就是说不是通过 mainQueue 获取的队列都是其他队列

NSOperationQueue *queue = [[NSOperationQueue alloc]init];
__weak typeof(self) weakself = self;
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    [weakself run];
}];
[operation addExecutionBlock:^{
    [weakself run];
}];
//    [operation start];  只要加入队列，任务就会自动start
[queue addOperation:operation];
或者
[queue addOperationWithBlock:^{
    [weakself run];
}];
```

其实更多来看 NSOperation相当于一个任务组，里面可以装多个任务，然后任务组被加入队列去执行

那么问题来了：没有串行队列么？按前面说的，所有任务会在其他线程同步执行，那我希望一个个执行怎么办？

```
NSOperationQueue 有一个参数：maxConcurrentOperationCount

这个参数表示允许并发执行的任务数限制，当为1的时候其实也就是串行执行了

NSOperationQueue *queue = [[NSOperationQueue alloc]init];
__weak typeof(self) weakself = self;
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
    [weakself run];
}];
[operation addExecutionBlock:^{
    sleep(1);
    [weakself run];
}];
queue.maxConcurrentOperationCount = 1;
[queue addOperation:operation];
[queue addOperationWithBlock:^{
    [weakself run];
}];

结果

2017-11-09 16:18:23.524428+0800 MultithreadingDemo[98831:6301089] ---<NSThread: 0x600000473840>{number = 3, name = (null)}
2017-11-09 16:18:24.524800+0800 MultithreadingDemo[98831:6301087] ---<NSThread: 0x60000046d640>{number = 4, name = (null)}
2017-11-09 16:18:24.525121+0800 MultithreadingDemo[98831:6301087] ---<NSThread: 0x60000046d640>{number = 4, name = (null)}
```

#### 其他功能

依赖：NSOperation还有一个非常实用的功能，也就是添加依赖

```
NSBlockOperation *operationA = [NSBlockOperation blockOperationWithBlock:^{
    sleep(1);
    NSLog(@"拉取A接口--%@",NSThread.currentThread);
}];

NSBlockOperation *operationB = [NSBlockOperation blockOperationWithBlock:^{
    sleep(1);
    NSLog(@"通过A接口参数拉取B接口--%@",NSThread.currentThread);
}];

NSBlockOperation *operationC = [NSBlockOperation blockOperationWithBlock:^{
    sleep(1);
    NSLog(@"通过B接口参数拉取C接口--%@",NSThread.currentThread);
}];
[operationB addDependency:operationA];
[operationC addDependency:operationB];

NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperations:@[operationA, operationB, operationC] waitUntilFinished:NO];

队列允许多个任务同时执行，但因为三个任务之间的依赖，我们看一下结果：

2017-11-09 16:25:56.598192+0800 MultithreadingDemo[98972:6307395] 拉取A接口--<NSThread: 0x6040002748c0>{number = 3, name = (null)}
2017-11-09 16:25:57.599920+0800 MultithreadingDemo[98972:6307396] 通过A接口参数拉取B接口--<NSThread: 0x60000046d680>{number = 4, name = (null)}
2017-11-09 16:25:58.600665+0800 MultithreadingDemo[98972:6307395] 通过B接口参数拉取C接口--<NSThread: 0x6040002748c0>{number = 3, name = (null)}

注意：
使用依赖的时候，我们要注意一点，依赖不能产生循环依赖，不然会死锁
可以使用 removeDependency 来解除依赖关系。
不同的队列之间的任务也可以依赖
```



## 4、锁

ios中锁的使用

#### NSLock

#### @synchronized代码块

#### 条件信号量dispatch_semaphore_t



## 5、常见问题

dispatch_release 已被废弃（6.0）dispatch_release在6.0以后内部被改成对象释放（release）所以 arc后都不再使用。

app启动，系统默认创建5个线程





## 6、捕获开发中子线程更新UI的逻辑

### 1.为什么UI要在主线程更新

因为UIKit不是线程安全的。试想下面这几种情况：

两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。 

两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。 

两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。 

iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。

### 2.我的想法

View的更新操作 使用runtime 去替换 View 中实现 的方法 不变更实现。只是在中间插入 线程检查操作，发现子线程就必须打印线程调用栈并触发crash。

问题：替换哪些方法更合适?  都会涉及到哪些基础控件需要category？

### 3.例子

1.创建一个UIImage的category

```
@implementation UIImage (demo)

+(void)load
{
    Method  m1 = class_getClassMethod([UIImage class],@selector(imageNamed:));
    
    Method m2 = class_getClassMethod([UIImage class],@selector(ximageNamed:));
    
    // 开始交换方法实现
    method_exchangeImplementations(m1, m2);
}
+(UIImage *)ximageNamed:(NSString *)name
{
    NSLog(@"进入方法-开始检查线程");
    
    NSThread *thread = [NSThread currentThread];
    if (![thread isMainThread]) {
        NSLog(@" 当前线程不是主线程  %@",[NSThread callStackSymbols]);
    }
    return [UIImage ximageNamed:name];
}
@end
```

2.在一个视图内实现一段UIImage的异步赋予图片

```
UIImageView *img = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 300, 300)];
[self.view addSubview:img];
img.image = [UIImage imageNamed:@"networklosed"];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    img.image = [UIImage imageNamed:@"mncg_search_nor"];
});
NSLog(@"测试线程是否异步");
```






## 7、参考

[GCD使用三部曲之：基本用法](http://www.jianshu.com/p/d56064507fb8)