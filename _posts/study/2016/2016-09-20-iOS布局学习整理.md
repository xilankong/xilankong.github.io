---
layout: post
category: 2016年
title:  "iOS布局学习整理" 
---



XIB的使用



## 1.XIB AutoLayout

一个简单的例子  :   在XIB中 设置一个自己根据内容变化的竖向scrollview 

步骤：

1、在scrollview中添加一个contentView，edges equalTo scrollview

2、设置 contentView 的 width、height equal scrollview （高度可以不设置，但是xib会提示错误，所以一般设置一个低优先级或者remove on build）

3、在contentView里面添加需要展示的内容，保证可以根据内容推算出总高度。

比如：

添加三个label，每个label左右依赖contentView ，第一个距离依赖顶部, 最后一个依赖底部 中间各自间距 0。

这种情况下contentView高度被推算，scrollView的contentSize也会自动推算。



## 2.代码 AutoLayout

代码写约束 : 让UIView跟着内部的UILabel自适应拉伸

例如 ：

让一个UIView 居于左上角 根据文字内容自动拉伸 

设置UIView的左边和上面约束 equal 

设置右边居于右屏幕边缘 greater than  margin

设置UIView的高度 greater than 最小高度

内部UILabel 设置 edges  equal 就可以了



## 3.Masonry 使用

1.masonry 创建自动适应scrollview

使用 Masonry 设置一个自己根据内容变化的竖向scrollview 

1、在scrollview 中添加一个contentView，edges equalTo scrollview

2、设置 contentView 的 width equalTo scrollview

3、在contentView里面添加需要展示的内容并且上下各自equal ,左右 margin contentView 0

4、在添加完成最后一个后，把 contentView 的 bottom margin 更新到依赖最后一个view的 bottom

```
  1、
  [contentView makeConstraints:^(MASConstraintMaker *make) {
        make.edges.equalTo(self.scrollView);
        make.width.equalTo(self.scrollView);
        make.height.equalTo(self.scrollView).priority(900);
    }];
   2、
      [contentView makeConstraints:^(MASConstraintMaker *make) {
        make.bottom.equalTo(lastView.bottom);
    }];
```

2.masonry 常用内容

1、redView     :    make.height.equalTo(@[greenView, blueView]);   //can pass array of attributes

可以使用数组equal多个view

2、make.center.equalTo(CGPointMake(0, 50));    make.size.equalTo(CGSizeMake(200, 100));

3、make.edges.equalTo(lastView).insets(UIEdgeInsetsMake(5, 10, 15, 20));

4、make.width.and.height.lessThanOrEqualTo(self.topView);

5、make.edges.equalTo(superview).insets(paddingInsets).priorityLow(),  优先级

6、

```
  [self.longLabel makeConstraints:^(MASConstraintMaker *make) {
      make.left.equalTo(self.left).insets(kPadding);
      make.top.equalTo(self.top).insets(kPadding);
  }];
    
 - (void)layoutSubviews {
    [super layoutSubviews];
    CGFloat width = CGRectGetMinX(self.shortLabel.frame) - kPadding.left;
    width -= CGRectGetMinX(self.longLabel.frame);
    self.longLabel.preferredMaxLayoutWidth = width;
    [super layoutSubviews];
 }
```

7、

```
//判断这个是不是必须
+ (BOOL)requiresConstraintBasedLayout
{
    return YES;
}

// this is Apple's recommended place for adding/updating constraints 更新约束进入，在调用super之前进行约束修改。
- (void)updateConstraints {

    [self.growingButton updateConstraints:^(MASConstraintMaker *make) {
        make.center.equalTo(self);
        make.width.equalTo(@(self.buttonSize.width)).priorityLow();
        make.height.equalTo(@(self.buttonSize.height)).priorityLow();
        make.width.lessThanOrEqualTo(self);
        make.height.lessThanOrEqualTo(self);
    }];
    
    //according to apple super should be called at end of method
    [super updateConstraints];
}

    // tell constraints they need updating
    [self setNeedsUpdateConstraints];

    // update constraints now so we can animate the change
    [self updateConstraintsIfNeeded];
```

8、  一个按钮宽度随着参数变化的同时受限制于外边框，所以可以通过优先级来处理。

```
  make.width.equalTo(@(self.buttonSize.width)).priorityLow();
  make.height.equalTo(@(self.buttonSize.height)).priorityLow();
  make.width.lessThanOrEqualTo(self);
  make.height.lessThanOrEqualTo(self);
```

9、兼容数组调用同一个约束设定

```
    [lowerButton mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.equalTo(self).with.offset(10.0);
    }];

    [centerButton mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.equalTo(self);
    }];

    [raiseButton mas_makeConstraints:^(MASConstraintMaker *make) {
        make.right.equalTo(self).with.offset(-10);
    }];
    
    self.buttonViews = @[ raiseButton, lowerButton, centerButton ];
    
    - (void)updateConstraints {
        [self.buttonViews updateConstraints:^(MASConstraintMaker *make) {
            make.baseline.equalTo(self.mas_centerY).with.offset(self.offset);
        }];
        [super updateConstraints];
	}
```



## 4.UIView更新机制

1、UIView的setNeedsDisplay和setNeedsLayout方法

首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到  UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，
 就可以  处理子视图中的一些数据。

综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便处理数据。

layoutSubviews在以下情况下会被调用：

1、init初始化不会触发layoutSubviews。
2、addSubview会触发layoutSubviews。
3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。
4、滚动一个UIScrollView会触发layoutSubviews。
5、旋转Screen会触发父UIView上的layoutSubviews事件。
6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。
7、直接调用setLayoutSubviews。

drawRect在以下情况下会被调用：

 1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).

2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。
3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。
4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。
以上1,2推荐；而3,4不提倡

drawRect方法使用注意点：

1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。
2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法
3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕

## layoutSubviews

在UIView里面有一个方法layoutSubviews，这个方法具体作用是什么呢？

```
- (void)layoutSubviews; // override point. called by layoutIfNeeded automatically. As of iOS 6.0, when constraints-based layout is used the base implementation applies the constraints-based layout, otherwise it does nothing. 
```

## 官方文档解释

我们先来看看苹果官方文档的解释：

```
The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.

Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.

You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method. 
```

最后一段说，不要直接调用此方法。如果你想强制更新布局，你可以调用setNeedsLayout方法；如果你想立即数显你的views，你需要调用layoutIfNeeded方法。

## layoutSubviews作用

layoutSubviews是对subviews重新布局。比如，我们想更新子视图的位置的时候，可以通过调用layoutSubviews方法，既可以实现对子视图重新布局。

layoutSubviews默认是不做任何事情的，用到的时候，需要在自雷进行重写。

## layoutSubviews以下情况会被调用

苹果官方文档已经强调，不能直接调用layoutSubviews对子视图进行重新布局。那么，layoutSubviews什么情况下会被调用呢？通过百度搜索，发现以下几种情况layoutSubviews会被调用。

1. 直接调用setLayoutSubviews。（这个在上面苹果官方文档里有说明）
2. addSubview的时候。
3. 当view的frame发生改变的时候。
4. 滑动UIScrollView的时候。
5. 旋转Screen会触发父UIView上的layoutSubviews事件。
6. 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。

我简单测试了一下，上面基本都会被调用。 注意：

```
当view的fram的值为0的时候，`addSubview`也不会调用`layoutSubviews`的。
```

layoutSubviews方法在对自雷视图进行布局的时候非常方便。可以自己动手，深入理解layoutSubviews的调用机制。





## 5.UITableView 碰上自动布局

UITableViewCell 如何 在不计算的情况下自适应高度,需要测试attributeString等耗时操作的影响

    第一步  给tableView设置估值高度 不要设置rowHeight  rowHeight返回方法也不要
    self.tableView.rowHeight = UITableViewAutomaticDimension;
    self.tableView.estimatedRowHeight = 200;
    
    第二步
    
     JDGGoldDetailCell *cell = [JDGGoldDetailCell cellWithTableView:tableView];
     //MARK:自动计算行高最关键的一步  cell一定要重新布局
     [cell layoutIfNeeded];
    
    第三步
    
    cell的layoutSubViews中更新cell内容 
    - (void)layoutSubviews {
        [super layoutSubviews];
    
        [self.imgview mas_makeConstraints:^(MASConstraintMaker *make) {
            make.centerY.mas_equalTo(self.contentView.mas_centerY);
            make.left.mas_equalTo(self.contentView.mas_left).offset(34);
            make.width.height.mas_equalTo(60);
        }];
        
        [self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.contentView.mas_top).offset(15);
            make.left.mas_equalTo(self.imgview.mas_right).offset(24);
            make.right.mas_equalTo(self.contentView.mas_right).offset(-20);
        }];
        
        [self.detailLabel mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.titleLabel.mas_bottom).offset(13);
            make.left.mas_equalTo(self.imgview.mas_right).offset(24);
            make.right.mas_equalTo(self.contentView.mas_right).offset(-25);
            
            //MARK:自动计算行高第四步---根据大家反映,更新后的代码
            make.bottom.mas_equalTo(self.contentView.mas_bottom).offset(-10);
        }];
        
    }



## 6.自动布局中的约束优先级

UIView 有两个类别的content优先级

Content Hugging Priority 确定view有多大的优先级阻止自己变大。 默认 250 （例如保证UIButton不会因为屏幕边距变大而拉伸按钮）

Content Compression Resistance Priority 确定有多大的优先级阻止自己变小。 默认 750（例如保证UILabel不会被挤压导致显示不全）优先级越大 越不会被压缩

说这个之前先了解一些信息：

这两个属性对有intrinsic content size的控件（例如button，label）非常重要。通俗的讲，具有intrinsic content size的控件自己知道（可以计算）自己的大小，例如一个label，当你设置text，font之后，其大小是可以计算到的。

```
UIView中关于Content Hugging 和 Content Compression Resistance的方法

- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

```


默认优先级情况下从左到右，从上到下优先。 默认情况下两边的label的Content Hugging和Content Compression优先级都是一样的。

**Q1 : 当一个View 高度需要根据内容来扩张，那么内部label 和 view的优先级怎么判断 有什么不同吗？**

**A1 : 没有, 根据优先级来。**

**测试出现的情况：**

1.当xib的View中加了两个默认的Label 并自动计算高度适配，再通过代码在底下继续加上Label 的时候 label需要更改收缩优先级来保证他完整显示。(依然未解)

2.但是直接在xib中加入多个label，并设定好约束，label会正常扩张，父view也会正常扩张。

3.在 2 的基础上 再在底下通过代码添加的label 设定好masonry约束 同样能正常显示，正常扩张

4.一个View中 由上到下分别是 label、label、view（里面有一个label） 的布局，自动布局也可以正常扩张

5.hidden 并不会影响约束



当一个view中有一个图片和一个label，我希望label来决定view的宽度，这个时候就需要把图片的抗压缩优先级设置到小于label的抗扩张优先级

## warning !

1、IOS 自动化布局 masonry autolayout  等 尽量别混用

2、多看看masonry 官方 demo

3、masonry 的约束优先级的作用  和content优先级有什么区别