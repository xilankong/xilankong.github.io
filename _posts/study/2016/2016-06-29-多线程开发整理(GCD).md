---
layout: post
category: 2016年
title:  "iOS多线程知识整理" 
---

> 多线程开发



## 什么是多线程





## GCD

Grand Central Dispatch，是libdispatch的市场名称，而libdispatch是Apple的一个库，其为并发代码在iOS和OS X的多核硬件上执行提供支持。确切地说GCD是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程被创建的问题。

### GCD 优点

**易用:** GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱,而且因为基于block，它能极为简单得在不同代码作用域之间传递上下文。

**灵活:** GCD 具有在常见模式上(比如锁、单例)，用更高性能的方法优化代码，而且GCD能提供更多的控制权力以及大量的底层函数。

**性能:** GCD 能自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。

### GCD 概念

#### 1.Dispatch Object

GCD被组建成面向对象的风格。GCD对象被称为 dispatch object, 所有的 dispatch object 都是OC对象.，就如其他OC对象一样，当开启了 ARC 时,dispatch object 的retain和release都会自动执行。而如果是MRC的话，dispatch objects会使用dispatch_retain和dispatch_release这两个方法来控制引用计数。

在 iOS 6.0 dispatch_release 已被废弃。内部被改成对象释放（release）所以 arc 后都不再使用
#### 2.Serial & Concurrent

串行任务就是每次只有一个任务被执行，并发任务就是在同一时间可以有多个任务被执行。

#### 3.Synchronous & Asynchronous

Synchronous（同步函数）意思是在完成了它预定的任务后才返回，在任务执行时会阻塞当前线程。而 Asynchronous（异步函数）则是任务会完成但不会等它完成，所以异步函数不会阻塞当前线程，会继续去执行下去。

#### 4.Concurrency & Parallelism

Concurrency （并发）的意思就是同时运行多个任务。这些任务可能是以在单核 CPU 上以分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。然后为了使单核设备也能实现这一点，并发任务必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。Parallelism（并行）则是真正意思上的多任务同时运行。

#### 5.Context Switch

Context Switch即上下文切换，一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。

#### 6.Dispatch Queues

GCD dispatch queues 是一个强大的执行多任务的工具。Dispatch queue 是一个对象，它可以接受任务，并将任务以先进先出(FIFO)的顺序来执行。Dispatch queue 可以并发的或串行的执行任意一个代码块，而且并发任务会像 NSOperationQueue 那样基于系统负载来合适地并发进行，串行队列同一时间则只执行单一任务。Dispatch queues 内部使用的是线程，GCD 管理这些线程，并且使用 Dispatch queues 的时候，我们都不需要自己创建线程。Dispatch queues相对于和线程直接通信的代码优势是：使用起来特别方便，执行任务更加有效率。

#### 7.Queue Types

*    main queue  :  主队列  （主线程）


```
一般使用 main queue, 都是在该线程中操作 UI 相关的.也就是说, 在 main queue 中执行的任务会在主线程中执行.主线程只有一个, main queue 是与主线程相关的，所以 main queue 是串行队列.

//Returns the default queue that is bound to the main thread.
                                                                                                                                                                       dispatch_get_main_queue(void)
{
	return DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);                                                                                   
}
```



*    global queue  :  全局队列 （有多个线程）


```
dispatch_get_global_queue(long identifier, unsigned long flags);                                                        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 
常写作 dispatch_get_global_queue(0, 0);

global queue 是并发队列.可以设置其优先级.  ？？？优先级问题
//@param identifier  优先级
- A quality of service class defined in qos_class_t or a priority defined in  
                                                                                                                                                   - dispatch_queue_priority_t.
 //@param flags  备用参数
- Reserved for future use. Passing any value other than zero may result in
- a NULL return value.
//@result  返回一个全局队列
- Returns the requested global queue or NULL if the requested global queue
- does not exist.
```



*    custom queue  : 自定义队列  （串行：单线程 ，并行：有多个线程）


```
这些队列是可以是串行的, 也可以是并行的。默认是串行的.
dispatch_queue_attr_t设置成NULL的时候默认代表串行。
串行队列可以保证任务是串行的, 保证了执行顺序.类似锁机制.
   
dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);
                                                                                           
//@param label  队列名称 尽量别重名
- A string label to attach to the queue.
- This parameter is optional and may be NULL.
//@param attr   队列类型  默认 DISPATCH_QUEUE_SERIAL
- A predefined attribute such as DISPATCH_QUEUE_SERIAL,
- DISPATCH_QUEUE_CONCURRENT, or the result of a call to
- a dispatch_queue_attr_make_with_* function.
//@result
- The newly created dispatch queue.
```



### GCD的具体使用

#### 1.添加任务到队列

GCD有两种方式来把任务添加到队列中：异步和同步。

异步方式添加任务到队列的情况：

1.自定义串行队列：顺序执行

2.主队列：顺序执行、这是在一个并发队列上完成任务后更新 UI 的一般选择。

3.并发队列：非顺序执行，随机



#### 2.并发执行迭代循环

在开发中，并发队列能很好地提高效率，特别是当我们需要执行一个数据庞大的循环操作时。打个比方来说吧，我们需要执行一个for循环，每一次循环操作如下：

```
for (i = 0; i < count; i++) {
   NSLog("%d",i);
}
```


GCD提供了一个简化方法叫做dispatch_apply，当我们把这个方法放到并发队列中执行时，这个函数会调用单一block多次，并平行运算，然后等待所有运算结束。

**代码示例：**

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_apply(count, queue, ^(size_t i) {
   NSLog("%d",i);
});

但是dispatch_apply函数是没有异步版本的。只能将整个dispatch_apply 置于异步中。

直接在主线程调用dispatch_apply 会阻塞主线程，如果使用了并发队列 队列任务会被放置在异步线程中执行，但是主线程依然被阻塞。
```



#### 3.挂起和恢复队列

有时候，我们不想让队列中的某些任务马上执行，这时我们可以通过挂起操作来阻止一个队列中将要执行的任务。当需要挂起队列时，使用**dispatch_suspend**方法；恢复队列时，使用**dispatch_resume**方法。调用**dispatch_suspend**会增加队列挂起的引用计数，而调用**dispatch_resume**则会减少引用计数，当引用计数大于0时，队列会保持挂起状态。因此，这队列的挂起和恢复中，我们需要小心使用以避免引用计数计算错误的出现。

> 执行挂起操作不会对已经开始执行的任务起作用，它仅仅只会阻止将要进行但是还未开始的任务。

```
dispatch_queue_t myQueue;

myQueue = dispatch_queue_create("com.example.MyCustomQueue", NULL);
//挂起队列
dispatch_suspend(myQueue);
//恢复队列
dispatch_resume(myQueue);
```



#### 4.dispatch_after 的使用

延迟一段时间把一项任务提交到队列中执行，返回之后就不能取消

```
dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);
```



#### 5.dispatch_once 的使用

保证在APP运行期间，block中的代码只执行一次

```
dispatch_once(<#dispatch_once_t * _Nonnull predicate#>, <#^(void)block#>)
```



#### 6.Dispatch Groups 的使用

**Dispatch groups**是阻塞线程直到一个或多个任务完成的一种方式。在那些需要等待任务完成才能执行某个处理的时候，你可以使用这个方法。**Dispatch Group**会在整个组的任务都完成时通知你，这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，**Dispatch Group**可以用同步的或者异步的方式通知你。当group中所有的任务都完成时，GCD 提供了两种通知方式。

**dispatch_group_wait**。它会阻塞当前线程，直到队列里面所有的任务都完成或者等到某个超时发生。

代码示例：

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
// 添加队列到组中
dispatch_group_async(group, queue, ^{
// 一些异步操作 或者耗时操作
});

//如果在所有任务完成前超时了，该函数会返回一个非零值。
//你可以对此返回值做条件判断以确定是否超出等待周期；
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

NSLog(@"123"); //被阻塞,因为dispatch_group_wait  所以这一句代码只会在队列任务都完成后执行
```




**dispatch_group_notify**。它以异步的方式工作，当 Dispatch Group中没有任何任务时，它就会执行其代码，那么 completionBlock便会运行。可以用于在并行队列中待所有任务都完成之后再调起执行。

代码示例：

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
// 添加队列到组中
dispatch_group_async(group, queue, ^{
// 一些异步操作
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{ 
   //队列都完成之后才会调起
});
NSLog(@"123");//不会被阻塞
```

#### 7.GCD在 Swift 中的使用



## NSThread



## 常见问题

dispatch_release 已被废弃（6.0）dispatch_release在6.0以后内部被改成对象释放（release）所以 arc后都不再使用。

app启动，系统默认创建5个线程





捕获开发中子线程更新UI的逻辑

### 1.为什么UI要在主线程更新

因为UIKit不是线程安全的。试想下面这几种情况：

两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。 

两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。 

两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。 

iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议讲UI操作保证在主线程中执行。

 

### 2.有什么软件或者插件可以测试这个问题吗？



### 3.我的想法

View的更新操作 使用runtime 去替换 View 中实现 的方法 不变更实现。只是在中间插入 线程检查操作，发现子线程就必须打印线程调用栈并触发crash。

问题：替换哪些方法更合适?  都会涉及到哪些基础控件需要category？



### 4.例子

1.创建一个UIImage的category

```
@implementation UIImage (demo)

+(void)load
{
    Method  m1 = class_getClassMethod([UIImage class],@selector(imageNamed:));
    
    Method m2 = class_getClassMethod([UIImage class],@selector(ximageNamed:));
    
    // 开始交换方法实现
    method_exchangeImplementations(m1, m2);
}
+(UIImage *)ximageNamed:(NSString *)name
{
    NSLog(@"进入方法-开始检查线程");
    
    NSThread *thread = [NSThread currentThread];
    if (![thread isMainThread]) {
        NSLog(@" 当前线程不是主线程  %@",[NSThread callStackSymbols]);
    }
    return [UIImage ximageNamed:name];
}
@end
```

2.在一个视图内实现一段UIImage的异步赋予图片

```
    UIImageView *img = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 300, 300)];
    [self.view addSubview:img];
    img.image = [UIImage imageNamed:@"networklosed"];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        img.image = [UIImage imageNamed:@"mncg_search_nor"];
    });
    NSLog(@"测试线程是否异步");
```

3.检测结果为非主线程 并打印出线程 函数调用栈





多线程使用场景

3、常见多线程错误场景




## 参考

[GCD使用三部曲之：基本用法](http://www.jianshu.com/p/d56064507fb8)