---
layout: post
category: 2016年
title:  "iOS运行时的学习" 
---

### OC是动态语言

OC是一门动态语言，类型的判断、类的成员变量、方法的内存地址都是在程序的运行阶段才最终确定，并且还能动态的添加成员变量和方法。也就意味着你调用一个不存在的方法时，编译也能通过，甚至一个对象它是什么类型并不是表面我们所看到的那样，只有运行之后才能决定其真正的类型

Objective-C 消息机制：

```
1、编译器会先将代码[obj  method]转化为objc_msgSend(obj, @selector (method))函数去执行。

2、在objc_msgSend()函数中,首先通过obj的isa指针找到(对象)obj对应的(类)class。

3、在class中会先去cache中 通过SEL查找对应函数method（cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若 cache中未找到。再去class中的消息列表methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。

补充：

>在oc中，每一个对象都有一个isa指针变量，这个指针指向的是对象的类，我们可以通过isa指针访问一个对象的类

>方法都保存在类的消息列表中，这个列表其实是一个字典，key是selector，value是IMP（imp是一个指针类型，指向方法的实现），并且selector和IMP之间的关系是在运行时才决定的，而不是编译时。如此们就可以做出一些特别事情来。
```



### 我们可以用运行时做什么



#### 1、互换方法的实现

上面说到selector和IMP之间的关系是在运行时才决定的，那我们是不是可以改变selector和IMP的对应关系呢？runtime就给我们提供了这么一个函数：

```
void method_exchangeImplementations(Method m1, Method m2)

例子：

__inline__ __attribute__((always_inline)) void MethodSwizzle(Class class,SEL origSEL,SEL overrideSEL)
{
    Method origMethod = class_getInstanceMethod(class, origSEL);
    Method overrideMethod= class_getInstanceMethod(class, overrideSEL);
    if(class_addMethod(class, origSEL, method_getImplementation(overrideMethod),method_getTypeEncoding(overrideMethod))){
        //如果添加方法成功，则说明子类没用重写该方法，这时候superClass的原方法的指针已经指向了 overrideMethod ，所以 overrideMethod 还需要被superClass的原方法的指针替换
        class_replaceMethod(class,overrideSEL, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));
    }else{
        //如果重写了方法则直接交换
        method_exchangeImplementations(origMethod,overrideMethod);
    }
}

+ (void)load
{
    SEL originalSelector = @selector(viewDidLoad);
    SEL swizzledSelector = NSSelectorFromString([@"jfz_" stringByAppendingString:NSStringFromSelector(originalSelector)]);
    MethodSwizzle(self, originalSelector, swizzledSelector);
}

load方法中替换了方法

+load方法的执行时机：见末尾题外话


attribute((always_inline))的意思是强制内联，所有加了attribute((always_inline))的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如我定义了函数 
attribute((always_inline)) void a()和 
void b() 
｛ 
a(); 
｝ 
b调用a函数的汇编代码不会是跳转到a执行，而是a函数的代码直接在b内成为b的一部分。
```



#### 2、动态添加方法

经常遇见 “ unrecognized selector sent to instance ” 错误，编译阶段没问题，但是运行crash

原因就是方法调用在运行时才知道是否实现。

从而，我们可以动态的为某个类添加方法，而苹果performSelector:这个方法也很好的为我们逃过编译报错提供了支持。示例代码如下：

```

//动态添加方法
class_addMethod(class, origSEL, method_getImplementation(overrideMethod),method_getTypeEncoding(overrideMethod))

//判断方法是否已经实现
if ([homeController respondsToSelector:@selector(setNavigationItems:)]) {
    [homeController performSelector:@selector(setNavigationItems:) withObject:self.rootTabBarController];
}
```



#### 3、动态添加属性

这也是runtime的一个重量级功能了，我们经常会想为系统的类或者一些不便修改的第三方框架的类增加一些自定义的属性以满足开发的需求。这个时候我们还是首先会想到类目，但是问题来了，类目只能为一个类添加方法，不能添加属性。

运行时，为类动态添加属性。

```
示例代码：为UIViewController类添加一个是否显示导航的属性: BOOL isTempNavigationBarShowing
static char *const  isTempNavigationBarShowingKey = "isTempNavigationBarShowingKey";
- (void)setIsTempNavigationBarShowing:(BOOL)isTempNavigationBarShowing
{
    objc_setAssociatedObject(self, isTempNavigationBarShowingKey, @(isTempNavigationBarShowing), OBJC_ASSOCIATION_RETAIN);
}

- (BOOL)isTempNavigationBarShowing
{
    return [objc_getAssociatedObject(self, isTempNavigationBarShowingKey) boolValue];
}


```



#### 4、获取类中所有的成员变量和属性

一些没有提供API的类，有些属性我们拿不到又需要用怎么办？

例如：UITextField的placeholder的颜色，API并没有这个属性

```
运行时获取UITextField的所有成员变量，会发现有一个_placeholderLabel成员变量，通过这个可以设置颜色

[self.textField setValue:[UIColor blueColor] forKeyPath:@"_placeholderLabel.textColor"];
```



### 题外话-iOS程序启动过程

iOS开发中，main函数是我们熟知的程序启动入口，但实际上并非真正意义上的入口，因为在我们运行程序，再到main方法被调用之间，程序已经做了许许多多的事情，比如我们熟知的runtime的初始化就发生在main函数调用前，还有程序动态库的加载链接也发生在这阶段。

1、系统先读取App的可执行文件（Mach-O文件），获取到dyld的路径，并加载dyld

2、dyld去初始化运行环境、开启缓存策略、加载依赖库、我们的可执行文件、链接依赖库，并调用每个依赖库的初始化方法

3、在上一步runtime被初始化，当所有的依赖库初始化后，程序可执行文件进行初始化，这个时候runtime回对项目中的所有类进行类结构初始化，然后调用所有类的+load方法

```
1、runtime初始化方法 _objc_init 中最后注册了两个通知：
map_images 主要是在镜像加载进内容后对其二进制内容进行解析，初始化里面的类结构等
load_images主要是调用call_load_methods 按照继承层次依次调用Class的 +load方法 然后是Category的+ load方法。(call_load_methods 调用load 是通过方法地址直接调用的load方法，并不是通过消息机制，这就是为什么分类中的load方法并不会覆盖主类以及其他同主类的分类里的load 方法实现了。)

2、runtime 调用项目中所有的load方法时，所有的类的结构已经初始化了,此时在load方法中可以使用任何类创建实例并给他们发送消息。
```

4、最后dyld返回main函数地址，main函数被调用



5、通过了解程序在启动前做了什么，我们可以尝试去优化App的启动速度

[参考](https://www.jianshu.com/p/43db6b0aab8e)

