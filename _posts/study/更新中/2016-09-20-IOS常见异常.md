---
layout: post
category: 学习之路
title : "iOS 常见异常"
---

IOS 异常捕获和常见Crash

1."performSelector may cause a leak because its selector is unknown"

cause by 

```
[target performSelector:action];
```

solve 

```
IMP imp = [target methodForSelector:action];
void (*func)(id, SEL) = (void *)imp;
func(target,action);
```

或者忽略

```
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
[target performSelector:action];
#pragma clang diagnostic pop
```



10.Use Legacy Swift Language Version  错误    

在project  和target 吧 SWIFT_VERSION   Use Legacy Swift Language Version   这个属性改成NO就可以了

高版本Xcode 选Swift3



1、iOS 删除线不显示问题 （10.3以后） 解决办法：

```
[str addAttribute:NSStrikethroughStyleAttributeName value:@(NSUnderlineStyleSingle | NSUnderlinePatternSolid) range:NSMakeRange(3, model.fee.length)];
//加上下面这个属性
[str addAttribute:NSBaselineOffsetAttributeName value:@(NSUnderlineStyleNone) range:NSMakeRange(0, 3)];
```



2、在开发过程中会有一种情况就是，多个浮层的页面，会出现浮层资源抢占导致的卡死。

iOS中timer相关的延时调用，常见的有NSObject中的**performSelector:withObject:afterDelay:**这个方法在调用的时候会设置当前runloop中timer，还有一种延时，直接使用**NSTimer**来配置任务。

这两种方式都一个共同的前提，就是当前线程里面需要有一个运行的runloop并且这个runloop里面有一个timer。

我们知道：只有主线程会在创建的时候默认自动运行一个runloop，并且有timer，普通的子线程是没有这些的。这样就带来一个问题了，有些时候我们并不确定我们的模块是不是会异步调用到，而我们在写这样的延时调用的时候一般都不会去检查运行时的环境，这样在子线程中被调用的时候，我们的代码中的延时调用的代码就会一直等待timer的调度，但是实际上在子线程中又没有这样的timer，这样我们的代码就永远不会被调到。

下面的代码展示了performSelector和dispatch_time的不同

```
1. /* 
2. 采用gcd的方式 延时添加到队列 
3. */  
4. -(void) testDispatch_after{  
5.     dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);  
6.     dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  
7.     dispatch_after(time, queue, ^{  
8.         NSLog(@"3秒后添加到队列");  
9.     });  
10.     dispatch_release(queue);  
11. }  
12. -(void) testDelay{  
13.     NSLog(@"testDelay被执行");  
14. }  
15. /* 
16. dispatch_barrier_async 栅栏的作用 
17. */  
18. -(void) testDispatch_Barrier{  
19.     //dispatch_queue_t gcd = dispatch_queue_create("这是序列队列", NULL);  
20.     dispatch_queue_t gcd = dispatch_queue_create("这是并发队列", DISPATCH_QUEUE_CONCURRENT);  
21.     dispatch_async(gcd, ^{  
22.         NSLog(@"b0");  
23.         //这个selector不会执行，因为线程中没有runloop  
24.         [self performSelector:@selector(testDelay) withObject:nil afterDelay:3];  
25.         //代码会执行，因为采用了gcd方式  
26.         [self testDispatch_after];  
27.     });  
28.     dispatch_release(gcd);  
29. }  
```



在有多线程操作的环境中，**这样performSelector的延时调用，其实是缺乏安全性的**。我们可以用另一套方案来解决这个问题，就是使用GCD中的dispatch_after来实现单次的延时调用

### 另外有一个解决方案：

performSelector并不是没有办法保证线程安全。例如下面的代码就可以运行：

1. [self performSelector:@selector(testDelay) onThread:[NSThread mainThread] withObject:nil waitUntilDone:NO];  

指定了该selector在主线程中运行。

### 还有一个解决方案：

1. [self performSelector:@selector(testDelay) withObject:nil afterDelay:3 inModes:[NSArray arrayWithObject:NSDefaultRunLoopMode]];  

2. [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];  

   ​

3、断点下载

http://www.jianshu.com/p/f65e32012f07



4、

**App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.**



解决在iOS9下基于ATS对HTTP的请求的说明及适配进行说明

系统会告诉我们不能直接使用HTTP进行请求，需要在Info.plist新增一段用于控制ATS的配置：

```
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```
5、Swift和OC混编的 改成动态库后编译速度，和每次改变swift都会重新编译 优化



6  8.3.3 xcode swift 和 OC混编 动态库 ，xcode每次buid后再次buid必崩溃

http://www.openradar.me/17920383

```
OTHER_SWIFT_FLAGS 这个参数
OTHER_SWIFT_FLAGS = "-D DEBUG -D FOO -Xfrontend -debug-time-function-bodies -driver-show-incremental";
 changeTo
 OTHER_SWIFT_FLAGS = "-D DEBUG -D FOO -Xfrontend -debug-time-function-bodies";
```



7、当scrollView 作为第一个view添加进self.view的时候，会被偏移contentOffset -64

```
如果只是解决，可以设置self.automaticallyAdjustsScrollViewInsets = false; 或者
self.edgesForExtendedLayout = [] 
但是在scrollview中解决尚未清楚
```



8、linker command failed with exit code 1





使用 Xcode 8 每次修改文件都需要全量编译的可以把 project 中的 C Language Dialect 设置为 Compiler Default。问题解决 







**NSInternalInconsistencyException**





启动崩溃问题：

SIGABRT

```

```

SIGTRAP

```
为一个非可选（non-optional）类型被赋值nil
一个有问题的强制类型转换
网络差得时候容易出现
```



