---
layout: post
category: 学习之路
title : "iOS 常见异常"
---

#### 问题：performSelector may cause a leak because its selector is unknown

```
原因：
[target performSelector:action];

解决：
IMP imp = [target methodForSelector:action];
void (*func)(id, SEL) = (void *)imp;
func(target,action);

或者忽略：
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
[target performSelector:action];
#pragma clang diagnostic pop
```



#### 问题：Use Legacy Swift Language Version

```
在project  和target 吧 SWIFT_VERSION   Use Legacy Swift Language Version   这个属性改成NO就可以了

高版本Xcode 选Swift3
```



#### 问题：iOS 删除线不显示问题 （10.3以后）

```
解决办法：

[str addAttribute:NSStrikethroughStyleAttributeName value:@(NSUnderlineStyleSingle | NSUnderlinePatternSolid) range:NSMakeRange(3, model.fee.length)];
//加上下面这个属性
[str addAttribute:NSBaselineOffsetAttributeName value:@(NSUnderlineStyleNone) range:NSMakeRange(0, 3)];
```



#### 问题：在开发过程中会有一种情况就是，多个浮层的页面，会出现浮层资源抢占导致的卡死

```
iOS中timer相关的延时调用，常见的有NSObject中的performSelector:withObject:afterDelay:这个方法在调用的时候会设置当前runloop中timer，还有一种延时，直接使用NSTimer来配置任务。

这两种方式都一个共同的前提，就是当前线程里面需要有一个运行的runloop并且这个runloop里面有一个timer。

我们知道：只有主线程会在创建的时候默认自动运行一个runloop，并且有timer，普通的子线程是没有这些的。这样就带来一个问题了，有些时候我们并不确定我们的模块是不是会异步调用到，而我们在写这样的延时调用的时候一般都不会去检查运行时的环境，这样在子线程中被调用的时候，我们的代码中的延时调用的代码就会一直等待timer的调度，但是实际上在子线程中又没有这样的timer，这样我们的代码就永远不会被调到。

下面的代码展示了performSelector和dispatch_time的不同

1. /* 
2. 采用gcd的方式 延时添加到队列 
3. */  
4. -(void) testDispatch_after{  
5.     dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);  
6.     dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  
7.     dispatch_after(time, queue, ^{  
8.         NSLog(@"3秒后添加到队列");  
9.     });  
10.     dispatch_release(queue);  
11. }  
12. -(void) testDelay{  
13.     NSLog(@"testDelay被执行");  
14. }  
15. /* 
16. dispatch_barrier_async 栅栏的作用 
17. */  
18. -(void) testDispatch_Barrier{  
19.     //dispatch_queue_t gcd = dispatch_queue_create("这是序列队列", NULL);  
20.     dispatch_queue_t gcd = dispatch_queue_create("这是并发队列", DISPATCH_QUEUE_CONCURRENT);  
21.     dispatch_async(gcd, ^{  
22.         NSLog(@"b0");  
23.         //这个selector不会执行，因为线程中没有runloop  
24.         [self performSelector:@selector(testDelay) withObject:nil afterDelay:3];  
25.         //代码会执行，因为采用了gcd方式  
26.         [self testDispatch_after];  
27.     });  
28.     dispatch_release(gcd);  
29. }  

在有多线程操作的环境中，这样performSelector的延时调用，其实是缺乏安全性的。我们可以用另一套方案来解决这个问题，就是使用GCD中的dispatch_after来实现单次的延时调用

另外有一个解决方案：

performSelector并不是没有办法保证线程安全。例如下面的代码就可以运行：

1. [self performSelector:@selector(testDelay) onThread:[NSThread mainThread] withObject:nil waitUntilDone:NO];  
指定了该selector在主线程中运行。

还有一个解决方案：

1. [self performSelector:@selector(testDelay) withObject:nil afterDelay:3 inModes:[NSArray arrayWithObject:NSDefaultRunLoopMode]];  
2. [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];  
```



#### 问题：App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.

```
解决在iOS9下基于ATS对HTTP的请求的说明及适配进行说明

系统会告诉我们不能直接使用HTTP进行请求，需要在Info.plist新增一段用于控制ATS的配置：


<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>
</dict>
```


#### 问题：Swift和OC混编的 改成动态库后编译速度很慢，和每次改变swift都会重新编译就算了，还经常丢失提示、修改OC也需要全部重新编译



#### 问题： 8.3.3 xcode swift 和 OC混编 动态库 ，xcode每次buid后再次buid必崩溃

http://www.openradar.me/17920383

```
OTHER_SWIFT_FLAGS 这个参数
OTHER_SWIFT_FLAGS = "-D DEBUG -D FOO -Xfrontend -debug-time-function-bodies -driver-show-incremental";
改成：
OTHER_SWIFT_FLAGS = "-D DEBUG -D FOO -Xfrontend -debug-time-function-bodies";
```



#### 问题：当scrollView 作为第一个view添加进self.view的时候，会被偏移contentOffset -64

```
如果只是解决，可以设置self.automaticallyAdjustsScrollViewInsets = false; 或者
self.edgesForExtendedLayout = [] 
但是在scrollview中解决尚未清楚
```



#### 问题：[__NSArrayI removeAllObjects]: unrecognized selector sent to instance 0x7fb6d8233c00

NSMutableArray  不要用copy修饰，NSMutableArray  不要直接赋值





#### 问题：升级Xcode 9 + iOS 11后，发现原本没问题的collectionView和tableView像是中了风一样，头部刷新UI出现了错乱。

查阅发现 iOS11弃用了automaticallyAdjustsScrollViewInsets属性，新增contentInsetAdjustmentBehavior来替代它

关于 contentInsetAdjustmentBehavior

```
@available(iOS 11.0, *)
public enum UIScrollViewContentInsetAdjustmentBehavior : Int {

    case automatic // Similar to .scrollableAxes, but will also adjust the top & bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewContentInset = YES inside a navigation controller, regardless of whether the scroll view is scrollable

    case scrollableAxes // Edges for scrollable axes are adjusted (i.e., contentSize.width/height > frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)

    case never // contentInset is not adjusted

    case always // contentInset is always adjusted by the scroll view's safeAreaInsets
}
```

UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种:

- -automatic 和scrollableAxes一样,scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时,也会设置内边距.
- -scrollableAxes 自动计算内边距.
- -never不计算内边距
- -always 根据safeAreaInsets 计算内边距

很显然,我们这里要设置为 never

**开始适配**

**OC 中**

```
        //声明tableView的位置 添加下面代码
        if (@available(iOS 11.0, *)) {
            _tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;
            _tableView.contentInset = UIEdgeInsetsMake(64, 0, 49, 0);
            _tableView.scrollIndicatorInsets = _tableView.contentInset;
        }
```

**swift 中**

```
        //声明tableView的位置 添加下面代码
        if #available(iOS 11.0, *) {
            tableView.contentInsetAdjustmentBehavior = .never
            tableView.contentInset = UIEdgeInsetsMake(64, 0, 49, 0)
            tableView.scrollIndicatorInsets = tableView.contentInset
        }
```

终于又回归原来的效果啦





http://www.jianshu.com/p/370d82ba3939



上面解决方案出现问题，无法解决，tableView依然抖动



检查排除后





Undefined symbols for architecture x86_64:

  "_CATSwizzeMethod", referenced from:

​      ___34+[UINavigationBar(CATCustom) load]_block_invoke in UINavigationBar+JFZCustom.o

ld: symbol(s) not found for architecture x86_64

clang: error: linker command failed with exit code 1 (use -v to see invocation)



问题：

Undefined symbols for architecture x86_64



检查search path是否有问题，没问题 清理derivedata 



还不行，就是我遇到的问题，在动态库环境下打了静态库，模拟器编译不了



```
ignoring file /Users/young/Desktop/workplace/JFZFP_iOS/JFZSpecs/Aspects/libAspects.a, missing required architecture x86_64 in file /Users/young/Desktop/workplace/JFZFP_iOS/JFZSpecs/Aspects/libAspects.a (2 slices)ignoring file /Users/young/Desktop/workplace/JFZFP_iOS/JFZSpecs/SDCycleScrollView/libSDCycleScrollView.a, missing required architecture x86_64 in file /Users/young/Desktop/workplace/JFZFP_iOS/JFZSpecs/SDCycleScrollView/libSDCycleScrollView.a (2 slices)
```



