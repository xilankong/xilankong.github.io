---

---

QUESTION:

1、IOS 7.0下面使用自动布局之后 再次在layoutSubViews中变更了 子view的frame 需要更新AutoLayout机制  [self.view layoutIfNeeded]; 

添加到父类控制器的 -(void)viewDidLayoutSubviews 方法中

//必须要 Auto Layout still required after sending -viewDidLayoutSubviews to the view controller.



2、导航条上会用到的属性变化

1. 按钮颜色
2. title颜色
3. 导航背景色
4. 顶部状态栏变色

```
//按钮颜//按钮颜色
self.navigationController.navigationBar.tintColor = [UIColor whiteColor];
//导航条bar背景色
self.navigationController.navigationBar.barTintColor = [UIColor blackColor];
//导航条文字title颜色
[self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor whiteColor]}];
//设置顶部状态栏变色

1.控制器是依赖于系统的UINavigationController的：
第一步 ： 拓展一个UINavigationController的子类，
并设置 将导航控制器内所有控制器的顶部状态栏设置权赋予这些控制器。
- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}

第二步 ： 在导航下的控制器中实现 配置 

- (UIStatusBarStyle)preferredStatusBarStyle
{
    return UIStatusBarStyleLightContent; //白色
    //return UIStatusBarStyleDefault; //黑色
}

2.直接设置
1在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO

2 在需要改变状态栏颜色的ViewController中在ViewDidLoad方法中增加：

[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];

//这个地方，UIStatusBarStyleDefault外，设置其他值，导航条的文字颜色都将是白色，亲试。
```



3、Xcode卡 经常丢失高亮和代码提示

未解决



4、导航条背景色变透明

```
在viewwillappear调用
- (void)jfz_changeNavigationBarTintColorWithoutBottomLine:(UIColor *)color
{
    if ([self.navigationBar respondsToSelector:@selector(setBackgroundImage:forBarMetrics:)]){
        NSArray *list=self.navigationBar.subviews;
        for (id obj in list) {
            if ([obj isKindOfClass:[UIImageView class]]) {
                UIImageView *imageView=(UIImageView *)obj;
                imageView.hidden = YES;
            }
        }
    }
    if (self.currentNaviBackgroundColor != color){
        self.currentNaviBackgroundColor = color;
        self.navigationBackground.image = [UIImage jfz_imageWithColor:color withSize:CGSizeMake(self.navigationBackground.bounds.size.width, self.navigationBackground.bounds.size.height)];
    }
    [self.navigationBar insertSubview:self.navigationBackground atIndex:0];
    
}
在viewwillDisappear调用
- (void)jfz_removeCurrentNavigationBackground {
    [self.navigationBackground removeFromSuperview];
    if ([self.navigationBar respondsToSelector:@selector( setBackgroundImage:forBarMetrics:)]){
        NSArray *list=self.navigationBar.subviews;
        for (id obj in list) {
            if ([obj isKindOfClass:[UIImageView class]]) {
                UIImageView *imageView=(UIImageView *)obj;
                imageView.hidden = NO;
            }
        }
    }
}
```



5、在安装cocoapods遇到的问题  （未验证）

```
[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master
Cloning into 'master'...
error: RPC failed; curl 56 SSLRead() return error -36
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
```

解决方案： 

先在终端输入”sudo xcode-select -switch “，然后，打开Xcode—>右键显示包内容，找到Developer文件夹拖到终端里面

PS:一些xcode-select的命令的使用：

xcode-select [-help]
xcode-select [-switch xcode_folder_path]
xcode-select [-print-path]
xcode-select [-version]

例如： 
打印当前xcode的路径    xcode-select --print-path

输出：/Applications/Xcode.app/Contents/Developer



6、函数调用栈

```
(NSArray *)callStackReturnAddresses ／／线程的调用都会有函数的调用 函数的调用就会有栈返回地址的记录，在这里返回的是函数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组

(NSArray *)callStackSymbols ／／同上面的方法一样，只不过返回的事该线程调用函数的名字数字
```



6、iOS开发工具——统计Crash的工具Crashlytics

未查看



7、UITableViewCell  在点击之后马上取消点击效果

(void)setSelected:(BOOL)selected animated:(BOOL)animated {
//    [super setSelected:selected animated:animated];

}

在点击之后重新退回页面的时候取消点击效果

​ [tableView deselectRowAtIndexPath:indexPath animated:YES];

同时，tableViewCell 自带取消点击效果 



8、让scrollView延伸到导航条下面   使用需要注意场合 

self.automaticallyAdjustsScrollViewInsets = NO;

???

​    self.edgesForExtendedLayout = UIRectEdgeNone;

9、错误案例：

    NSDictionary *dict = [NSDictionary dictionary];
    [dict setValue:@"xx" forKey:@"key"];
NSDictionary 是不可变的



10、UIVisualEffectView 毛玻璃效果

    UIVisualEffectView *blurView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight ]];
    blurView.layer.opacity = .9;
    blurView.frame = self.view.frame;
    [self.view addSubview:blurView];
11、 po [self.view recursiveDescription] 打印当前视图subviews的UI层次



12、instrument 使用

1.Target failed to run: Permission to debug jp.psc.TabletSync was denied. The app must be signed with a development identity (e.g. iOS Developer).

把 工程的scheme 中的profile  build模式改成debug





13、在Pod库中使用xcasset的拷贝陷阱

工作中遇到一个难解的BUG - 在App中用UIImage的imageNamed:方法读取的图片始终是不正确的。突然图片获取途径都是正常情况下 图片资源却取的不正确。排除缓存问题后，查看ipa包下面的图片是正确的。 

原因：http://blog.startry.com/2016/03/17/the-trap-of-image-resource/

CocoaPods在Pod里引用了任意一个xcasset相关的文件后, 就会去根目录搜索所有的xcasset组合成为最终的car。CocoaPods设定这样脚本的原因是无法精确的将主工程下的xcasset寻找到, 只能采用暴力的方式去解决, 暂时也没有更好的解决方案！

解决办法：

方法一: 删除所有物理目录下多余的xcasset, 本身在源代码根目录下放置没有用到库本身就是非常危险的行为。
方法二: 通过Podfile Hook去屏蔽Pod库资源的Copy和合成, 替换核心脚本, 定向指定自己需要Copy的资源。
方法三: 逃避的方法, 不要在Pod库中使用xcasset。本身CocoaPods的初衷并没有打算支持资源文件的, 后续演变成目前的形态。(不适用xcasset默认png压缩不会执行, 可能需要手动执行, 并且图片容易被提取)



14、IOS 按钮xib设置按钮取消点击效果 要从 system 改成custom



15、cocoa pods 升级更新

//gem更新

sudo gem update -n /usr/local/bin --system

//升级指定版本的cocoapods

sudo gem install -n /usr/local/bin cocoapods --version 1.1.0

sudo gem install -n /usr/local/bin cocoapods

//安装卸载指定版本的cocoapods

sudo gem install cocoapods --version 0.24.0

sudo gem uninstall cocoapods卸载cocoapods

16、查看具体设备 

```
#import <sys/sysctl.h>

+ (NSString*)getDeviceVersion

{
    
    size_t size;
    
    sysctlbyname("hw.machine",NULL, &size, NULL,0);
    
    char *machine = (char*)malloc(size);
    
    sysctlbyname("hw.machine", machine, &size,NULL, 0);
    
    NSString *platform = [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
    
    //NSString *platform = [NSStringstringWithUTF8String:machine];二者等效
    
    free(machine);
    
    return platform;
    
}

NSLog(@"%@",[ViewController getDeviceVersion])
```

17.

#  错误操作  真正原因是代理被修改

当使用图片选择器的时候 如果是控制器设置的时局部变量，不能在弹出之前 给代理  需要在弹出之后给上代理处理、当遇到代理回调不出现的时候 检查代理是否被修改

    UIImagePickerController *picker = [[UIImagePickerController alloc] init];
    picker.sourceType               = (int)sourceType;
    picker.delegate                 = (id)self;
    [self presentViewController:picker animated:YES completion:^{
        picker.delegate                 = (id)self;
    }];
18.

oc中  @class 和 #import的区别

@class可以减少xcode编译文件数  @class 可以解决指针引用某个类中的内容等问题  

@class 告诉xcode  后面这个类 只需要知道是指针引用就行，不需要知道全部定义  所有判断使用的时候 看是否需要知道全部定义：例如继承之类的  无法用@class

19.

IOS 响应链

http://ios.jobbole.com/88526/

NSScaner

http://blog.csdn.net/likendsl/article/details/7974761



20.

static和const的使用


##### static  生命周期


1.

修饰局部变量、让局部变量只初始化一次、局部变量在程序中只有一份内存

并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）

2.
修饰全局变量

全局变量的作用域仅限于当前文件

##### const  是否可修改


没有const修饰的指针

指针p和*p都能被修改

// 定义一个指针变量
int *p = NULL;

// 定义2个int类型的变量
int a = 10;
int b = 30;

// p指向a
p = &a;
*p = 20;

// p指向b
p = &b;
*p = 40;

NSLog(@"%d %d", a, b);
const修饰的*p

被const修饰的*p只能被赋值一次，以后不能赋值，否则编译器报错

// const修饰的*p
const int *p = NULL;
int const *p = null;

*p = 20; // 编译器报错，不能修改*p的值
const修饰的p

被const修饰的p只能存一次地址，以后再也不能其它存地址了，否则编译器报错

// const修饰的指针变量p
int * const p = NULL;
int a = 20;

p = &a; // 编译器报错，不能修改指针变量p
const在声明字符串的用法
  NSString * const ZMJName = @"jack";
static和const联合使用
static将一个全局变量变成局部变量
const将一个局部变量变成局部常量
// 定义了一个局部常量
static const CGFloat ZMJRed = 0.4;
static const CGFloat ZMJGreen = 0.6;
static const CGFloat ZMJBlue = 0.7;
使用static const 与 #define
使用static const修饰变量和宏定义的比较
相同点 : 都不能再被修改  一处修改，其它都改了
不同点 : static const修饰变量只有一份内存  宏定义，只是简单的替换，每次使用都需要创建一份内存
结论 :
使用static const修饰更加高效，在同一个文件内可以使用static const取代#define
    // static const修饰变量只有一份内存
    static const CGFloat ZMJRed = 0.4;
    // 宏定义，只是用0.4替换ZMJRed，每次使用都需要创建一份内存
    #define ZMJRed 0.4
const实际开发的应用
一般专门存放常量的引用

// 定义了整个程序都能访问的常量
const CGFloat ZMJRed = 0.4;
NSString * const ZMJName = @"jack";



21.

tableView的侧滑删除  commitEditingStyle 、canEditRowAtIndexPath

deleteRowsAtIndexPaths 的时候 需要先 更新数据源 再移除 防止空指针问题

22.

对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。

    NSString *string = @"origin";
    NSString *stringCopy = [string copy];
    理解这个的时候要分清楚，*string 是一个指针，它本身有一个内存地址 存放了@"origin"这个对象的内存地址
    每次拷贝都会生成一个新的指针地址 *stringCopy  但是这个指针地址内存放的对象内存地址会因为拷贝方式不一样而不一样。
23.

Xcode 7.0也就是iOS9.0中开发要求App内访问的网络必须使用HTTPS协议。那么我们公司没用采用https怎么办？如果发现网络请求失败，Xcode后台报错信息为： 
The resource could not be loaded because the App Transport Security policy requires the use of a secure connection. 
（大概意思就是：资源数据不能被下载，因为APP传输安全策略需要采用安全的连接方式）。

解决方法：

在Info.plist中添加NSAppTransportSecurity类型Dictionary。 
在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES

    <key>NSAppTransportSecurity</key>
    <dict>
          <key>NSAllowsArbitraryLoads</key>
          <true/>
    </dict>
找到info.plist,注意不是测试文件里面的plist哦。 



24.监听侧滑完成

```
    [self.transitionCoordinator notifyWhenInteractionEndsUsingBlock:^(id<UIViewControllerTransitionCoordinatorContext>  _Nonnull context) {
        
    }];
```



25.  沙盒

    http://www.jianshu.com/p/f74a5ef11b78



26.字典设置





27.事件阻隔

比如button中加个view view的事件会阻隔掉button的touch事件 怎么办？

view.userInteractionEnabled  = NO;//取消view的事件响应能力即可



28.

@property (nonatomic, strong) NSMutableArray *dataArray;

当回用到dataArray去变更添加数据的时候，前面如果声明为copy  在构造的时候  需要使用mutableCopy 复制一份，不然会出现_ _NSArrayI 问题  也可直接用strong类型





29.

当一个View要随着内部内容自动变更frame



30.

小数的四舍五入

round(combinationFee  * 100)/100



31.

UIView 自动布局更新View大小，只要都是使用自动布局并且xib可以根据约束自己估算出高度就可以不设置UIView的高度，Xib会根据约束自动去计算需要的高度并展示

例如 UIView根据UILabel自动去计算高度，但是这个情况是在UIView刷新的时候才会生效，所以直接设置UILabel的text然后希望去取到新高度是不可能的。

masonry 写约束的话 每个View的上下左右相对约束都要有 相互约束 要保证有一方约束到



32.  break 后面不再执行





33. masonry 当针对负的offset设置大于等于时要用lessThan



oc pch文件的使用



http://www.jianshu.com/p/67ce72c4ad6c



注意要在  build - setting 中得 prefix Header配置新建的pch文件  配置格式 $(SRCROOT)/项目名称/pch文件名

当xib layout设置width>=0的时候  在代码中设置constraints = 0 无效 比如我需要移除一个label的宽度 但是label在xib中自适应的width>0   ?????

UITabelView 的 headView 想要动态更新大小的时候 需要变更view的frame然后重新设置tableHeaderView



34.

http://blog.csdn.net/loving_ios/article/details/53018879

UIView 有两个类别的content优先级

Content Hugging Priority      确定view有多大的优先级阻止自己变大。 默认 250  （例如保证UIButton不会因为屏幕边距变大而拉伸按钮）

Content Compression Resistance Priority  确定有多大的优先级阻止自己变小。  默认 750（例如保证UILabel不会被挤压导致显示不全）优先级越大 越不会被压缩

说这个之前先了解一些信息：

这两个属性对有intrinsic content size的控件（例如button，label）非常重要。通俗的讲，具有intrinsic content size的控件自己知道（可以计算）自己的大小，例如一个label，当你设置text，font之后，其大小是可以计算到的。

UIView中关于Content Hugging 和 Content Compression Resistance的方法

```
- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
```

默认从左到右，从上到下。   默认情况下两边的label的Content Hugging和Content Compression优先级都是一样的。当一个View 高度需要根据内容来扩张，那么内部label 和 view的优先级怎么判断 有什么不同吗？没有 根据优先级来。



测试出现的情况：

1.当xib的View中加了两个默认的Label 并自动计算高度适配，再通过代码在底下继续加上Label 的时候 label需要更改收缩优先级来保证他完整显示。(依然未解)

2.但是直接在xib中加入多个label，并设定好约束，label会正常扩张，父view也会正常扩张。

3.在 2 的基础上 再在底下通过代码添加的label 设定好masonry约束 同样能正常显示，正常扩张

4.一个View中 由上到下分别是 label、label、view（里面有一个label） 的布局，自动布局也可以正常扩张

5.hidden 并不会影响约束



35.

删除线在 IOS 8.0 的兼容问题 value中 给值的问题

```
ou should add NSUnderlineStyleNone at the beginning of the string.

 NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] init];
 [attributedString appendAttributedString:[[NSAttributedString alloc] initWithString:@"test "
                                                                          attributes:@{NSUnderlineStyleAttributeName: @(NSUnderlineStyleNone)}]];
 [attributedString appendAttributedString:[[NSAttributedString alloc] initWithString:@"s"
                                                                         attributes:@{NSUnderlineStyleAttributeName: @(NSUnderlineStyleSingle),
                                                                                      NSBackgroundColorAttributeName: [UIColor clearColor]}]];
 [attributedString appendAttributedString:[[NSAttributedString alloc] initWithString:@"tring"]];
Another bonus of such approach is absence of any ranges. Very nice for localized strings.
```



36.方法唤起，系统提供的方法只支持一两个参数，如果有多个参数 需要使用另一套。

系统

```
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
     [target performSelector:action];
#pragma clang diagnostic pop
```

自定义

```

```





37.va_list 的作用 用于接收一些可以传递不定个数量参数的方法中的参数。

```
- (id)customPerformSelector:(SEL)aSelector withObjects:(id)object, ...{
	va_list args;
	va_start(args, object); //表示从object开始 后面的参数都会存在va_list中
	return [self customPerformSelector:aSelector withObjects:object orVAList:args];
	va_end(args);
}
```



38.在 iOS中可以直接调用某个对象的消息方式有两种

一种是performSelector:withObject；
再一种就是NSInvocation。
第一种方式比较简单，能完成简单的调用。但是对于>2个的参数或者有返回值的处理，那performSelector:withObject就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。

NSInvocation的基本使用

```
方法签名类

// 方法签名中保存了方法的名称/参数/返回值，协同NSInvocation来进行消息的转发
// 方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系
//1、根据方法来初始化NSMethodSignature
NSMethodSignature  *signature = [ViewController instanceMethodSignatureForSelector:@selector(run:)];
根据方法签名来创建NSInvocation对象

// NSInvocation中保存了方法所属的对象/方法名称/参数/返回值
//其实NSInvocation就是将一个方法变成一个对象
//2、创建NSInvocation对象
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
//设置方法调用者
invocation.target = self;
//注意：这里的方法名一定要与方法签名类中的方法一致
invocation.selector = @selector(run:);
NSString *way = @"byCar";
//这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd)
[invocation setArgument:&way atIndex:2];
//3、调用invoke方法
[invocation invoke];
//实现run:方法
- (void)run:(NSString *)method{

}
优化

但是上述方法有很多弊端，首先我们来一一解决

1、如果调用的方法不存在

//此时我们应该判断方法是否存在，如果不存在这抛出异常
if (signature == nil) {
//aSelector为传进来的方法
NSString *info = [NSString stringWithFormat:@"%@方法找不到", NSStringFromSelector(aSelector)];
[NSException raise:@"方法调用出现异常" format:info, nil];
    }
2、方法的参数个数与外界传进来的参数数组元素个数不符

//此处不能通过遍历参数数组来设置参数，因为外界传进来的参数个数是不可控的
//因此通过numberOfArguments方法获取的参数个数,是包含self和_cmd的，然后比较方法需要的参数和外界传进来的参数个数，并且取它们之间的最小值
NSUInteger argsCount = signature.numberOfArguments - 2;
NSUInteger arrCount = objects.count;
NSUInteger count = MIN(argsCount, arrCount);
for (int i = 0; i < count; i++) {
    id obj = objects[i];
    // 判断需要设置的参数是否是NSNull, 如果是就设置为nil
    if ([obj isKindOfClass:[NSNull class]]) {
        obj = nil;
    }
[invocation setArgument:&obj atIndex:i + 2];
}
3、判断当前调用的方法是否有返回值

//方法一：
id res = nil;
if (signature.methodReturnLength != 0) {//有返回值
    //将返回值赋值给res
    [invocation getReturnValue:&res];
}
return res;

//方法二：
//可以通过signature.methodReturnType获得返回的类型编码，因此可以推断返回值的具体类型
```



39.调用三点符号方法的时候 如果后面没有参数了 也要加上nil传入



40.pch 文件

http://www.jianshu.com/p/e6e0e3bbbf38

1.)  打开你的Xcode工程. 在Supporting Files目录下,选择 File > New > File > iOS > Other > PCH File 然后点击下一步；

2.) 假设你的项目名称为TestDemo, 你的PCH 文件的名字应该为 TestDemo-Prefix.pch,然后创建；




3.) 选择 PCH 文件(文章的示例文件为 TestDemo-Prefix.pch) ,可以看到里面的内容如下:


4.) 找到 Project > Build Settings > 搜索 “Prefix Header“；

5.) “Apple LLVM 7.0 -Language″ 栏目中你将会看到 Prefix Header 关键字；

6.) 输入: TestDemo/TestDemo-Prefix.pch (如 TestDemo/TestDemo-Prefix.pch )；

7.)，将Precompile Prefix Header为YES，预编译后的pch文件会被缓存起来，可以提高编译速度。效果如下


8.) Clean 并且 build 你的项目.

就是这样！Done！现在你可以使用你的 PCH 文件就像你使用老版本的Xcode一样了



41.未释放问题 webView引用循环



    [Jockey on:@"toggle-talk-with-callback" performAsync:^(UIWebView *webView, NSDictionary *payload, void (^complete)()) {
        NSString *text = [payload objectForKey:@"text"];
        NSDictionary *param = @{@"response": [NSString stringWithFormat:@"你说：%@  我回答什么好呢?",text]};
        [Jockey send:@"toggle-talk-response" withPayload:param toWebView:weakSelf.webView];
    }];

Jockey 开辟的on监听会去持有内部block  所以，block内部一定不能使用self  而需要弱化。否则控制器（self）无法释放。

42.  打印内存地址 

    int i = 1;
    NSLog(@"%p + out",&i);

    ​

43.引用计数

CFGetRetainCount

44.IOS 存放地址

iphone沙盒  documents，tmp，Library。数据分别存放位置以及存储方式

```
1、Documents 目录：您应该将所有de应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。

2、Library 目录：这个目录下有两个子目录：Caches 和 Preferences
	Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.
	Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。

3、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。
```

获取路径方法

```
1、获取沙盒主目录路径的函数
NSString *homeDir = NSHomeDirectory();
2，获取Documents目录路径的方法：
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
3，获取Caches目录路径的方法：
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *cachesDir = [paths objectAtIndex:0];
4，获取tmp目录路径的方法：
NSString *tmpDir = NSTemporaryDirectory();
5，获取应用程序程序包中资源文件路径的方法：
例如获取程序包中一个图片资源（apple.png）路径的方法：
NSString *imagePath = [[NSBundle mainBundle] pathForResource:@”apple” ofType:@”png”];
UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath];
代码中的mainBundle类方法用于返回一个代表应用程序包的对象。
```



45.xcode 存放地址

xcode的preference中有Locations 可以查看DerivedData地址和Archives地址

1、xcode项目缓存地址 DerivedData

2、自定义代码块地址

/Users/username/Library/Developer/Xcode/UserData/CodeSnippets

46.xcode代码块、代码块文件 导出





47.当合并代码出现很奇怪也不太会出现的问题时候，特别比如提交podspec的时候，考虑是不是更改了文件目录，检查是不是有文件问题



48.alias in mac 

```
1.创建了一个 ~/.bash_aliases 文件，专门用来管理alias 例如内部加上如下几个别名:

alias gs='git push'
alias gp='git push'
alias pi='pod install'
alias pu='pod update --no-repo-update'

2.在 ~/.bash_profile 中编译这个文件 : 加入下面代码
test -f ~/.bash_aliases && source ~/.bash_aliases

3.重启终端

这样操作方便管理，同时 如果更换电脑也不需要一个个重新设置
```

49.xcode release  和 debug 打包

Scheme -> Edit Scheme -> Run

![](https://xilankong.github.io/resource/xcode_2.png)

以上呢就是这两种模式的切换方法，这样做呢就可以在开发阶段输出我们想要查看的信息，发布的时候更为应用节省了一些硬件设备的资源，不过在Xcode中默认的开发环境都是debug模式的。
到这里呢在补充一点，在Xcode中我们怎么确定当前到底是不是debug模式呢？好，我们继续看下面：

首先确定下项目里Build Setting是否已经设置过宏定义debug,如何看呢？点击Build Setting ,然后在搜索框里输入macros，如下图：

![](https://xilankong.github.io/resource/xcode_1.png)

如果已经设置过，在 Preprocessor Macros 的 Debug 后面会有 DEBUG=1，如果没有，就手动设置下。
接下来就可以这样做了, swift  oc 通用

```
#if DEBUG
    print("00000")
#else
    print("11111")
#endif
```



50.IOS 签名

```
1.非对称加密

非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法

甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。

非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。
 
非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。
```





51.引用计数  ----关于内存/引用计数这一块 还需要继续学习。

1.引用计数(retainCount) 规定:只要引用计数为零,对象就会被释放

2.alloc, new, copy, mutableCopy 根据编译器的约定，这以这四个单词开头的方法都会使引用计数加一

当我们使用alloc、new或者copy的我们需要销毁这个对象。release函数，只是将对象的retainCount值减1，并不是删除对象。当retainCount==0的时候，系统会发给对象一个dealloc消息，另外：千万不要手动调用dealloc，因为我们不知道何时，何地，何人还会使用该对象。应该老老实实依赖引用计数机制完成内存管理。    释放对象所有权的函数除了release还有autorelease，这是一种延迟操作。

3.字符串常量，系统不会收回，也不会对其作引用计数 （retainCount方法的实现返回的是maxIntValue）

4.weak assign 并不会增加引用计数，assign 释放的时候并不会置为nil  weak 会

NSLog(@"assign属性：%@",self.assignPoint); //在释放后调用打印assign

当assign指针所指向的内存被释放（释放并不等于抹除，只是引用计数为0），不会自动赋值nil，这样再引用self.assignPoint就会导致野指针操作，如果这个操作发生时内存还没有改变内容，依旧可以输出正确的结果，而如果发生时内存内容被改变了，就会crash。

SO：在ARC模式下编程时，指针变量一定要用weak修饰，只有基本数据类型和结构体需要用assgin



```
参数的弱化：

1、__strong 和 __weak 对 self做了什么？

如下 ：
__weak __typeof(self)weakself = self;
[NSTimer timerWithTimeInterval:1.0 target:weakSelf selector:@selector(get) userInfo:nil repeats:YES];

新的一个指针 指向self的内存地址，并使用弱化引用。经常在block外部定义，内部使用，因为block的异步执行问题，如果直接使用self 会出现释放问题，两者都强引用了对方。而使用weak ，一旦weakself对象被释放，weakself就会被置为nil，不会crash。

2、如果strong的 delegate  为什么把弱化的self 设成代理依然循环引用

因为例如 NSTime的方法，target对应的代理设置的是防丢失的strong，导致weakself再次被强化引用。这种情况的释放需要用到YYWeakProxy

3、weak和assign都不会增加引用计数，区别是修饰的对象在释放时所做的操作不同，weak是会把对象置为nil，assign则不会，assign一般适用与基本数据类型


在 swift中如何处理这些问题
```

自动释放池 autoreleasepool

    自动释放池是NSAutoreleasePool的实例，其中包含了收到autorelease消息的对象。当一个自动释放池自身被销毁（dealloc）时，它会给池中每一个对象发送一个release消息（如果你给一个对象多次发送autorelease消息，那么当自动释放池销毁时，这个对象也会收到同样数目的release消息）。可以看出，一个自动释放的对象，它至少能够存活到自动释放池销毁的时候。

52.

```
避免对 可选类型 强解包

If you have an identifier foo of type FooType? or FooType!, don't force-unwrap it to get to the underlying value (foo!) if possible.

如果你有个 FooType? 或 FooType! 的 foo，尽量不要强行展开它以得到基本类型（foo!）。

理由： if let 绑定可选类型产生了更安全的代码，强行展开很可能导致运行时崩溃。




if let x = foo {
    // Use unwrapped `x` value in here
} else {
    // If appropriate, handle the case where the optional is nil
}

这一段的重要性，直接在if块解包 
少用强解

if let rateString = dic?["incomeRate"] as? String  {
  let rate = NSString(string: rateString).floatValue
}
比较
let rate  = NSString(string: incomeRate!).floatValue //可能出现转换失败导致的崩溃



```



53.半透明遮罩抠透明区域

```
 UIBezierPath *path = [UIBezierPath bezierPathWithRect:view.frame];
[path appendPath:[[UIBezierPath bezierPathWithRoundedRect: CGRectMake((UIScreenMainScreenWidth -200) * 0.5, (UIScreenMainScreenHeight -200) * 0.5 -100, 200,200) cornerRadius:0] bezierPathByReversingPath]];
CAShapeLayer *shapeLayer = [CAShapeLayerlayer];
shapeLayer.path = path.CGPath;
view.layer.mask = shapeLayer

let path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: App.screenWidth, height: App.screenHeight))
path.append(UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 100, height: 100), cornerRadius: 15).reversing())
let shapeLayer = CAShapeLayer()
shapeLayer.path = path.cgPath
self.view.layer.mask = shapeLayer
```



54.在tableView上浮键盘的时候，点击cell会隐藏键盘，但是手势会影响tableView点击事件

```
响应链机制  http://ios.jobbole.com/86425/
```





55.swift 创建view xib如何绑定



56.swift 的构造方法到底是如何实现

 public init(dic: Any) 



57.

```
问题，需要满足小屏幕滚动，大屏幕尽量一屏显示
```

58.绘制很细的实、虚线

```
            //横线
            UIBezierPath *path = [UIBezierPath bezierPath];
            path.lineWidth =  0.5;
            [path moveToPoint:CGPointMake(0, 0)];
            [path addLineToPoint:CGPointMake(self.bounds.size.width,0)];
            
            CAShapeLayer *layer = [[CAShapeLayer alloc] init];
            layer.masksToBounds = YES;
            layer.frame = CGRectMake(0, self.frame.origin.y + space * idx, self.frame.size.width, 1.0/[UIScreen mainScreen].scale);
            layer.lineWidth =  0.5;
            layer.path = path.CGPath;
            layer.strokeEnd = 1.0;
            layer.fillColor = [UIColor whiteColor].CGColor;
            layer.strokeColor = [UIColor colorWithRed:0.85 green:0.85 blue:0.85 alpha:1.0].CGColor;
            layer.lineDashPattern = @[@2, @1];
            [self addSublayer:layer];
            
            用图片
```

59 guard 的使用

```
        guard let xAxis = xAxis, !xAxis.isEmpty  else {
            return ""
        }
```

60.手势冲突



61.UIViewController 自动寻找xib的原理 。就是[[UIViewController alloc]init] 为什么会自动加载XIB 

```
每次访问UIViewController的view(比如controller.view、self.view)而且view为nil，loadView方法就会被调用。 前提是 view 的UIViewController 不为空。

作用：

loadView方法是用来负责创建UIViewController的view  也就是我们可以用来自定义VC 的View

如果我们没有重载这个方法。它会调用 【super loadView】;返回一个View .里面实现为：

1> 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view

如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件
[[MJViewController alloc] initWithNibName:@"MJViewController" bundle:nil];  
如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件
[[MJViewController alloc] init]; // 加载MJViewController.xib  
2> 如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下

self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];  
// applicationFrame的值是：x = 0, y = 20  width = 320, height = 460
 
[super loadView]里面就大致完成1>和2>中叙述的内容

 
大家都知道UIViewController的view可以通过xib文件来创建，但是在某些情况下，xib不是那么地灵活，所以有时候我们想通过代码来创建UIView，比如：

self.view = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];  
 如果想通过代码来创建UIViewController的view，就要重写loadView方法，并且不需要调用[super loadView]，因为在第3点里面已经提到：若没有xib文件，[super loadView]默认会创建一个空白的UIView。我们既然要通过代码来自定义UIView，那么就没必要事先创建一个空白的UIView，以节省不必要的开销。正确的做法应该是这样：

- (void)loadView {  
     self.view = [[[UIWebView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame] autorelease];  
}  
 
不需要调用[super loadView]，你调用了也不会出错，只是造成了一些不必要的开销。

总结一句话，苹果设计这个方法就是给我们自定义UIViewController的view用的
```

62.github pages 中 md文件里不能写双花括号





63.

```
动态类型，说简单点就是id类型。动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(run time)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。

动态绑定(dynamic binding)貌似比较难记忆，但事实上很简单，只需记住关键词 @selector/SEL 即可。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。这里要注意一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。

简单的说 [a someFunc] 这样一个调用，在编译阶段，编译器并不知道someFunc要执行哪段代码。这个时候[a someFunc]会被转换为 objc_msgSend(a, "someFunc")，字面的意思也很容易理解，就是给a这个instance，发“someFunc”这个消息，以selector的形式。在运行阶段，执行到上述的objc_msgSend这个函数时。函数内部会到a对应的内存地址，寻找someFunc这个方法的地址，并执行。如果找不到，就会抛一个“unknown selector sent to instance”的异常。（比如.h中声明了方法，但.m中没有实现，就可以重现这个错误） 所以严格意义上来将，任何Objective C的函数调用，编译阶段的表现，都只能算一种“发消息”的行为。
```

64. URL TYPES

    ```
    http://www.jb51.net/article/83266.htm
    ```

    ​

65 ssh key 问题，ssh-keygen -t rsa -C "your email " 更新账户，会要求输入密码和确认密码，如果不需要就直接回车，然后把生成的public key 拷贝存放到 gitlab ssh key 存放处



66 swift 获取 debug  release



在target下 Build Settings 搜索 Other [Swift](http://lib.csdn.net/base/swift) Flags

设置Debug 添加 -D DEBUG,注意不要好Release一起添加

使用方式和oc下一样

\#if DEBUG // 判断是否在[测试](http://lib.csdn.net/base/softwaretest)环境下

​    // TODO

\#else

​    // TODO

\#endif























1. UITextView 中的文字默认并不是从最上面开始，在 UITextView 所在的 UIViewController中添加：

   ```
   self.automaticallyAdjustsScrollViewInsets = false;
   ```

2. UIButton 在边缘的时候没有高亮响应，重写 UIButton 的 pointInside函数：

   ```
   /**
        解决按钮在边缘的时候被按下时没有显示高亮

     - parameter point: 按下的位置
     - parameter event: 目标事件

     - returns: 是否在内部
     */
    override func pointInside(point: CGPoint, withEvent event: UIEvent?) -> Bool {

        let inside = super.pointInside(point, withEvent: event)

        if inside != highlighted && event?.type == .Touches {
            highlighted = inside
        }

        return inside
    }
   ```

   *PS：如果遇到需要这样的情况下，最好继承 UIButton 重写该函数，而不是extension UIButton，因为这样会使工程中用到的所有的 UIButton 都被重写。*

3. 静音模式下播放音频，最好在`didFinishLaunchingWithOptions`中进行调用

   ```
   /**
        静音模式下仍可以播放音频
    */
    public class func playInQuietMode() {

        let audioSession: AVAudioSession = AVAudioSession.sharedInstance()

        do {
            try audioSession.setCategory(AVAudioSessionCategoryPlayback)
        } catch let error as NSError{
            print(error)
        }

        do {
            try audioSession.setActive(true)
        } catch let error as NSError{
            print(error)
        }
    }
   ```

4. 自定义 UITableViewCell 选中时的颜色

   ```
   /**
        设置选中背景色

     - parameter color: 背景色
     */
    public func setSelectColor(color: UIColor) {

        let backgroundView = UIView();
        backgroundView.backgroundColor = color;
        self.selectedBackgroundView = backgroundView;
    }
   ```

   *PS：self.selectionStyle的值不能为.None。*

5. 给 UIView 添加阴影

   ```
   /**
        添加阴影

     - parameter color:  阴影颜色
     - parameter offset: 阴影偏移
     */
    public func addShadow(color: UIColor, offset: CGFloat) {

        self.layer.shadowColor = color.CGColor;
        self.layer.shadowOffset = CGSizeMake(-offset, offset);
        self.layer.shadowOpacity = 0.8;
        self.layer.shadowRadius = offset;
    }
   ```

6. 震动

   ```
   /**
        震动,在真机上：设置/声音 中开启响铃/震动选项开启后才能震动
    */
    public class func shark() {
        AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate));
    }
   ```

7. 打开 iPod

   ```
   /**
        打开 iPod
     */
    public class func openIpod() {

        UIApplication.sharedApplication().openURL(NSURL(string: "music://")!);
    }
   ```

8. App 国际化时，有时我们第一次安装APP时不想默认跟随系统，那么可以通过Xcode的scheme来指定特定语言

   ![img](http://upload-images.jianshu.io/upload_images/808722-afcf990628be3300?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

9. 让 UITableView 在没有数据时不能滚动

   ```
   override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {

        self.tableView.scrollEnabled = (data.count > 0);

        return data.count;
   }
   ```

10. 应用内打开其他 App
 在`Info.plist`文件中设置`URL types`：

 ![img](http://upload-images.jianshu.io/upload_images/808722-38849dae1f4bdbf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 之后就可以使用下面的模式来发送一个URL：

 ```
 myapp://
 myapp://some/path/here
 myapp://?foo=1&bar=2
 myapp://some/path/here?foo=1&bar=2
 ```

 然后，App 的`UIApplicationDelegate`会收到一个消息。若你想自己处理该URL，可以重载下面这个方法：

 ```
 func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool {
 }
 ```

11. App 播放视频时进入后台让视频继续播放，有两种方法可以实现：

    第一种、 对目标视频对象的视频轨进行以下处理： 

    ```
    let playerItem = AVPlayerItem(URL: NSURL(string: "videoUrl")!);
    let tracks = playerItem.tracks;
    for track in tracks {
    if (track.assetTrack.hasMediaCharacteristic(AVMediaCharacteristicVisual)) {
        track.enabled = false;
    }
    }
    ```

    第二种、 在进入后台前将目标视频渲染层设为 `nil`，在恢复到前台时重新设置：

    ```
    func applicationDidEnterBackground(application: UIApplication) { 
    let playerView = "Get your player view"; 
    playerView.playerLayer.player = nil; 
    }
    func applicationDidBecomeActive(application: UIApplication) {
    let playerView = "Get your player view";
    playerView.playerLayer.player = player;
    }
    ```

12. 获取视频的每秒帧数 `fps` 和 视频的长度 `duration`：

    ```
    let asset = AVAsset(URL: NSURL(fileURLWithPath: "videoPath"));
    let fps = asset.tracksWithMediaType(AVMediaTypeVideo)[0].nominalFrameRate;
    let duration = CMTimeGetSeconds(asset.duration);
    ```

13. App 进入后台仍然继续运行：

    ```
    public func applicationDidEnterBackground(application: UIApplication) {

        application.beginReceivingRemoteControlEvents();

        var bgTask : UIBackgroundTaskIdentifier?
        bgTask = application.beginBackgroundTaskWithExpirationHandler {
            dispatch_async(dispatch_get_main_queue(), {
                if bgTask != UIBackgroundTaskInvalid
                {
                    bgTask = UIBackgroundTaskInvalid
                }
            })
        }

        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
            dispatch_async(dispatch_get_main_queue(), {
                if bgTask != UIBackgroundTaskInvalid
                {
                    bgTask = UIBackgroundTaskInvalid
                }
            })
        }
    }
    ```

14. App 运行中不锁屏：

    ```
    UIApplication.sharedApplication().idleTimerDisabled = true;
    ```

15. 禁止 `oc` 文件使用 `ARC`：`-fno-objc-arc`

16. 禁止 `UIButton` 在按下时有动态阴影：

    ```
    button.adjustsImageWhenHighlighted = false;
    ```

17. 隐藏导航栏的返回按钮：

    ```
    self.navigationItem.hidesBackButton = true;
    ```

18. 隐藏导航栏下影线：

    ```
    self.navigationController?.navigationBar.shadowImage = UIImage();
    ```

19. 设置导航栏中间为图片：

    ```
    self.navigationItem.titleView = UIImageView(image: UIImage(named: "titleImage"));
    ```

20. 机型与屏幕尺寸的对应：

    - 4s_3.5inch
    - 5s_4inch
    - 6_4.7inch
    - 6+_5.5inch

21. 模拟器截图时，必须设置分辨率为100%（Simulator > Window > Scale > 100%）

22. *UIView* 中添加定时器时导致内存泄露处理：

    ```
    override func willMoveToWindow(newWindow: UIWindow?) {
    super.willMoveToWindow(newWindow);
    if (newWindow == nil) {
        self.updateTimer.invalidate();
    }
    }
    ```

23. *UITextfiled* 设置 *placehold* 字体颜色：

    ```
    self.passwdTextIpt.attributedPlaceholder = NSAttributedString(string: NSLocalizedString("login_passwd", comment: ""), attributes: [NSForegroundColorAttributeName: UIColor(white: 1.0, alpha: 0.4)]);
    ```

24. 使用自定义字体

    1. 将目标字体拖入目标项目；

       ​

       ​

       ​

       F001.png

    2. 在 *Info.plist* 文件中设置目标字体；
       ![img](http://upload-images.jianshu.io/upload_images/808722-37c5ac313ecad416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
       F002.png

    3. 将字体添加到 *Copy Bundle Resources*；
       ![img](http://upload-images.jianshu.io/upload_images/808722-2fc9bcb342162d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
       F003.png

    4. 使用字体：`UIFont(name: fontname, size: fontsize);`

25. 设置 *UITextfiled* 文字偏移：

    ```
    self.userIdTextIpt.layer.sublayerTransform = CATransform3DMakeTranslation(10, 0, 0);
    ```

    或者重写 *UITextfiled* ：

    ```
    override func textRectForBounds(bounds: CGRect) -> CGRect {
    return CGRectInset(bounds, 44, 0);
    }
    override func editingRectForBounds(bounds: CGRect) -> CGRect {
    return CGRectInset(bounds, 44, 0);
    }
    ```

26. *UIImage* 显示与图片不同，设置其渲染模式即可：

    ```
    UIImage(named: imageName)!.imageWithRenderingMode(.AlwaysOriginal);
    ```

27. 设置状态栏背景样式无效：

    1. 在 `Info.plist` 文件中设置 `View controller-based status bar appearance` 为 `No`；
    2. 在 `Appdelegate.swift` 文件中设置 `UIApplication.sharedApplication().statusBarStyle = UIStatusBarStyle.Default;`

28. 隐藏导航栏返回按钮：

    ```
    self.navigationItem.hidesBackButton = true;
    ```

29. 使用 Cookie：

    ```
    let url = NSURL(string: url);
    guard let cookies = NSHTTPCookieStorage.sharedHTTPCookieStorage().cookiesForURL(url!) else {
    return
    }
    let header = NSHTTPCookie.requestHeaderFieldsWithCookies(cookies);
    let request = NSMutableURLRequest(URL: url!);
    request.addValue(header["Cookie"]!, forHTTPHeaderField: "Cookie");
    ```

30. 添加阴影

    ```
    view.layer.shadowColor = UIColor.blackColor().CGColor;
    view.layer.shadowOffset = CGSizeMake(0, 0);
    view.layer.shadowOpacity = 0.25;
    view.layer.shadowRadius = 6;
    ```

31. 检查 API 可用性

    ```
    if #available(iOS 9.0, *) { 
      let store = CNContactStore()
    } else { 
      // 旧版本的情况
    }
    ```

32. *swift* 中将 *Unmanaged<CGImage>* 转化为 *UIImage*

    ```
    let unCGimage:Unmanaged<CGImage> = defaultRepresentation.fullResolutionImage();
    let image = unCGimage.takeUnretainedValue())
    ```

33. *CADisplayLink* 使用完成后内存无法被释放：

    ```
    self.displaylink = CADisplayLink(target: self, selector: #selector(SCGifView.changeKeyFrame))
    self.displaylink?.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSRunLoopCommonModes)
    ```

    以上在我一个工程中使用到的，在测试的时候，发现其内存无法被释放，检查看发现需要手动调用以下代码来完成释放：

    ```
    self.displaylink?.removeFromRunLoop(NSRunLoop.mainRunLoop(), forMode: NSRunLoopCommonModes);
    self.displaylink?.invalidate();
    self.displaylink = nil;
    ```

34. 设置 *App* 沙盒内的 *Document* 文件夹可以被其他软件共享（各类手机助手）：
    在 *Info.plist* 文件中 添加 `Application supports iTunes file sharing`，并设置其值为 `YES`

35. 播放系统拍照时的 *咔嚓声*（本质就是播放系统声音）：

    ```
    let soundID: SystemSoundID = 1108;    //! 1108 就是拍照的系统声音编号，要播放其他的声音可以到网上搜索对应的编号
    AudioServicesPlayAlertSound(soundID);
    ```

36. `AudioServicesPlaySystemSound` 和 `AudioServicesPlayAlertSound` 的区别：

    1. `AudioServicesPlaySystemSound` 仅仅是播放系统声音，在静音模式下不播放； 
    2. `AudioServicesPlayAlertSound` 当设置了 `通用/声音/响铃模式振动`，播放系统声音并振动，否则只播放系统声音；当设置了 `通用/声音/静音模式振动`，振动，否则不播放系统声音。

37. 当 *UIButton* 即有文字又有图像时，只让图像旋转：

    ```
    let animation = CABasicAnimation(keyPath: "transform.rotation.z");
    animation.fromValue = NSNumber(float: 0);
    animation.toValue = NSNumber(double: 2 * M_PI);
    animation.duration = 3;
    animation.repeatCount = HUGE;
    button.imageView?.layer.addAnimation(animation, forKey: "scRotationAnimation");
    ```

38. 调用 *AVPlayer* 的 `seekToTime` 接口时间不对，将

    ```
    self.player!.seekToTime(CMTimeMakeWithSeconds(time, self.player!.currentItem!.currentTime().timescale));
    ```

    更换为：

    ```
    self.player!.seekToTime(CMTimeMakeWithSeconds(time, self.player!.currentItem!.currentTime().timescale), toleranceBefore: kCMTimeZero, toleranceAfter: kCMTimeZero);
    ```

39. 使用 `NSDateFormatter.dateFromString` 总是返回 `nil`，原因可能是你的时间格式是`12小时制而你的值是24小时制`，将 `hh:mm:ss` 改成 `HH:mm:ss`即可。

40. `swift` 中结构体与结构体指针的使用，`SMsgAVIoctrlSetPlayVolumeReq` 为结构体， `IOTYPE_USER_IPCAM_AUDIO_PLAY_VOLUME_SETTING_REQ` 为枚举变量：

    ```
    let cmd = UnsafeMutablePointer<SMsgAVIoctrlSetPlayVolumeReq>(malloc(sizeof(SMsgAVIoctrlSetPlayVolumeReq)))
    cmd.memory.command_types_ = 1;
    cmd.memory.value_ = 1;  
    self.camera.sendIOCtrlToChannel(0, type: Int(IOTYPE_USER_IPCAM_AUDIO_PLAY_VOLUME_SETTING_REQ.rawValue), data: UnsafeMutablePointer<Int8>(cmd), dataSize: sizeof(SMsgAVIoctrlSetPlayVolumeReq))
        free(cmd)
    ```

41. 指针偏移

    ```
    let buf:UnsafePointer<UInt8> = CFDataGetBytePtr(rawData)
    var r:UInt8 = 0
    r = buf.advancedBy(i+0).memory
    ```

42. 字符串保留特定字符（以下例子保留字母）：

    ```
    let notAllowedCharactersSet = NSCharacterSet(charactersInString: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdedghijklmnopqrsquvwxyz").invertedSet
    let filterStr = (str.componentsSeparatedByCharactersInSet(notAllowedCharactersSet) as NSArray).componentsJoinedByString("")
    ```

43. [swift 的黑魔法](http://swifter.tips/swizzle/)

    ```
    extension UIButton {

    class func oyc_swizzleSendAction() {

        struct oyc_swizzleToken {
            static var onceToken : dispatch_once_t = 0
        }

        dispatch_once(&oyc_swizzleToken.onceToken) {

            let cls: AnyClass! = UIButton.self

            let originalSelector = #selector(sendAction(_:to:forEvent:))
            let swizzledSelector = #selector(oyc_sendAction(_:to:forEvent:))

            let originalMethod =
                class_getInstanceMethod(cls, originalSelector)
            let swizzledMethod =
                class_getInstanceMethod(cls, swizzledSelector)

            method_exchangeImplementations(originalMethod, swizzledMethod)
        }
    }

    public func oyc_sendAction(action: Selector, to: AnyObject!, forEvent: UIEvent!) {

        struct oyc_buttonTapCounter {
            static var count: Int = 0
        }

        oyc_buttonTapCounter.count += 1
        print(oyc_buttonTapCounter.count)
        oyc_sendAction(action, to: to, forEvent: forEvent)
    }

    override public class func initialize() {
        if self != UIButton.self {
            return
        }
        UIButton.oyc_swizzleSendAction()
    }
    }
    ```

44. `??` 操作符
    在 Swift 中，有一个非常有用的操作符，可以用来快速地对 `nil` 进行条件判断，那就是 `??` 。这个操作符可以判断输入并在当左侧的值是非 `nil` 的 *Optional* 值时返回其 *value*，当左侧是 `nil` 时返回右侧的值，比如：

    ```
    var level : Int?
    var startLevel = 1
    var currentLevel = level ?? startLevel
    ```

45. App 在启动界面停留特定时间：

    ```
    NSThread.sleepForTimeInterval(3.0);      // 3.0 表示 3 秒
    ```

46. swift 中根据字符串创建对象：

    ```
        //动态获取命名空间：
        let nameSpace = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"] as! String
        //根据命名空间和传过来的控制器名字获取控制器的类
        let controllerClass:AnyClass = NSClassFromString(nameSpace + "." + controllerName)!

        //告诉编译器真实的控制器类型，比如这个控制器本质是UITableViewController则：
        let realClass = controllerClass as! UITableViewController.Type

        //实例化这个控制器出来
        let childController = realClass.init()
    ```

47. `UIButton` 中的 `文本` 和 `图片` 默认是水平对齐

48. 使用 `单元测试` 时显示 `Module 'CTest' was not compiled for testing`：
    在 `Build Settings` 中 `Enable Testability` 设置为 `YES`

49. `Xcode 8` 控制台输出信息太多解决方法：`Edit Scheme` -> `Run` -> `Arguments`， 在 `Environment Variables` 里边添加 `OS_ACTIVITY_MODE`，值设置为 `disable`

    ![img](http://upload-images.jianshu.io/upload_images/1284335-ba4b0fa2139b3d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&_=5882304)

50. 设置 `WKWebView` 的字体大小：

    ```
        //创建网页配置对象
        let config = WKWebViewConfiguration();
        // 创建设置对象
        let preference = WKPreferences();
        // 设置字体大小(最小的字体大小)
        preference.minimumFontSize = 60;
        // 设置偏好设置对象
        config.preferences = preference;
        // 创建WKWebView
        let webView = WKWebView(frame: self.view.bounds, configuration: config);
        webView.loadHTMLString("<p>Some Text</p>", baseURL: nil)
        return webView;
    ```

51. `lazy` 属性本质上是一个闭包，闭包中的表达式只会调用一次。需要强调的是，虽然这个闭包中捕获了`self`，但是这样做并不会导致循环引用，猜测是 `swift` 自动把 `self` 标记为 `unowned` 了。

52. 给视图及之上的子控件添加阴影：

    ```
    let container = UIView();
    container.clipsToBounds = true;
    container.layer.cornerRadius = 5;
    container.layer.borderWidth = 1;
    container.layer.borderColor = UIColor.gray.cgColor;
    container.layer.shadowColor = UIColor.black.cgColor;
    container.layer.shadowOffset = CGSize(width: 4, height: 4);
    container.layer.shadowOpacity = 0.5;
    container.layer.shadowRadius = 3;
    return container;
    ```

53. 从项目中删除了某个目录、文件以后，编译出现警告信息：
    `ld: warning: directory not found for option“XXXXXX”`
    解决办法：

    1. 选择工程，选中 `TARGETS` 中的目标工程
    2. 选择 `Build Settings` 菜单
    3. 查找 `Library Search Paths` 和 `Framework Search Paths`，删掉编译报 `warning` 的路径即可。

54. 统一收起键盘：

    ```
    UIApplication.shared.keyWindow?.endEditing(true);
    ```

55. 动态创建控制器

    ```
    let vcs = [RunLoopViewController.self, CDrawViewController.self] as [UIViewController.Type];
    let vc = self.vcs[indexPath.row].init()    // 创建控制器
    let vcString = NSStringFromClass(self.vcs[indexPath.row])    //
    ```

56. 设置 `UITableView` 中的 `cell` 的`分隔线`铺满整个 `cell`

    ```
    let stView = UITableView();
    stView.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0);
    ```

57. 动态修改 tableFooterView 的高度

    ```
    self.footview.frame = CGRect(x: 0, y: 0, width: self.view.bounds.width, height: heightOfFooterView);
    self.tableView.tableFooterView = self.footview;    // 需要重新给 tableFooterView 赋值
    ```

58. 获取 `UILabel` 设置 `text` 后的大小：

    ```
    label.intrinsicContentSize
    ```

59. `UIButton` 添加子视图后无法响应事件的处理：

    ```
    let btn = UIButton();
    let subView = UIView(frame: btn.bounds);
    subView.isUserInteractionEnabled = false;     // 将子视图的用户交互禁止，这样 UIButton 就能继续响应事件
    btn.addSubview(subView);
    ```

60. 使用 `UISearchController` 导致的黑屏问题，在使用 `UISearchController` 的 `UIViewController` 的 `viewDidLoad` 添加：

    ```
    self.definesPresentationContext = true
    ```

61. 自定义 `UISearchBar` 中的 `UITextField` 无效：必须确保 `UISearchBar` 的 `searchBarStyle` 为 `prominent` ，当其值为 `minimal` 时，自定义 `UITextField` 无效。

62. 子控件（比如按钮）超出父视图部分无法响应事件，在父视图添加以下代码（其思路是遍历父视图的所有子视图，并判断触发事件的点是否在子视图的bounds内如果在就返回这个子视图。）：

    ```
    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
    var view = super.hitTest(point, with: event);
    guard view == nil else { return view }
    for subView in self.subviews {
        let p = subView.convert(point, from: self);
        if subView.bounds.contains(p) {
            view = subView;
        }
    }
    return view;
    }
    ```

63. `Xcode` 无法在高于某系统的真机上运行：`This iPhone 6 is running iOS 10.1 (14B55或者14B72), which may not be supported by this version of Xcode`：
    把升级包放在路径：`应用程序（xcode）-右键-显示包内容  /Developer/Platforms/iPhoneOS.platform/DeviceSupport`

64. 在控制器 `A` 中，`push` 展示 控制器 `B`，这时要隐藏控制器 `B` 的返回按钮的文本，需要在控制器 `A` 中添加以下代码，而不是在控制器 `B` 中，因为 控制器 `B` 中的返回按钮实际是控制器 `A` 的：

    ```
    self.navigationItem.backBarButtonItem = UIBarButtonItem(title:"", style:.plain, target:nil, action:nil)
    ```

65. 设置导航栏标题：

    方式一：

    ```
    self.title = "标题"          // 当控制器处于 UITabbarViewController 中时，对应的 Tabbar 项也会显示该标题
    ```

    方式二：

    ```
    self.navigationItem.title = "标题"          // 这样设置的话，即使当控制器处于 UITabbarViewController 中时，对应的 Tabbar 项也不会显示该标题
    ```

66. 设置导航栏返回按钮图片：在创建导航栏的时候添加以下代码

    ```
    // 绘制图片，主要是原始图片问题，可以跳过此步
    UIGraphicsBeginImageContextWithOptions(image.size, false, 0)
    image.draw(at: CGPoint(x: -10, y: 10))
    var backImage = UIGraphicsGetImageFromCurrentImageContext()!
    UIGraphicsEndImageContext()
    // 设置渲染模式，不设置的话，会使用系统默认颜色
    backImage = backImage.withRenderingMode(.alwaysOriginal);
    // 设置返回按钮图片
    self.navigationController?.navigationBar.backIndicatorImage = backImage;
    self.navigationController?.navigationBar.backIndicatorTransitionMaskImage = backImage;
    ```

67. `UITableViewCell` 被点击时，`subviews` 消失，这是因为当 `UITableViewCell` 被点击时会改变它内部的 `subviews` 的背景色，因此重写 `UITableViewCell` 以下两个方法即可：

    ```
    override func setSelected(_ selected: Bool, animated: Bool) {
    super.setSelected(selected, animated: animated)
    guard selected else { return }
    subview.backgroundColor = subviewColor
    }
    override func setHighlighted(_ highlighted: Bool, animated: Bool) {
    super.setHighlighted(highlighted, animated: animated)
    guard highlighted else { return }
    subview.backgroundColor = subviewColor
    }
    ```

68. `swift 3` 之后，函数有返回值没有被使用的时候会报警告，在该函数前加 `@discardableResult` 可以让编译器不报警告

69. `GCD`

    1. 串行
       - 同步,则在当前线程中按顺序执行(此处当前线程为主线程),同时阻塞当前线程
       - 异步,新开线程,但仅新开一个线程,所有执行的任务都在同一个新开的线程中顺序执行,不会阻塞当前线程
    2. 并发
       - 同步,则在当前线程中顺序执行(此处当前线程为主线程),同时阻塞当前线程。（这个运行结果和串行队列，同步执行是一模一样的。 因为同步任务的概念就是按顺序执行，后面都要等。言外之意就是不允许多开线程。 同步和异步则是决定开一条还是开多条。）
       - 异步,每一个 async 新开一个线程（也可能多个 async 共有一个线程，具体看系统分配）并发执行,不会阻塞当前线程
    3. 总结
       - 同步/异步决定开不开新线程；
       - 只有并发异步内的任务是并发执行的；
       - 其他的都是顺序执行；

70. 使用 `for in` 操作序列：

    ```
    // 只对非 nil 值进行循环
    for case let item? in seq { 
    // i 将是 Int 值,而不是 Int? 
    print(item)
    }
    或
    for case let .some(item) in seq { 
    // i 将是 Int 值,而不是 Int? 
    print(item)
    }
    // 只对 nil 值进行循环 
    for case nil in seq { 
    // 将对每个 nil 执行一次
    print("No value") 
    }
    ```







- 创建项目时记得勾选『include Unit Tests』

![011.png](http://cc.cocimg.com/api/uploads/20151124/1448355481913832.png)

在项目创建时如果直接选择了包含单元测试是最方便的了。Xcode7 中的 UI 自动测试已经很完善，建议『include UI Tests』也一起选上。

- 已有项目，可以通过添加 target 的方式添加

![012.png](http://cc.cocimg.com/api/uploads/20151124/1448355504907178.png)

选择 iOS Unit Testing Bundle

![013.png](http://cc.cocimg.com/api/uploads/20151124/1448355510545176.png)

在 Test 分类下选择

- 添加测试文件

在单元测试项目下，新建文件，选择 source 下的 Unit Test Case Class。

tips：如果几个test case都有一些共同的数据或逻辑，可以自己新建一个 test case 的基类，然后每个分别继承.

![014.png](http://cc.cocimg.com/api/uploads/20151124/1448355547421668.png)

- 将要测试的 module 导入到 test case 中

import 完你需要测试的项目名称后，就可以在这个类里欢快的调用里面的类了。

![015.png](http://cc.cocimg.com/api/uploads/20151124/1448355601449094.png)

使用 cocoapods 的同学注意了

在 import 完后很可能你的 swift『Bridging-Header.h』桥接文件会报如下的错：

failed to import bridging header 或者 SDWebImage/UIImageView+WebCache.h File Not Found Error

可能你不愿接受这个现实，clean了项目，重新build，或者重启了计算机。在模拟器中运行你的项目时心里默念：刚才还是好好的啊，明明能正常运行，为什么有错误！

是的。为此我已经抓掉了不少头发。

原因是：unit tests 是个单独的项目，所以一些项目配置必须重新配置一遍

![016.png](http://cc.cocimg.com/api/uploads/20151124/1448355665601747.png)

在编辑区中选择 Tests 项目，在 build setting 中配置

因为Swift的桥接文件很可能在你第一次创建 Swift 类时 Xcode 自动帮你配置了项目，你可能没有意识到 build setting 其实已经更改了。

可以参照着自己项目的配置来重新配置一次。

![017.png](http://cc.cocimg.com/api/uploads/20151124/1448355687678423.png)

可以参考这个链接下的回答：[http://stackoverflow.com/questions/26116288/failed-to-import-bridging-header](http://stackoverflow.com/questions/26116288/failed-to-import-bridging-header)

cocoapods 同理，其实已经默认帮你配置了不少 search paths，自己手动贴进去吧，主要是下面这几个选项.

![018.png](http://cc.cocimg.com/api/uploads/20151124/1448355707798236.png)

还差最后一步：Enable Testability

一切类都配置到项目后又出现了这个错误：

'Module was not compiled for testing'

在原来的项目里配置 Enable Testability 为 Yes

![019.png](http://cc.cocimg.com/api/uploads/20151124/1448355725191419.png)

现在你就真的可以愉快的在 test case 中快活的测试任意一个项目中的类了



IOS 11 UITableView：默认开启Self-Sizing

大概就是说我们不再需要自己去计算cell的高度了，只要设置好这两个属性，约束好布局，系统会自动计算好cell的高度。IOS11以后，Self-Sizing默认开启，包括Headers, footers。如果项目中没使用estimatedRowHeight属性，在IOS11下会有奇奇怪怪的现象，因为IOS11之前，estimatedRowHeight默认为0，Self-Sizing自动打开后，contentSize和contentOffset都可能发生改变。可以通过以下方式禁用：

self.tableView.estimatedRowHeight = 0; 
self.tableView.estimatedSectionHeaderHeight = 0; 
self.tableView.estimatedSectionFooterHeight = 0;



# IBDesignable和IBInspectable（xcode的所见即所得）

https://www.jianshu.com/p/83161b02b792



堆栈

## iOS数据存储类型 及 堆(heap)和栈(stack)

 

### 一般认为在c中分为这几个存储区：

**1栈** --  由编译器自动分配释放。
**2堆** --  一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。
**3全局区（静态存储区）**-- 全局变量和静态变量的存储是放在一块区域 ，程序退出后自动释放 。全局区又分为全局初始化区和全局未初始化区。初始化的全局变量和静态变量存放在全局初始化区，未初始化的全局变量和未初始化的静态变量存放在相邻的另一块区域。

**4常量区**-- 专门放数字/字符常量的地方， 程序退出后自动释放 。

在函数体中定义的自动变量通常是在**栈上**，

用malloc, calloc, realloc等分配内存的函数分配得到的就是在**堆上**。

加了static修饰符后不管在哪里都存放在**全局区**（静态存储区）。

在所有函数体外定义的是全局变量，存储在**全局区**（静态存储区），在整个C程序所有源文件中通过extern声明后都可用。

在所有函数体外定义的static全局变量存储在**全局区**（静态存储区），只在该文件中有效，不能extern声明到别的文件用。

在函数体内定义的static静态变量存储在**全局区**（静态存储区），表示只在该函数体内有效，但是其生命周期却变为和整个程序同生同死。

另外，函数中的"adgfdf"这样的字符串存放在**常量区**。 
代码: 
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
main() 
{ 
int b; //栈 
char s[] = "abc"; //栈 
char *p2; //栈 
char *p3 = "123456";  //123456\0在常量区，p3在栈上。 
static int c = 0； //全局（静态）初始化区 
p1 = (char *)malloc(10);   //分配得来的10 字节的区域就在堆区。 
p2 = (char *)malloc(20);  //分配得来的 20字节的区域就在堆区。 
strcpy(p1, "123456");   //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块。 
} 
函数调用时会在栈上有一系列的保留现场及传递参数的操作。 栈的空间大小有限定，VC的缺省是2M。栈不够用的情况一般是程序中分配了大量数组和递归函数层次太 深。有一点必须知道，当一个函数调用完返回后它会释放该函数中所有的栈空间。栈是由编译器自动管理的，不用你操心。 

堆是动态分配内存的，并且你可以分配使用很大的内存。但是用不好会产生内存泄漏。 并且频繁地malloc和free会产生内存碎片（有点类似磁盘碎片），因为c分配动态内存时是寻找匹配的内存的。而使用栈则不会产生碎片。

一般大家说的堆栈和栈是一样的，就是栈(stack)，而说堆时才是堆heap。在栈上存取数据比通过指针在堆上存取数据快些。 栈是先入后出的，一般是由高地址向低地址生长。 
堆(heap)和栈(stack)是C/C++编程不可避免会碰到的两个基本概念。

栈是机器系统提供的数据结构，而堆则是C/C++函数库提供的。 
具体地说，现代计算机(串行执行机制)，都直接在代码底层支持栈的数据结构。这体现在，有专门的寄存器指向栈所在的地址，有专门的机器指令完成数据入栈出栈的操作。 
这种机制的特点是效率高，支持的数据有限，一般是整数，指针，浮点数等系统直接支持的数据类型，并不直接支持其他的数据结构。因为栈的这种特点，对栈的使用在程序中是非常频繁的。

 C/C++中的自动变量是直接利用栈的例子，这也就是为什么当函数返回时，该函数的自动变量自动失效的原因。 
和栈不同，堆的数据结构并不是由系统(无论是机器系统还是操作系统)支持的，而是由函数库提供的。 
基本的malloc/realloc/free函数维护了一套内部的堆数据结构。当程序使用这些函数去获得新的内存空间时，这套函数首先试图从内部堆中寻找可用的内存空间，如果没有可以使用的内存空间，则试图利用系统调用来动态增加程序数据段的内存大小，新分配得到的空间首先被组织进内部堆中去，然后再以适当的形式返回给调用者。当程序释放分配的内存空间时，这片内存空间被返回内部堆结构中，可能会被适当的处理(比如和其他空闲空间合并成更大的空闲空间)，以更适合下一次内存分配申请。这套复杂的分配机制实际上相当于一个内存分配的缓冲池(Cache)，使用这套机制有如下若干原因： 
1. 系统调用可能不支持任意大小的内存分配。有些系统的系统调用只支持固定大小及其倍数的内存请求(按页分配)；这样的话对于大量的小内存分类来说会造成浪费。 
2. 系统调用申请内存可能是代价昂贵的。系统调用可能涉及用户态和核心态的转换。 
3. 没有管理的内存分配在大量复杂内存的分配释放操作下很容易造成内存碎片。 

堆和栈的对比 
从以上知识可知，栈是系统提供的功能，特点是快速高效，缺点是有限制，数据不灵活；而栈是函数库提供的功能，特点是灵活方便，数据适应面广泛，但是效率有一定降低。

 

栈是系统数据结构，对于进程/线程是唯一的；堆是函数库内部数据结构，不一定唯一。不同堆分配的内存无法互相操作。栈空间 
分静态分配和动态分配两种。静态分配是编译器完成的，比如自动变量(auto)的分配。动态分配由alloca函数完成。栈的动态分配无需释放(是自动的)，也就没有释放函数。为可移植的程序起见，栈的 
动态分配操作是不被鼓励的！

 

堆空间的分配总是动态的，虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存/释放内存匹配是良好程序的基本要素。



```
1.修饰变量类型的区别

weak 只可以修饰对象。如果修饰基本数据类型，编译器会报错-“Property with ‘weak’ attribute must be of object type”。

assign 可修饰对象，和基本数据类型。当需要修饰对象类型时，MRC时代使用unsafe_unretained。当然，unsafe_unretained也可能产生野指针，所以它名字是"unsafe_”。
2.是否产生野指针的区别

weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计数器值为0），指针会自动被置nil，之后再向该对象发消息也不会崩溃。 weak是安全的。

assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对象发消息会崩溃。

assign 适用于基本数据类型如int,float,struct等值类型，不适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入堆中，需要我们自己手动管理内存或通过ARC管理。
weak 适用于delegate和block等引用类型，不会导致野指针问题，也不会循环引用，非常安全。

```




手势相关

 [singleTapGesture requireGestureRecognizerToFail:doubleTapGesture];  单双击冲突解决

http://blog.csdn.net/likendsl/article/details/7554150



git submodule 的方式去处理development pods





##### 关于混编方面的更多信息

更多关于混编方面的内容，可以访问查看Apple官方提供的这篇文章：[Using Swift with Cocoa and Objective-C (Swift 4)](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID0)，篇幅不少，不单单介绍了`Swift4.0`与`OC`的混用，也介绍了与`C`的`api`的交互、还有更多关于`@objc`修饰符的用法。

## 关于`Xcode9-beta`的更多

### `Xcode9-beta`局域网调试

#### 要求

- 必须是`Xcode9-beta`
- `iPhone`系统需`iOS11`以上

#### 操作

1. 在`Xcode9-beta`菜单的`Window`选项中选择`Devices and Simulators`
2. 通过连接线让你的`Mac`识别到你的`iPhone`
3. 在`Devices and Simulators`面板的左侧`Connected`菜单中选择连接的设备，然后在顶部的`Devices`和`Simulators`选项中选择`Devices`(这里其实默认就是选择了`Devices`)，最后勾选`Connect via network`选项。

来自[`stackoverflow`回答](https://stackoverflow.com/questions/44382841/how-to-do-wireless-debug-on-xcode-9-and-ios-11?answertab=votes#tab-top)





### xcodebuild archive 出包的archive文件中有对应的dsym

jenkins打包对应用户开启keychain权限问题, 遇到codesign问题 可以考虑一下这个原因

security -v list-keychains -d system -s "/Users/jfzapp/Library/Keychains/jenkins.keychain"
security -v unlock-keychain -p jfzapp "/Users/jfzapp/Library/Keychains/jenkins.keychain"



不要去选择始终信任证书 ！！！！！！





DEBUG_INFORMATION_FORMAT="dwarf-with-dsym"