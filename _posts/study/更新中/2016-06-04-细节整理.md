---
layout: post
category: 学习之路
title : "IOS开发小纸条"
---

1、 iOS layout的相关方法了解

layoutIfNeeded

```
如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）

如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局

在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]

UIKit会判断该view是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的

遍历的不是superview链，应该是subviews链
```

layoutSubviews

```
默认没有做任何事情，需要子类进行重写

1.init初始化不会触发layoutSubviews
但是是用initWithFrame 进行初始化时，当rect的值不为CGRectZero时,也会触发

2.addSubview会触发layoutSubviews

3.改变view的Frame会触发layoutSubviews 

4.滚动一个UIScrollView会触发layoutSubviews

5.旋转Screen会触发父UIView上的layoutSubviews事件

6.改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件

7.layoutSubviews对subviews重新布局

8.layoutSubviews方法调用先于drawRect
```

setNeedsLayout

```
 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用
 在view标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews
```



重绘

-drawRect:(CGRect)rect方法：重写此方法，执行重绘任务

-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect

-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘

sizeToFit会自动调用sizeThatFits方法；

sizeToFit不应该在子类中被重写，应该重写sizeThatFits

sizeThatFits传入的参数是view当前的size，返回一个适合的size

sizeToFit可以被手动直接调用

sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己

drawRect是对view的重绘，能获得context

setNeedDisplay在view标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘 



2、导航条上会用到的属性变化

1. 按钮颜色

   ```
   //按钮颜色
   self.navigationController.navigationBar.tintColor = [UIColor whiteColor];

   ```

2. title颜色

   ```
   //导航条文字title颜色
   [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor whiteColor]}];
   ```

3. 导航背景色(包括透明半透明导航条)

   ```
   直接更改barTintColor 颜色并非完全对
   所以一般操作都是替换

   func nav_setBackgroundColor(_ backgroundColor: UIColor) {
       if customBar == nil {
           self.shadowImage = UIImage()
           self.setBackgroundImage(UIImage(), for: UIBarMetrics.default)
           customBar = UIView.init(frame: CGRect.init(x: 0, y: 0, width: bounds.width, height: bounds.height+20))
           customBar?.isUserInteractionEnabled = false
           customBar?.autoresizingMask = UIViewAutoresizing.flexibleWidth
           subviews.first?.insertSubview(customBar!, at: 0)
       }
       customBar?.backgroundColor = backgroundColor
   }
   ```

4. 顶部状态栏变色

   ```
   //设置顶部状态栏变色

   1.控制器是依赖于系统的UINavigationController的：
   第一步 ： 拓展一个UINavigationController的子类，
   并设置 将导航控制器内所有控制器的顶部状态栏设置权赋予这些控制器。
   - (UIViewController *)childViewControllerForStatusBarStyle{
       return self.topViewController;
   }

   第二步 ： 在导航下的控制器中实现 配置 

   - (UIStatusBarStyle)preferredStatusBarStyle
   {
       return UIStatusBarStyleLightContent; //白色
       //return UIStatusBarStyleDefault; //黑色
   }

   2.直接设置
   1在Info.plist中设置UIViewControllerBasedStatusBarAppearance 为NO

   2 在需要改变状态栏颜色的ViewController中在ViewDidLoad方法中增加：

   [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];

   //这个地方，UIStatusBarStyleDefault外，设置其他值，导航条的文字颜色都将是白色，亲试。
   ```



3、在安装cocoapods遇到的问题  （未验证）

```
[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master
Cloning into 'master'...
error: RPC failed; curl 56 SSLRead() return error -36
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: index-pack failed
```

解决方案： 

```
先在终端输入”sudo xcode-select -switch “，然后，打开Xcode—>右键显示包内容，找到Developer文件夹拖到终端里面

PS:一些xcode-select的命令的使用：

xcode-select [-help]
xcode-select [-switch xcode_folder_path]
xcode-select [-print-path]
xcode-select [-version]

例如： 

打印当前xcode的路径    xcode-select --print-path
输出：/Applications/Xcode.app/Contents/Developer
```



4、函数调用栈

```
- (NSArray *)callStackReturnAddresses 
//线程的调用都会有函数的调用 函数的调用就会有栈返回地址的记录，在这里返回的是函数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组

- (NSArray *)callStackSymbols 
//同上面的方法一样，只不过返回的事该线程调用函数的名字数字
```



5、UITableViewCell  在点击之后马上取消点击效果

```
做一点延时处理效果会好很多
override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
        tableView.deselectRow(at: indexPath, animated: true)
    }
}
```



6、让scrollView延伸到导航条下面   使用需要注意场合 

```
self.automaticallyAdjustsScrollViewInsets = NO;

//下面属性会取消上面效果
swift: self.edgesForExtendedLayout = []
oc: self.edgesForExtendedLayout = UIRectEdgeNone; 
```



7、脑残错误案例：

    1、
    NSDictionary *dict = [NSDictionary dictionary];
    [dict setValue:@"xx" forKey:@"key"];
    NSDictionary 是不可变的
    2、
    当使用图片选择器的时候 如果是控制器设置的时局部变量，不能在弹出之前 给代理  需要在弹出之后给上代理处理、当遇到代理回调不出现的时候 检查代理是否被修改
    
    UIImagePickerController *picker = [[UIImagePickerController alloc] init];
    picker.sourceType               = (int)sourceType;
    picker.delegate                 = (id)self;
    [self presentViewController:picker animated:YES completion:^{
        picker.delegate                 = (id)self;
    }];
    
    3、
    tableView的侧滑删除  commitEditingStyle 、canEditRowAtIndexPath
    deleteRowsAtIndexPaths 的时候 需要先 更新数据源 再移除 防止空指针问题
    
8、UIVisualEffectView 毛玻璃效果

    UIVisualEffectView *blurView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight ]];
    blurView.layer.opacity = .9;
    blurView.frame = self.view.frame;
    [self.view addSubview:blurView];
9、instrument 使用错误

```
1.Target failed to run: Permission to debug jp.psc.TabletSync was denied. The app must be signed with a development identity (e.g. iOS Developer).

把 工程的scheme 中的profile  build模式改成debug
```



10、在Pod库中使用xcasset的拷贝陷阱

工作中遇到一个难解的BUG - 在App中用UIImage的imageNamed:方法读取的图片始终是不正确的。突然图片获取途径都是正常情况下 图片资源却取的不正确。排除缓存问题后，查看ipa包下面的图片是正确的。 

原因：http://blog.startry.com/2016/03/17/the-trap-of-image-resource/

CocoaPods在Pod里引用了任意一个xcasset相关的文件后, 就会去根目录搜索所有的xcasset组合成为最终的car。CocoaPods设定这样脚本的原因是无法精确的将主工程下的xcasset寻找到, 只能采用暴力的方式去解决, 暂时也没有更好的解决方案！

解决办法：

方法一: 删除所有物理目录下多余的xcasset, 本身在源代码根目录下放置没有用到库本身就是非常危险的行为。
方法二: 通过Podfile Hook去屏蔽Pod库资源的Copy和合成, 替换核心脚本, 定向指定自己需要Copy的资源。
方法三: 逃避的方法, 不要在Pod库中使用xcasset。本身CocoaPods的初衷并没有打算支持资源文件的, 后续演变成目前的形态。(不适用xcasset默认png压缩不会执行, 可能需要手动执行, 并且图片容易被提取)



11、IOS 按钮xib设置按钮取消点击效果 要从 system 改成custom



12、cocoa pods 升级更新

```
//gem更新

sudo gem update -n /usr/local/bin --system

//升级指定版本的cocoapods

sudo gem install -n /usr/local/bin cocoapods --version 1.1.0

sudo gem install -n /usr/local/bin cocoapods

//安装卸载指定版本的cocoapods

sudo gem install cocoapods --version 0.24.0

sudo gem uninstall cocoapods卸载cocoapods
```



13、查看具体设备 

```
#import <sys/sysctl.h>

+ (NSString*)getDeviceVersion

{
    size_t size;
    
    sysctlbyname("hw.machine",NULL, &size, NULL,0);
    
    char *machine = (char*)malloc(size);
    
    sysctlbyname("hw.machine", machine, &size,NULL, 0);
    
    NSString *platform = [NSString stringWithCString:machine encoding:NSUTF8StringEncoding];
    
    //NSString *platform = [NSStringstringWithUTF8String:machine];二者等效
    
    free(machine);
    
    return platform;
}

NSLog(@"%@",[ViewController getDeviceVersion])
```

14 、oc中  @class 和 #import、@import的区别

```
@class可以减少xcode编译文件数  @class 可以解决指针引用某个类中的内容等问题  

@class 告诉xcode  后面这个类 只需要知道是指针引用就行，不需要知道全部定义  所有判断使用的时候 看是否需要知道全部定义：例如继承之类的  无法用@class

#import 防止重复导入，
#import 相当于直接导入对应文件，而@import相当于引入一个对应文件的地址，需要使用的时候再去引入使用
@import 引入某个框架下得某个文件可以不需要明确框架，会自动引入。
#import 编译会慢一点

import 中得 <> 和 "" 的区别  查找路径优先级不同，<> 优先查找系统层再找用户自定义层，""相反 
动态库引入其他动态库的时候要用@import
```

15、

NSScaner

http://blog.csdn.net/likendsl/article/details/7974761



16、static和const的使用

```
static  生命周期

1.
修饰局部变量、让局部变量只初始化一次、局部变量在程序中只有一份内存
并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）

2.
修饰全局变量
全局变量的作用域仅限于当前文件

const  是否可修改

没有const修饰的指针

指针p和*p都能被修改

// 定义一个指针变量

int *p = NULL;

// 定义2个int类型的变量

int a = 10;

int b = 30;

// p指向a

p = &a;

*p = 20;

// p指向b

p = &b;

*p = 40;

NSLog(@"%d %d", a, b);

const修饰的*p

被const修饰的*p只能被赋值一次，以后不能赋值，否则编译器报错

// const修饰的*p

const int *p = NULL;

int const *p = null;

p = 20; // 编译器报错，不能修改p的值

const修饰的p

被const修饰的p只能存一次地址，以后再也不能其它存地址了，否则编译器报错

// const修饰的指针变量p

int * const p = NULL;

int a = 20;

p = &a; // 编译器报错，不能修改指针变量p

const在声明字符串的用法

  NSString * const ZMJName = @"jack";

static和const联合使用

static将一个全局变量变成局部变量

const将一个局部变量变成局部常量

// 定义了一个局部常量

static const CGFloat ZMJRed = 0.4;

static const CGFloat ZMJGreen = 0.6;

static const CGFloat ZMJBlue = 0.7;

使用static const 与 #define

使用static const修饰变量和宏定义的比较

相同点 : 都不能再被修改  一处修改，其它都改了

不同点 : static const修饰变量只有一份内存  宏定义，只是简单的替换，每次使用都需要创建一份内存

结论 :

使用static const修饰更加高效，在同一个文件内可以使用static const取代#define

    // static const修饰变量只有一份内存
    static const CGFloat ZMJRed = 0.4;
    // 宏定义，只是用0.4替换ZMJRed，每次使用都需要创建一份内存
    #define ZMJRed 0.4

const实际开发的应用

一般专门存放常量的引用

// 定义了整个程序都能访问的常量

const CGFloat ZMJRed = 0.4;

NSString * const ZMJName = @"jack";

```



17、对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。

    NSString *string = @"origin";
    NSString *stringCopy = [string copy];
    理解这个的时候要分清楚，*string 是一个指针，它本身有一个内存地址 存放了@"origin"这个对象的内存地址
    每次拷贝都会生成一个新的指针地址 *stringCopy  但是这个指针地址内存放的对象内存地址会因为拷贝方式不一样而不一样。
18、Xcode 7.0也就是iOS9.0中开发要求App内访问的网络必须使用HTTPS协议。那么我们公司没用采用https怎么办？如果发现网络请求失败，Xcode后台报错信息为： 

The resource could not be loaded because the App Transport Security policy requires the use of a secure connection. （大概意思就是：资源数据不能被下载，因为APP传输安全策略需要采用安全的连接方式）。

解决方法：

在Info.plist中添加NSAppTransportSecurity类型Dictionary。 
在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES

    <key>NSAppTransportSecurity</key>
    <dict>
          <key>NSAllowsArbitraryLoads</key>
          <true/>
    </dict>
找到info.plist, 注意不是测试文件里面的plist哦。 



19、监听侧滑完成

```
[self.transitionCoordinator notifyWhenInteractionEndsUsingBlock:^(id<UIViewControllerTransitionCoordinatorContext>  _Nonnull context) {
	dosth
}];
```



20、事件阻隔

比如button中加个view view的事件会阻隔掉button的touch事件 怎么办？

view.userInteractionEnabled  = NO;//取消view的事件响应能力即可



21、@property (nonatomic, strong) NSMutableArray *dataArray;

当用到dataArray去变更添加数据的时候，前面如果声明为copy  在构造的时候  需要使用mutableCopy 复制一份，不然会出现_ _NSArrayI 问题  也可直接用strong类型



22、

小数的四舍五入

round(combinationFee  * 100)/100



23、

UIView 自动布局更新View大小，只要都是使用自动布局并且xib可以根据约束自己估算出高度就可以不设置UIView的高度，Xib会根据约束自动去计算需要的高度并展示

例如 UIView根据UILabel自动去计算高度，但是这个情况是在UIView刷新的时候才会生效，所以直接设置UILabel的text然后希望去取到新高度是不可能的。

masonry 写约束的话 每个View的上下左右相对约束都要有 相互约束 要保证有一方约束到



24、masonry 当针对负的offset设置大于等于时要用lessThan

25、


oc pch文件的使用

http://www.jianshu.com/p/67ce72c4ad6c

注意要在  build - setting 中得 prefix Header配置新建的pch文件  配置格式 $(SRCROOT)/项目名称/pch文件名

当xib layout设置width>=0的时候  在代码中设置constraints = 0 无效 比如我需要移除一个label的宽度 但是label在xib中自适应的width>0   ?????

UITabelView 的 headView 想要动态更新大小的时候 需要变更view的frame然后重新设置tableHeaderView



26、

UIView 有两个类别的content优先级 http://blog.csdn.net/loving_ios/article/details/53018879

Content Hugging Priority      确定view有多大的优先级阻止自己变大。 默认 250  （例如保证UIButton不会因为屏幕边距变大而拉伸按钮）优先级越高越抗拒变大

Content Compression Resistance Priority  确定有多大的优先级阻止自己变小。  默认 750（例如保证UILabel不会被挤压导致显示不全）优先级越大 越抗拒被压缩

说这个之前先了解一些信息：

这两个属性对有intrinsic content size的控件（例如button，label）非常重要。通俗的讲，具有intrinsic content size的控件自己知道（可以计算）自己的大小，例如一个label，当你设置text，font之后，其大小是可以计算到的。

UIView中关于Content Hugging 和 Content Compression Resistance的方法

```
- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
```

默认从左到右，从上到下。   默认情况下两边的label的Content Hugging和Content Compression优先级都是一样的。当一个View 高度需要根据内容来扩张。

那么内部label 和 view的优先级怎么判断 有什么不同吗？没有， 根据优先级来。

测试出现的情况：

1.当xib的View中加了两个默认的Label 并自动计算高度适配，再通过代码在底下继续加上Label 的时候 label需要更改收缩优先级来保证他完整显示。(依然未解)

2.但是直接在xib中加入多个label，并设定好约束，label会正常扩张，父view也会正常扩张。

3.在 2 的基础上 再在底下通过代码添加的label 设定好masonry约束 同样能正常显示，正常扩张

4.一个View中 由上到下分别是 label、label、view（里面有一个label） 的布局，自动布局也可以正常扩张

5.hidden 并不会影响约束









35.

删除线在 IOS 8.0 的兼容问题 value中 给值的问题

```
ou should add NSUnderlineStyleNone at the beginning of the string.

 NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] init];
 [attributedString appendAttributedString:[[NSAttributedString alloc] initWithString:@"test "
                                                                          attributes:@{NSUnderlineStyleAttributeName: @(NSUnderlineStyleNone)}]];
 [attributedString appendAttributedString:[[NSAttributedString alloc] initWithString:@"s"
                                                                         attributes:@{NSUnderlineStyleAttributeName: @(NSUnderlineStyleSingle),
                                                                                      NSBackgroundColorAttributeName: [UIColor clearColor]}]];
 [attributedString appendAttributedString:[[NSAttributedString alloc] initWithString:@"tring"]];
Another bonus of such approach is absence of any ranges. Very nice for localized strings.
```



36.方法唤起，系统提供的方法只支持一两个参数，如果有多个参数 需要使用另一套。

系统

```
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
     [target performSelector:action];
#pragma clang diagnostic pop
```

自定义

```

```





37.va_list 的作用 用于接收一些可以传递不定个数量参数的方法中的参数。

```
- (id)customPerformSelector:(SEL)aSelector withObjects:(id)object, ...{
	va_list args;
	va_start(args, object); //表示从object开始 后面的参数都会存在va_list中
	return [self customPerformSelector:aSelector withObjects:object orVAList:args];
	va_end(args);
}
```



38.在 iOS中可以直接调用某个对象的消息方式有两种

一种是performSelector:withObject；
再一种就是NSInvocation。
第一种方式比较简单，能完成简单的调用。但是对于>2个的参数或者有返回值的处理，那performSelector:withObject就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。

NSInvocation的基本使用

```
方法签名类

// 方法签名中保存了方法的名称/参数/返回值，协同NSInvocation来进行消息的转发
// 方法签名一般是用来设置参数和获取返回值的, 和方法的调用没有太大的关系
//1、根据方法来初始化NSMethodSignature
NSMethodSignature  *signature = [ViewController instanceMethodSignatureForSelector:@selector(run:)];
根据方法签名来创建NSInvocation对象

// NSInvocation中保存了方法所属的对象/方法名称/参数/返回值
//其实NSInvocation就是将一个方法变成一个对象
//2、创建NSInvocation对象
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
//设置方法调用者
invocation.target = self;
//注意：这里的方法名一定要与方法签名类中的方法一致
invocation.selector = @selector(run:);
NSString *way = @"byCar";
//这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd)
[invocation setArgument:&way atIndex:2];
//3、调用invoke方法
[invocation invoke];
//实现run:方法
- (void)run:(NSString *)method{

}
优化

但是上述方法有很多弊端，首先我们来一一解决

1、如果调用的方法不存在

//此时我们应该判断方法是否存在，如果不存在这抛出异常
if (signature == nil) {
//aSelector为传进来的方法
NSString *info = [NSString stringWithFormat:@"%@方法找不到", NSStringFromSelector(aSelector)];
[NSException raise:@"方法调用出现异常" format:info, nil];
    }
2、方法的参数个数与外界传进来的参数数组元素个数不符

//此处不能通过遍历参数数组来设置参数，因为外界传进来的参数个数是不可控的
//因此通过numberOfArguments方法获取的参数个数,是包含self和_cmd的，然后比较方法需要的参数和外界传进来的参数个数，并且取它们之间的最小值
NSUInteger argsCount = signature.numberOfArguments - 2;
NSUInteger arrCount = objects.count;
NSUInteger count = MIN(argsCount, arrCount);
for (int i = 0; i < count; i++) {
    id obj = objects[i];
    // 判断需要设置的参数是否是NSNull, 如果是就设置为nil
    if ([obj isKindOfClass:[NSNull class]]) {
        obj = nil;
    }
[invocation setArgument:&obj atIndex:i + 2];
}
3、判断当前调用的方法是否有返回值

//方法一：
id res = nil;
if (signature.methodReturnLength != 0) {//有返回值
    //将返回值赋值给res
    [invocation getReturnValue:&res];
}
return res;

//方法二：
//可以通过signature.methodReturnType获得返回的类型编码，因此可以推断返回值的具体类型
```



39.调用三点符号方法的时候 如果后面没有参数了 也要加上nil传入



40.pch 文件

http://www.jianshu.com/p/e6e0e3bbbf38

1.)  打开你的Xcode工程. 在Supporting Files目录下,选择 File > New > File > iOS > Other > PCH File 然后点击下一步；

2.) 假设你的项目名称为TestDemo, 你的PCH 文件的名字应该为 TestDemo-Prefix.pch,然后创建；




3.) 选择 PCH 文件(文章的示例文件为 TestDemo-Prefix.pch) ,可以看到里面的内容如下:


4.) 找到 Project > Build Settings > 搜索 “Prefix Header“；

5.) “Apple LLVM 7.0 -Language″ 栏目中你将会看到 Prefix Header 关键字；

6.) 输入: TestDemo/TestDemo-Prefix.pch (如 TestDemo/TestDemo-Prefix.pch )；

7.)，将Precompile Prefix Header为YES，预编译后的pch文件会被缓存起来，可以提高编译速度。效果如下


8.) Clean 并且 build 你的项目.

就是这样！Done！现在你可以使用你的 PCH 文件就像你使用老版本的Xcode一样了



41.未释放问题 webView引用循环



    [Jockey on:@"toggle-talk-with-callback" performAsync:^(UIWebView *webView, NSDictionary *payload, void (^complete)()) {
        NSString *text = [payload objectForKey:@"text"];
        NSDictionary *param = @{@"response": [NSString stringWithFormat:@"你说：%@  我回答什么好呢?",text]};
        [Jockey send:@"toggle-talk-response" withPayload:param toWebView:weakSelf.webView];
    }];

Jockey 开辟的on监听会去持有内部block  所以，block内部一定不能使用self  而需要弱化。否则控制器（self）无法释放。

42.  打印内存地址 

    int i = 1;
    NSLog(@"%p + out",&i);

    ​

43.引用计数

CFGetRetainCount

44.IOS 存放地址

iphone沙盒  documents，tmp，Library。数据分别存放位置以及存储方式

```
1、Documents 目录：您应该将所有de应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。

2、Library 目录：这个目录下有两个子目录：Caches 和 Preferences
	Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.
	Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。

3、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。
```

获取路径方法

```
1、获取沙盒主目录路径的函数
NSString *homeDir = NSHomeDirectory();
2，获取Documents目录路径的方法：
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *docDir = [paths objectAtIndex:0];
3，获取Caches目录路径的方法：
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *cachesDir = [paths objectAtIndex:0];
4，获取tmp目录路径的方法：
NSString *tmpDir = NSTemporaryDirectory();
5，获取应用程序程序包中资源文件路径的方法：
例如获取程序包中一个图片资源（apple.png）路径的方法：
NSString *imagePath = [[NSBundle mainBundle] pathForResource:@”apple” ofType:@”png”];
UIImage *appleImage = [[UIImage alloc] initWithContentsOfFile:imagePath];
代码中的mainBundle类方法用于返回一个代表应用程序包的对象。
```



45.xcode 存放地址

xcode的preference中有Locations 可以查看DerivedData地址和Archives地址

1、xcode项目缓存地址 DerivedData

2、自定义代码块地址

/Users/username/Library/Developer/Xcode/UserData/CodeSnippets

46.xcode代码块、代码块文件 导出





47.当合并代码出现很奇怪也不太会出现的问题时候，特别比如提交podspec的时候，考虑是不是更改了文件目录，检查是不是有文件问题



48.alias in mac 

```
1.创建了一个 ~/.bash_aliases 文件，专门用来管理alias 例如内部加上如下几个别名:

alias gs='git push'
alias gp='git push'
alias pi='pod install'
alias pu='pod update --no-repo-update'

2.在 ~/.bash_profile 中编译这个文件 : 加入下面代码
test -f ~/.bash_aliases && source ~/.bash_aliases

3.重启终端

这样操作方便管理，同时 如果更换电脑也不需要一个个重新设置
```

49.xcode release  和 debug 打包

Scheme -> Edit Scheme -> Run

![](https://xilankong.github.io/resource/xcode_2.png)

以上呢就是这两种模式的切换方法，这样做呢就可以在开发阶段输出我们想要查看的信息，发布的时候更为应用节省了一些硬件设备的资源，不过在Xcode中默认的开发环境都是debug模式的。
到这里呢在补充一点，在Xcode中我们怎么确定当前到底是不是debug模式呢？好，我们继续看下面：

首先确定下项目里Build Setting是否已经设置过宏定义debug,如何看呢？点击Build Setting ,然后在搜索框里输入macros，如下图：

![](https://xilankong.github.io/resource/xcode_1.png)

如果已经设置过，在 Preprocessor Macros 的 Debug 后面会有 DEBUG=1，如果没有，就手动设置下。
接下来就可以这样做了, swift  oc 通用

```
#if DEBUG
    print("00000")
#else
    print("11111")
#endif
```



50.IOS 签名

```
1.非对称加密

非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法

甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。

非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。
 
非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。
```





51.引用计数  ----关于内存/引用计数这一块 还需要继续学习。

1.引用计数(retainCount) 规定:只要引用计数为零,对象就会被释放

2.alloc, new, copy, mutableCopy 根据编译器的约定，这以这四个单词开头的方法都会使引用计数加一

当我们使用alloc、new或者copy的我们需要销毁这个对象。release函数，只是将对象的retainCount值减1，并不是删除对象。当retainCount==0的时候，系统会发给对象一个dealloc消息，另外：千万不要手动调用dealloc，因为我们不知道何时，何地，何人还会使用该对象。应该老老实实依赖引用计数机制完成内存管理。    释放对象所有权的函数除了release还有autorelease，这是一种延迟操作。

3.字符串常量，系统不会收回，也不会对其作引用计数 （retainCount方法的实现返回的是maxIntValue）

4.weak assign 并不会增加引用计数，assign 释放的时候并不会置为nil  weak 会

NSLog(@"assign属性：%@",self.assignPoint); //在释放后调用打印assign

当assign指针所指向的内存被释放（释放并不等于抹除，只是引用计数为0），不会自动赋值nil，这样再引用self.assignPoint就会导致野指针操作，如果这个操作发生时内存还没有改变内容，依旧可以输出正确的结果，而如果发生时内存内容被改变了，就会crash。

SO：在ARC模式下编程时，指针变量一定要用weak修饰，只有基本数据类型和结构体需要用assgin



```
参数的弱化：

1、__strong 和 __weak 对 self做了什么？

如下 ：
__weak __typeof(self)weakself = self;
[NSTimer timerWithTimeInterval:1.0 target:weakSelf selector:@selector(get) userInfo:nil repeats:YES];

新的一个指针 指向self的内存地址，并使用弱化引用。经常在block外部定义，内部使用，因为block的异步执行问题，如果直接使用self 会出现释放问题，两者都强引用了对方。而使用weak ，一旦weakself对象被释放，weakself就会被置为nil，不会crash。

2、如果strong的 delegate  为什么把弱化的self 设成代理依然循环引用

因为例如 NSTime的方法，target对应的代理设置的是防丢失的strong，导致weakself再次被强化引用。这种情况的释放需要用到YYWeakProxy

3、weak和assign都不会增加引用计数，区别是修饰的对象在释放时所做的操作不同，weak是会把对象置为nil，assign则不会，assign一般适用与基本数据类型


在 swift中如何处理这些问题
```

自动释放池 autoreleasepool

    自动释放池是NSAutoreleasePool的实例，其中包含了收到autorelease消息的对象。当一个自动释放池自身被销毁（dealloc）时，它会给池中每一个对象发送一个release消息（如果你给一个对象多次发送autorelease消息，那么当自动释放池销毁时，这个对象也会收到同样数目的release消息）。可以看出，一个自动释放的对象，它至少能够存活到自动释放池销毁的时候。

52.

```
避免对 可选类型 强解包

If you have an identifier foo of type FooType? or FooType!, don't force-unwrap it to get to the underlying value (foo!) if possible.

如果你有个 FooType? 或 FooType! 的 foo，尽量不要强行展开它以得到基本类型（foo!）。

理由： if let 绑定可选类型产生了更安全的代码，强行展开很可能导致运行时崩溃。




if let x = foo {
    // Use unwrapped `x` value in here
} else {
    // If appropriate, handle the case where the optional is nil
}

这一段的重要性，直接在if块解包 
少用强解

if let rateString = dic?["incomeRate"] as? String  {
  let rate = NSString(string: rateString).floatValue
}
比较
let rate  = NSString(string: incomeRate!).floatValue //可能出现转换失败导致的崩溃



```



53.半透明遮罩抠透明区域

```
 UIBezierPath *path = [UIBezierPath bezierPathWithRect:view.frame];
[path appendPath:[[UIBezierPath bezierPathWithRoundedRect: CGRectMake((UIScreenMainScreenWidth -200) * 0.5, (UIScreenMainScreenHeight -200) * 0.5 -100, 200,200) cornerRadius:0] bezierPathByReversingPath]];
CAShapeLayer *shapeLayer = [CAShapeLayerlayer];
shapeLayer.path = path.CGPath;
view.layer.mask = shapeLayer

let path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: App.screenWidth, height: App.screenHeight))
path.append(UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: 100, height: 100), cornerRadius: 15).reversing())
let shapeLayer = CAShapeLayer()
shapeLayer.path = path.cgPath
self.view.layer.mask = shapeLayer
```



54.在tableView上浮键盘的时候，点击cell会隐藏键盘，但是手势会影响tableView点击事件

```
响应链机制  http://ios.jobbole.com/86425/
```





55.swift 创建view xib如何绑定



56.swift 的构造方法到底是如何实现

 public init(dic: Any) 



57.

```
问题，需要满足小屏幕滚动，大屏幕尽量一屏显示
```

58.绘制很细的实、虚线

```
            //横线
            UIBezierPath *path = [UIBezierPath bezierPath];
            path.lineWidth =  0.5;
            [path moveToPoint:CGPointMake(0, 0)];
            [path addLineToPoint:CGPointMake(self.bounds.size.width,0)];
            
            CAShapeLayer *layer = [[CAShapeLayer alloc] init];
            layer.masksToBounds = YES;
            layer.frame = CGRectMake(0, self.frame.origin.y + space * idx, self.frame.size.width, 1.0/[UIScreen mainScreen].scale);
            layer.lineWidth =  0.5;
            layer.path = path.CGPath;
            layer.strokeEnd = 1.0;
            layer.fillColor = [UIColor whiteColor].CGColor;
            layer.strokeColor = [UIColor colorWithRed:0.85 green:0.85 blue:0.85 alpha:1.0].CGColor;
            layer.lineDashPattern = @[@2, @1];
            [self addSublayer:layer];
            
            用图片
```

59 guard 的使用

```
        guard let xAxis = xAxis, !xAxis.isEmpty  else {
            return ""
        }
```

60.手势冲突



61.UIViewController 自动寻找xib的原理 。就是[[UIViewController alloc]init] 为什么会自动加载XIB 

```
每次访问UIViewController的view(比如controller.view、self.view)而且view为nil，loadView方法就会被调用。 前提是 view 的UIViewController 不为空。

作用：

loadView方法是用来负责创建UIViewController的view  也就是我们可以用来自定义VC 的View

如果我们没有重载这个方法。它会调用 【super loadView】;返回一个View .里面实现为：

1> 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view

如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件
[[MJViewController alloc] initWithNibName:@"MJViewController" bundle:nil];  
如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件
[[MJViewController alloc] init]; // 加载MJViewController.xib  
2> 如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下

self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];  
// applicationFrame的值是：x = 0, y = 20  width = 320, height = 460
 
[super loadView]里面就大致完成1>和2>中叙述的内容

 
大家都知道UIViewController的view可以通过xib文件来创建，但是在某些情况下，xib不是那么地灵活，所以有时候我们想通过代码来创建UIView，比如：

self.view = [[UIWebView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];  
 如果想通过代码来创建UIViewController的view，就要重写loadView方法，并且不需要调用[super loadView]，因为在第3点里面已经提到：若没有xib文件，[super loadView]默认会创建一个空白的UIView。我们既然要通过代码来自定义UIView，那么就没必要事先创建一个空白的UIView，以节省不必要的开销。正确的做法应该是这样：

- (void)loadView {  
     self.view = [[[UIWebView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame] autorelease];  
}  
 
不需要调用[super loadView]，你调用了也不会出错，只是造成了一些不必要的开销。

总结一句话，苹果设计这个方法就是给我们自定义UIViewController的view用的
```

62.github pages 中 md文件里不能写双花括号





63.

```
动态类型，说简单点就是id类型。动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(run time)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。

动态绑定(dynamic binding)貌似比较难记忆，但事实上很简单，只需记住关键词 @selector/SEL 即可。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。这里要注意一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。

简单的说 [a someFunc] 这样一个调用，在编译阶段，编译器并不知道someFunc要执行哪段代码。这个时候[a someFunc]会被转换为 objc_msgSend(a, "someFunc")，字面的意思也很容易理解，就是给a这个instance，发“someFunc”这个消息，以selector的形式。在运行阶段，执行到上述的objc_msgSend这个函数时。函数内部会到a对应的内存地址，寻找someFunc这个方法的地址，并执行。如果找不到，就会抛一个“unknown selector sent to instance”的异常。（比如.h中声明了方法，但.m中没有实现，就可以重现这个错误） 所以严格意义上来将，任何Objective C的函数调用，编译阶段的表现，都只能算一种“发消息”的行为。
```

64. URL TYPES

    ```
    http://www.jb51.net/article/83266.htm
    ```

    ​

65 ssh key 问题，ssh-keygen -t rsa -C "your email " 更新账户，会要求输入密码和确认密码，如果不需要就直接回车，然后把生成的public key 拷贝存放到 gitlab ssh key 存放处









66.IOS上 关于状态栏的相关设置(UIStatusBar)

## 知识普及

ios上状态栏 就是指的最上面的20像素高的部分
状态栏分前后两部分，要分清这两个概念，后面会用到：

- **前景部分**：就是指的显示电池、时间等部分；

- **背景部分**：就是显示黑色或者图片的背景部分；

  如下图：前景部分为白色，背景部分为黑色
  ![在此输入图片描述](http://static.oschina.net/uploads/space/2014/0820/005046_Oztm_574576.png)

`注意：这里只涉及到ios7以及更高版本，低版本下面的讲解可能无效。`

------

## 设置statusBar的【前景部分】

简单来说，就是设置显示电池电量、时间、网络部分标示的颜色， 这里只能设置两种颜色：

- 默认的黑色（**UIStatusBarStyleDefault**）
- 白色（**UIStatusBarStyleLightContent**）

可以设置的地方有两个：plist设置里面 和 程序代码里

### 1.plist设置statusBar

在plist里增加一行 **UIStatusBarStyle**(或者是“Status bar style”也可以)，这里可以设置两个值，就是上面提到那两个 **UIStatusBarStyleDefault** 和 **UIStatusBarStyleLightContent**

这样在app启动的launch页显示的时候，statusBar的样式就是上面plist设置的风格。

### 2.程序代码里设置statusBar

```
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];  

```

或者 

```
//相对于上面的接口，这个接口可以动画的改变statusBar的前景色  
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];

```

不仅如此，ios还很贴心的在UIViewController也增加了几个接口，
目的是让状态栏根据当前显示的UIViewController来定制statusBar的前景部分。

- \- (UIStatusBarStyle)preferredStatusBarStyle;
- \- (UIViewController *)childViewControllerForStatusBarStyle;
- \- (void)setNeedsStatusBarAppearanceUpdate

**- (UIStatusBarStyle)preferredStatusBarStyle:**

在你自己的UIViewController里重写此方法，返回你需要的值(UIStatusBarStyleDefault 或者 UIStatusBarStyleLightContent)； 

注意： 

- 这里如果你只是简单的return一个固定的值，那么该UIViewController显示的时候，程序就会马上调用该方法，来改变statusBar的前景部分； 
- 如果在该UIViewController已经在显示在当前，你可能还要在当前页面不时的更改statusBar的前景色，那么，你首先需要调用下面的**setNeedsStatusBarAppearanceUpdate**方法(这个方法会通知系统去调用当前UIViewController的**preferredStatusBarStyle**方法)， 这个和UIView的**setNeedsDisplay**原理差不多(调用UIView对象的**setNeedsDisplay**方法后，系统会在下次页面刷新时，调用重绘该view，系统最快能1秒刷新60次页面，具体要看程序设置)。

**- (UIViewController \*)childViewControllerForStatusBarStyle:**

这个接口也很重要，默认返回值为nil。当我们调用**setNeedsStatusBarAppearanceUpdate**时，系统会调用application.window的rootViewController的**preferredStatusBarStyle**方法，我们的程序里一般都是用UINavigationController做root，如果是这种情况，那我们自己的UIViewController里的**preferredStatusBarStyle**根本不会被调用；
这种情况下**childViewControllerForStatusBarStyle**就派上用场了，
我们要子类化一个UINavigationController，在这个子类里面重写**childViewControllerForStatusBarStyle**方法，如下：

```
- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}

```

上面代码的意思就是说，不要调用我自己(就是UINavigationController)的**preferredStatusBarStyle**方法，而是去调用**navigationController.topViewController**的**preferredStatusBarStyle**方法，这样写的话，就能保证当前显示的UIViewController的**preferredStatusBarStyle**方法能影响statusBar的前景部分。

另外，有时我们的当前显示的UIViewController可能有多个childViewController，重写当前UIViewController的**childViewControllerForStatusBarStyle**方法，让childViewController的**preferredStatusBarStyle**生效(当前UIViewController的**preferredStatusBarStyle**就不会被调用了)。

简单来说，只要UIViewController重写的的**childViewControllerForStatusBarStyle**方法返回值不是nil，那么，UIViewController的**preferredStatusBarStyle**方法就不会被系统调用，系统会调用**childViewControllerForStatusBarStyle**方法返回的UIViewController的**preferredStatusBarStyle**方法。

**- (void)setNeedsStatusBarAppearanceUpdate:**

让系统去调用application.window的rootViewController的**preferredStatusBarStyle**方法,如果rootViewController的**childViewControllerForStatusBarStyle**返回值不为nil，则参考上面的讲解。

------

## 设置statusBar的【背景部分】

背景部分，简单来说，就是背景色；改变方法有两种：

### 系统提供的方法

**navigationBar**的**setBarTintColor**接口，用此接口可改变statusBar的背景色

注意：一旦你设置了**navigationBar**的**- (void)setBackgroundImage:(UIImage \*)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics**接口，那么上面的**setBarTintColor**接口就不能改变statusBar的背景色，statusBar的背景色就会变成纯黑色。

### 另辟蹊径

创建一个UIView，
设置该UIView的frame.size 和statusBar大小一样，
设置该UIView的frame.origin 为{0,-20},
设置该UIView的背景色为你希望的statusBar的颜色，
在navigationBar上addSubView该UIView即可。





67.

```
我们设置text的时候也会自动设置lineBreakMode,但设置attributedText后,lineBreakMode就会失效,直接切断显示的内容,并且没用省略号代替

如果你确保你所有的文字都需要加省略号,那就简单,设置完attributedText之后 一行代码搞定:
self.titleLabel.lineBreakMode = NSLineBreakByTruncatingTail;
```





# Swift开发必备技巧：static和class的使用

#### 发表于2015-01-28 14:12| 17193次阅读| 来源Swifter| 8 条评论| 作者王巍

[移动开发](http://www.csdn.net/tag/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/news)[Objective-C](http://www.csdn.net/tag/objective-c/news)[Swift](http://www.csdn.net/tag/swift/news)[开发经验](http://www.csdn.net/tag/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/news)[iOS](http://www.csdn.net/tag/ios/news)[Apple](http://www.csdn.net/tag/apple/news)[编程语言](http://www.csdn.net/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/news)

**摘要：**Swift中表示“类型范围作用域”这一概念有着两个不同的关键字，分别为static和class，而在OC等其他语言中，开发者不会特地区分变量/类方法和静态变量/静态函数。本文作者王巍在这篇Tip中详解了static和class的使用。	

Swift中表示 “类型范围作用域” 这一概念有两个不同的关键字，它们分别是static和class。这两个关键字确实都表达了这个意思，但是在其他一些语言，包括Objective-C中，我们并不会特别地区分类变量/类方法和静态变量/静态函数。但是在Swift中，这两个关键字却是不能用混的。

在非class的类型上下文中，我们统一使用static来描述类型作用域。这包括在enum和struct中表述类型方法和类型属性时。在这两个值类型中，我们可以在类型范围内声明并使用存储属性，计算属性和方法。static适用的场景有这些：

**[cpp]** [view plain](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[copy](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/591221)[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/591221/fork)

1. struct Point {  
2. ​    let x: Double  
3. ​    let y: Double  
4. ​    // 存储属性  
5. ​    static let zero = Point(x: 0, y: 0)  
6. ​    // 计算属性  
7. ​    static var ones: [Point] {  
8. ​        return [Point(x: 1, y: 1),  
9. ​                Point(x: -1, y: 1),  
10. ​                Point(x: 1, y: -1),  
11. ​                Point(x: -1, y: -1)]  
12. ​    }  
13. ​    // 类型方法  
14. ​    static func add(p1: Point, p2: Point) -> Point {  
15. ​        return Point(x: p1.x + p2.x, y: p1.y + p2.y)  
16. ​    }  
17. }  

enum的情况与这个十分类似，就不再列举了。

class关键字相比起来就明白许多，是专门用在class类型的上下文中的，可以用来修饰类方法以及类的计算属性。要特别注意class中现在是不能出现存储属性的，我们如果写类似这样的代码的话：

**[cpp]** [view plain](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[copy](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/591221)[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/591221/fork)

1. class MyClass {  
2. ​    class var bar: Bar?  
3. }  

编译时会得到一个错误：

> class variables not yet supported

这主要是因为在Objective-C中就没有类变量这个概念，为了运行时的统一和兼容，暂时不太方便添加这个特性。Apple表示今后将会考虑在某个升级版本中实装class类型的类存储变量，现在的话，我们只能在class中用class关键字声明方法和计算属性。

有一个比较特殊的是protocol。在Swift中class、struct和enum都是可以实现protocol的。那么如果我们想在protocol里定义一个类型域上的方法或者计算属性的话，应该用哪个关键字呢？答案是使用class进行定义，但是在实现时还是按照上面的规则：在class里使用class关键字，而在struct或enum中仍然使用static——虽然在protocol中定义时使用的是class：

**[cpp]** [view plain](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[copy](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/591221)[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/591221/fork)

1. protocol MyProtocol {  
2. ​    class func foo() -> String  
3. }  
4. struct MyStruct: MyProtocol {  
5. ​    static func foo() -> String {  
6. ​        return "MyStruct"  
7. ​    }  
8. }  
9. enum MyEnum: MyProtocol {  
10. ​    static func foo() -> String {  
11. ​        return "MyEnum"  
12. ​    }  
13. }  
14. class MyClass: MyProtocol {  
15. ​    class func foo() -> String {  
16. ​        return "MyClass"  
17. ​    }  
18. }  