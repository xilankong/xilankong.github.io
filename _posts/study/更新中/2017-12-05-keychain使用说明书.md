---
layout: post
category: 学习之路
title : "keychain使用说明书"
---

1、什么是keychain

Keychain Services 是 OS X 和 iOS 都提供一种安全地存储敏感信息的工具，比如，存储用户ID，密码，和证书等。存储这些信息可以免除用户重复输入用户名和密码的过程。Keychain Services 的安全机制保证了存储这些敏感信息不会被窃取。简单说来，Keychain 就是一个安全容器。

2、keychain的优缺点

keychain优点：

> 1.每个组(keychain-access-groups)之间数据访问隔离，没有权限的app如何读取他人数据，保证了数据安全。
>
> *2.全局统一存储，即使删除了app，keychain里的数据也还在，下次重新安装app后依然能访问*
>
> *3.存储后的数据加密*
>
> *4.同一个组的app可以共享keychain中的数据*
>
> *5.暂时想不到了，求大伙补充*

keychain缺点：

> 1.删除app后不会自动清除keychain里的数据，如果存储密码等敏感数据会有一定风险（越狱后keychain能被导出来）

3、keychain的基本操作

Keychain 的操作

- SecItemCopyMatching 查
- SecItemAdd  增
- SecItemUpdate 改
- SecItemDelete 删



```
//CFTypeRef kSecAttrAccessible;//可访问性类型透明//值//CFTypeRefkSecAttrAccessibleWhenUnlocked;//解锁可访问，备份//CFTypeRefkSecAttrAccessibleAfterFirstUnlock;//第一次解锁后可访问，备份//CFTypeRefkSecAttrAccessibleAlways;//一直可访问，备份//CFTypeRefkSecAttrAccessibleWhenUnlockedThisDeviceOnly;//解锁可访问，不备份//CFTypeRefkSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;//第一次解锁后可访问，不备份//CFTypeRefkSecAttrAccessibleAlwaysThisDeviceOnly;//一直可访问，不备份


```





4、keychain作用

实现uuid的保持、保持私密信息（不要直接存放未加密的重要账户密码信息）、





5、keychain数据共享：





iOS 应用间共享 Keychain 数据

相同的 Team ID

有相同的 Team ID。这个是应用间共享 Keychain 数据的前提条件。一个 App ID 分两部分：

- Apple 为你生成的 Team ID；
- 开发者注册的 Bundle ID。

一个典型的 App ID 如：659823F3DC53.com.apple.oneappleapp。

659823F3DC53 即为你的 Team ID，是 Apple 为你生成的。一个开发者账号可以有不同的几个 Team ID。但 Apple 不会为不同的开发者生成一样的 Team ID。这样，不同的开发者账号发布的应用想共享 keychain 数据，在现在来看是无法实现的。而要做到 keychain 数据共享，要求是同一个开发账号开发的，同时选择了相同的 Team ID。

如果我们有多个APP，他们之间又需要互相共享一下数据，那么我可以考虑下使用keychain进行数据共享。

开启Keychain Sharing ，开启后会在工程中生成一份entitlements，表示keychain access groups，在Capabilities-keychain sharing 和 entitlements文件 都可以修改，内容为group的id，格式如下：

> 默认生成如下：
>
> $(AppIdentifierPrefix)你的bundleId
>
> 可以自定义用于创建独立组，自定义格式为：
>
> $(AppIdentifierPrefix)自定义内容



最后还需要提醒一点的是，如果你的帐号有多个AppIdentifierPrefix（team帐号），一需要确认一下你的mobileprovision文件里面的keychain-access-groups是否和你的keychain.entitlements文件定义的一致，否则xcode会报错。具体查看mobileprovision的方法是：命令行cat一下

这样你们既有自己私有的空间也有公共的空间



iOS应用安全机制

keychain

http://www.jianshu.com/p/3afc39f6b9a8

http://blog.csdn.net/ibcker/article/details/24839143

http://www.cocoachina.com/ios/20161129/18215.html



在开启 keychain的时候，生成的entitlements默认生成了一个item，填写的是当前app的bundleID，但其实应该是TeamID，前面还有前缀：AppIdentifierPrefix

例如： 98XXXXXXAXTT.com.yang.OCDemoTwo

默认写入的keychain在entitlements的第一项，加入有一部分内容你不希望分享给兄弟app，那么就可以单独设立一个share的group专门用于分享内容

entitlements 中写入的item只要共享数据的app填写相同即可，不需要特殊，

如果在默认情况下，app默认是存在当前teamID这个名字的group下面，所以如果两个App希望全部共享对方的keychain内容，则只需要把两个app的teamID 都填入keychain groups即可。

正常情况下我们会开启独立分享组：

第一项item为自己的teamID，第二项为我们需要共享的keychain组组名

当我们需要分享时，把内容指定存入分享组内，不需要分享时默认存放即可





keychain 维持唯一UUID





keychain 存放在哪？



codesign



```
 [self haveBundleIdentifier];//获取BundleIdentifier
    [self haveappidentifierprefix];//获取appidentifierprefix
   [self haveBundleExecutable];//获取项目名称
- (void)haveBundleExecutable{


- (void)haveappidentifierprefix{
    NSString * prefix = [self bundleSeedID];
    NSLog(@"prefix-->%@",prefix);
    
}

- (NSString *)bundleSeedID {
    NSDictionary *query = [NSDictionary dictionaryWithObjectsAndKeys:
                           kSecClassGenericPassword, kSecClass,
                           @"bundleSeedID", kSecAttrAccount,
                           @"", kSecAttrService,
                           (id)kCFBooleanTrue, kSecReturnAttributes,
                           nil];
    CFDictionaryRef result = nil;
    OSStatus status = SecItemCopyMatching((CFDictionaryRef)query, (CFTypeRef *)&result);
    if (status == errSecItemNotFound)
        status = SecItemAdd((CFDictionaryRef)query, (CFTypeRef *)&result);
    if (status != errSecSuccess)
        return nil;
    NSString *accessGroup = [(__bridge NSDictionary *)result objectForKey:kSecAttrAccessGroup];
    NSArray *components = [accessGroup componentsSeparatedByString:@"."];
    NSString *bundleSeedID = [[components objectEnumerator] nextObject];
    CFRelease(result);
    return bundleSeedID;
}


- (void)haveBundleIdentifier{
    NSString * identifier = [[NSBundle mainBundle]bundleIdentifier];
    NSLog(@"identifier--->%@",identifier);
}

- (void)haveBundleExecutable{

    NSString *executableFile = [[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString *)kCFBundleExecutableKey];    //获取项目名称
    NSLog(@"executableFile-->%@",executableFile);
    
    NSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString *)kCFBundleVersionKey];      //获取项目版本号
    
    
    
    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];
    NSLog(@"infoDictionary-->%@",infoDictionary);
    // app名称
    NSString *app_Name = [infoDictionary objectForKey:@"CFBundleDisplayName"];
    // app版本
    NSString *app_Version = [infoDictionary objectForKey:@"CFBundleShortVersionString"];
    // app build版本
    NSString *app_build = [infoDictionary objectForKey:@"CFBundleVersion"];
}
```







https://www.apple.com/business/docs/iOS_Security_Guide.pdf

http://blog.csdn.net/ibcker/article/details/24839143

http://www.jianshu.com/p/72c1f9d3a58c