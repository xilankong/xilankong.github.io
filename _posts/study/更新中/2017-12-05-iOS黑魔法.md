 isa-swizzling

runtime

http://www.jianshu.com/p/a0aaf0ffe6e1

http://www.jianshu.com/p/829864680648

\

objc_class  *Class



kvo实现

https://juejin.im/entry/59e5c3306fb9a0451329c47b

http://www.jianshu.com/p/ff19c04b34d0

http://www.jianshu.com/p/59b2b0ad6401





1、浩大工程需要每一个控制器添加进入统计功能



```
Category
我们可以为UIViewController建一个Category，然后在所有控制器中引入这个Category。当然我们也可以添加一个PCH文件，然后将这个Category添加到PCH文件中。
我们创建一个Category来覆盖系统方法，系统会优先调用Category中的代码，然后在调用原类中的代码。
我们可以通过下面的这段伪代码来看一下：

#import "UIViewController+EventGather.h"

@implementation UIViewController (EventGather)

- (void)viewDidLoad {

NSLog(@"页面统计:%@", self);

}

@end

Method Swizzling



```



异常

```
UIViewController (test)

+ (void)load {
    Method from = class_getInstanceMethod([self class], @selector(viewDidLoad));
    Method to = class_getInstanceMethod([self class], @selector(huang_viewDidLoad));
    
    if (!class_addMethod([self class], @selector(huang_viewDidLoad), method_getImplementation(to), method_getTypeEncoding(to))) {
        method_exchangeImplementations(from, to);
    }
}

-(void)huang_viewDidLoad {
    NSLog(@"交换后方法");
    [self huang_viewDidLoad];
}

ViewController

- (void)viewDidLoad {
    NSLog(@"这个是什么");
    [super viewDidLoad];
    NSLog(@"这个是VC");
}

打印结果：
2017-12-06 10:55:58.234808+0800 OcDemo[25497:1013706] 这个是什么
2017-12-06 10:55:59.215341+0800 OcDemo[25497:1013706] 交换后方法
2017-12-06 10:56:01.623221+0800 OcDemo[25497:1013706] 这个是VC


原因，我们写的扩展是基于 UIViewController ，而控制器的调用方式是先搜索子类，然后根据子类的复写的viewDidLoad方法去向父类（UIViewController）搜索 viewDidLoad 方法，而我们交换的其实是 UIViewController的实现，所以方法会先进入子类，然后再进入父类被交换方法。


```

#### Method Swizzling类簇

之前我也说到，在我们项目开发过程中，经常因为`NSArray`数组越界或者`NSDictionary`的`key`或者`value`值为`nil`等问题导致的崩溃，对于这些问题苹果并不会报一个警告，而是直接崩溃，感觉苹果这样确实有点“太狠了”。

由此，我们可以根据上面所学，对`NSArray`、`NSMutableArray`、`NSDictionary`、`NSMutableDictionary`等类进行`Method Swizzling`，实现方式还是按照上面的例子来做。但是....你发现`Method Swizzling`根本就不起作用，代码也没写错啊，到底是什么鬼？

这是因为`Method Swizzling`对`NSArray`这些的类簇是不起作用的。因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用`NSArray`的`objectAtIndex:`方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。

所以也就是我们对`NSArray`类进行操作其实只是对父类进行了操作，在`NSArray`内部会创建其他子类来执行操作，真正执行操作的并不是`NSArray`自身，所以我们应该对其“真身”进行操作。

###### 下面我们实现了防止`NSArray`因为调用`objectAtIndex:`方法，取下标时数组越界导致的崩溃：

```
#import "NSArray+LXZArray.h"
#import "objc/runtime.h"
@implementation NSArray (LXZArray)
+ (void)load {
    Method fromMethod = class_getInstanceMethod(objc_getClass("__NSArrayI"), @selector(objectAtIndex:));
    Method toMethod = class_getInstanceMethod(objc_getClass("__NSArrayI"), @selector(lxz_objectAtIndex:));
    method_exchangeImplementations(fromMethod, toMethod);
}

- (id)lxz_objectAtIndex:(NSUInteger)index {
    if (self.count-1 < index) {
        // 这里做一下异常处理，不然都不知道出错了。
        @try {
            return [self lxz_objectAtIndex:index];
        }
        @catch (NSException *exception) {
            // 在崩溃后会打印崩溃信息，方便我们调试。
            NSLog(@"---------- %s Crash Because Method %s  ----------\n", class_getName(self.class), __func__);
            NSLog(@"%@", [exception callStackSymbols]);
            return nil;
    }
        @finally {}
    } else {
        return [self lxz_objectAtIndex:index];
    }
}
@end

```

大家发现了吗，`__NSArrayI`才是`NSArray`真正的类，而`NSMutableArray`又不一样😂。我们可以通过`runtime`函数获取真正的类：

```
objc_getClass("__NSArrayI")

```

###### 下面我们列举一些常用的类簇的“真身”：

| 类                   | “真身”            |
| ------------------- | --------------- |
| NSArray             | __NSArrayI      |
| NSMutableArray      | __NSArrayM      |
| NSDictionary        | __NSDictionaryI |
| NSMutableDictionary | __NSDictionaryM |

其他自行Google....

#### Method Swizzling封装

在项目中我们肯定会在很多地方用到`Method Swizzling`，而且在使用这个特性时有很多需要注意的地方。我们可以将`Method Swizzling`封装起来，也可以使用一些比较成熟的第三方。
在这里我推荐**Github**上星最多的一个第三方－[jrswizzle](https://link.jianshu.com?t=https://github.com/rentzsch/jrswizzle)

里面核心就两个类，代码看起来非常清爽。
\#import <Foundation/Foundation.h>
@interface NSObject (JRSwizzle)
\+ (BOOL)jr_swizzleMethod:(SEL)origSel_ withMethod:(SEL)altSel_ error:(NSError**)error_;
\+ (BOOL)jr_swizzleClassMethod:(SEL)origSel_ withClassMethod:(SEL)altSel_ error:(NSError**)error_;
@end

```
// MethodSwizzle类
#import <objc/objc.h>
BOOL ClassMethodSwizzle(Class klass, SEL origSel, SEL altSel);
BOOL MethodSwizzle(Class klass, SEL origSel, SEL altSel);

```

#### Method Swizzling 错误剖析

在上面的例子中，如果只是单独对`NSArray`或`NSMutableArray`中的单个类进行`Method Swizzling`，是可以正常使用并且不会发生异常的。如果进行`Method Swizzling`的类中，有两个类有继承关系的，并且`Swizzling`了同一个方法。例如同时对`NSArray`和`NSMutableArray`中的`objectAtIndex:`方法都进行了`Swizzling`，这样可能会导致父类`Swizzling`失效的问题。

对于这种问题主要是两个原因导致的，首先是不要在`+ (void)load`方法中调用`[super load]`方法，这会导致父类的`Swizzling`被重复执行两次，这样父类的`Swizzling`就会失效。例如下面的两张图片，你会发现由于`NSMutableArray`调用了`[super load]`导致父类`NSArray`的`Swizzling`代码被执行了两次。

###### 错误代码：

```
#import "NSMutableArray+LXZArrayM.h"
@implementation NSMutableArray (LXZArrayM)
+ (void)load {
    // 这里不应该调用super，会导致父类被重复Swizzling
    [super load];

    Method fromMethod = class_getInstanceMethod(objc_getClass("__NSArrayM"), @selector(objectAtIndex:));
    Method toMethod = class_getInstanceMethod(objc_getClass("__NSArrayM"), @selector(lxz_objectAtIndexM:));
    method_exchangeImplementations(fromMethod, toMethod);
}

```

###### 这里由于在子类中调用了super，导致NSMutableArray执行时，父类NSArray也被执行了一次。

![img](http://upload-images.jianshu.io/upload_images/270478-938623cd9bf7c7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508)

第一次

###### 父类NSArray执行了第二次Swizzling，这时候就会出现问题，后面会讲具体原因。

![img](http://upload-images.jianshu.io/upload_images/270478-64b94e4bd8ce3ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508)

第二次

这样就会导致程序运行过程中，子类调用`Swizzling`的方法是没有问题的，父类调用同一个方法就会发现`Swizzling`失效了.....具体原因我们后面讲！

还有一个原因就是因为代码逻辑导致`Swizzling`代码被执行了多次，这也会导致`Swizzling`失效，其实原理和上面的问题是一样的，我们下面讲讲为什么会出现这个问题。

###### 问题原因

我们上面提到过`Method Swizzling`的实现原理就是对类的`Dispatch Table`进行操作，每进行一次`Swizzling`就交换一次`SEL`和`IMP`(可以理解为函数指针)，如果`Swizzling`被执行了多次，就相当于`SEL`和`IMP`被交换了多次。这就会导致第一次执行成功交换了、第二次执行又换回去了、第三次执行.....这样换来换去的结果，能不能成功就看运气了😄，这也是好多人说`Method Swizzling`不好用的原因之一。

###### 一图胜千言：

![img](http://upload-images.jianshu.io/upload_images/270478-ffaca421e1b8a5ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

Dispatch Table 交换流程

从这张图中我们也可以看出问题产生的原因了，就是`Swizzling`的代码被重复执行，为了避免这样的原因出现，我们可以通过**GCD**的`dispatch_once`函数来解决，利用`dispatch_once`函数内代码只会执行一次的特性。

在每个`Method Swizzling`的地方，加上`dispatch_once`函数保证代码只被执行一次。当然在实际使用中也可以对下面代码进行封装，这里只是给一个示例代码。

```
#import "NSMutableArray+LXZArrayM.h"
@implementation NSMutableArray (LXZArrayM)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        Method fromMethod = class_getInstanceMethod(objc_getClass("__NSArrayM"), @selector(objectAtIndex:));
        Method toMethod = class_getInstanceMethod(objc_getClass("__NSArrayM"), @selector(lxz_objectAtIndexM:));
        method_exchangeImplementations(fromMethod, toMethod);
    });
}

```

这里还要告诉大家一个调试小技巧，已经知道的可以略过😊。我们之前说过`IMP`本质上就是函数指针，所以我们可以通过打印函数指针的方式，查看`SEL`和`IMP`的交换流程。

###### 先来一段测试代码：

```
Method fromMethod = class_getInstanceMethod(objc_getClass("__NSArrayI"), @selector(objectAtIndex:));
Method toMethod = class_getInstanceMethod(objc_getClass("__NSArrayI"), @selector(lxz_objectAtIndex:));

NSLog(@"%p", method_getImplementation(fromMethod));
NSLog(@"%p", method_getImplementation(toMethod));
method_exchangeImplementations(fromMethod, toMethod);

NSLog(@"%p", method_getImplementation(fromMethod));
NSLog(@"%p", method_getImplementation(toMethod));
method_exchangeImplementations(fromMethod, toMethod);

NSLog(@"%p", method_getImplementation(fromMethod));
NSLog(@"%p", method_getImplementation(toMethod));
method_exchangeImplementations(fromMethod, toMethod);

NSLog(@"%p", method_getImplementation(fromMethod));
NSLog(@"%p", method_getImplementation(toMethod));

```

###### 看到这个打印结果，大家应该明白什么问题了吧：

```
2016-04-13 14:16:33.477 [16314:4979302]      0x1851b7020
2016-04-13 14:16:33.479 [16314:4979302]      0x1000fb3c8
2016-04-13 14:16:33.479 [16314:4979302]      0x1000fb3c8
2016-04-13 14:16:33.480 [16314:4979302]      0x1851b7020
2016-04-13 14:16:33.480 [16314:4979302]      0x1851b7020
2016-04-13 14:16:33.480 [16314:4979302]      0x1000fb3c8
2016-04-13 14:16:33.481 [16314:4979302]      0x1000fb3c8
2016-04-13 14:16:33.481 [16314:4979302]      0x1851b7020

```

------

#### Method Swizzling危险吗？

既然`Method Swizzling`可以对这个类的`Dispatch Table`进行操作，操作后的结果对所有当前类及子类都会产生影响，所以有人认为`Method Swizzling`是一种危险的技术，用不好很容易导致一些不可预见的**bug**，这些**bug**一般都是非常难发现和调试的。

这个问题可以引用[念茜](https://link.jianshu.com?t=http://blog.csdn.net/yiyaaixuexi)大神的一句话：`使用 Method Swizzling 编程就好比切菜时使用锋利的刀，一些人因为担心切到自己所以害怕锋利的刀具，可是事实上，使用钝刀往往更容易出事，而利刀更为安全。`

------

在这个`Demo`中通过`Method Swizzling`，简单实现了一个崩溃拦截功能。实现方式就是将原方法`Swizzling`为自己定义的方法，在执行时先在自己方法中做判断，根据是否异常再做下一步处理。

`Demo`只是来辅助读者更好的理解文章中的内容，**应该博客结合Demo一起学习，只看Demo还是不能理解更深层的原理**。`Demo`中代码都会有注释，各位可以打断点跟着`Demo`执行流程走一遍，看看各个阶段变量的值。



