---
layout: post
category: 学习之路
title : "iOS开发组件化、模块化"
---

## iOS开发组件化、模块化



为什么要执行组件化、模块化？简单了解一下什么是组件和模块：

**组件：**常用的独立组件，比如一个异步渲染富文本的Label组件

**模块：**业务中相对独立的区块，比如社区模块

无论是组件或者是模块（后续都统称为组件），他们的特性就是，如果缺少这一部分内容，主工程应该可以正常使用，只是缺少了相应功能。所以，如果代码全挤在一个project里面的后果就是业务难以拆分，随着迭代，越来越繁重。而且很多产品需要相对独立，可能就是为了一个活动上线，下个活动就要完全移除。

想象一下如果每一个独立的业务都是单独的，通过接口插入的方式与主工程通信，这种情况下迭代起来是不是方便，直观很多。

### 大神的组件化：

[casa](https://casatwy.com/iOS-Modulization.html)

[bang](https://blog.cnbang.net/tech/3080/)

这里记录一下我学习的组件化、模块化知识。

注意点：

```
组件之间不允许代码侵入

业务模块只能直接依赖基础组件，而不能直接依赖其他业务模块

通信直接用字典这种通用数据结构，不要使用model等依赖性强的方式
```



### 需要解决的问题：

1、本地无依赖调用组件

2、URL远程（H5调用、App唤起等）调用组件  （属于本地调用的子集）

### 解决方案：

1、使用工具：[cocoapods](https://guides.cocoapods.org)

2、通信方案：[iOS路由跳转](https://xilankong.github.io/2017年/2017/03/02/IOS路由跳转.html)

先介绍一个东西，叫路由跳转，具体实现，上面有代码

这个路由相当于我们自己定制一套二级路由表，也叫中间层，用于避免组件之间的代码侵入。

#### 路由表实例的解决方案：

**一级路由表（Route）**，Route类实现url解析、二级路由的查找、路由转发等工作，每一个组件对应一个Route分类，保存与自己组件内的二级路由表约定的通信方法。整个一级路由表作为一个独立组件以pod的方式引入，外部调用通过全局Route实例即可调用。

```
一级路由表相当于大交通，一级路由表之间的通信方式通过使用分类来解决，都是分类的情况下，互相调用和转发也就很方便了。

如果组件名称，需要调用的方法、参数都由调用的时候来传入，那么一级路由相当于只有一套方法就可以维护运行。

而开发中为了减少使用难度，会简化常用的操作，固化一些操作，这些操作也就是存放在分类中。然后再转发到二级路由。

```

**二级路由表**，以Target_XXX的方式命名的类，每个组件都有一份或多份，保存与组件内具体逻辑实现的通信约定方法

```
一级路由表寻址二级路由表的方式：通过runtime的 string->class的方式找到指定二级路由表，所以二级路由表的类名需要被约束：Target_XXXX，XXXX就是组件功能名称，例如：
Target_URLParseActions.h

二级路由中的方法也需要以同样的方式获取，所以方法名也需要被约束： Action_XXXX,XXXX就是方法功能名称，例如：
- (UIViewController *)Action_pushToViewControllerTwoWithParam:(NSDictionary *)param;

runtime获取路由表指定方法：
NSString *targetClassString = [NSString stringWithFormat:@"Target_%@",targetString];
NSString *selString = [NSString stringWithFormat:@"Action_%@",actionString];

获取到指定方法后调用，到此我们成功与组件无依赖通信。
```



**二级路由的好处：**

1、每个组件有独立的路由表，每个组件独立开发的时候，只需要知道需要开放出去什么，按约定规则写好路由方法即可。

2、主工程接入的时候不需要依赖组件，只需要依赖一级路由表即可，在路由表中按每个组件提供的路由方法需求就可以调起组件。

3、有一个地方统一管理组件交通（树级结构），开发更加明了直观。

