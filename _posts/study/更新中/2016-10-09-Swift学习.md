---
layout: post
category: 学习之路
title : "Swift 学习"
---

熟悉 Swift 3.0 过程中 学习到的东西。

Swift是强类型。

1.操作符

```
1...3 闭区间 包括 1、2、3

1..<3 开区间 包括 1、2


```



2.语法糖、自动识别类别

```
Array<String> 的语法糖： [String]
Dictionary<String, String> 的语法糖: [String : String]
var array: [String]?
//自动识别类型
var dict: [String : String] = [:] 
var arrayWithDict:[[String : String]]?
```



3.数组在Swift

```
// 创建数组
var array: [String] = []
var array = [String]()
var array = Array(repeating:0,count:5);  -> [0,0,0,0,0]

// 数组可以直接相加 直接加数组 
var anotherThreeDoubles = Array(repeating: "2.5", count: 2)
var sixDoubles = anotherThreeDoubles + anotherThreeDoubles
// sixDoubles类型是 [String], 包含元素:["2.5", "2.5", "2.5", "2.5"]
sixDoubles = sixDoubles + ["2.5"]

array = ["111","222","333"]
array[0...1] = ["444","555"];
print(array)
结果: ["444", "555", "333"]

array = ["111","222","333"]
array[0...2] = ["444","555"]; // 0...2 size 为3 ，后面数组size为 2
print(array)
结果: ["444", "555"]  //并不会出现两边因为数组size不一样产生错误，以更小size为准

array.

// 数组中只能存储同一类型的数据

// 数组常用方法
append(_ newElement: Element) 添加元素
insert(_:at:): 在某个位置插入元素  不能超出数组大小
remove(at:): 移除某个位置的元素
removeLast(): 移除最后一个元素
enumerated(): 该方法返回一个包含索引和对应位置的值的元祖(tuple)数组(Example)。


// 遍历数组
for i in 0..<array.count {
    print(array[i])
}
// forin 方式
for item in array {
    print(item)
}
// 设置遍历的区间
for item in array[0..<2] {
    print(item)
}
// enumerated 遍历
for en in array2.enumerated() {
    print(en)
    // 下标
    print(en.offset)
    // 值
    print(en.element)
}
// 下标和数值同时遍历   元祖
for (n,s) in array2.enumerated() {
     print(n , "==", s);
}
// 反序遍历
for s in array2.reversed() {
    print(s)
} 
// 遍历下标和数值 反序
for (xxx,ooo) in array2.enumerated().reversed() {
    print(xxx ,"====" ,ooo)
}
```



4.字典在Swift

```
字典构建方法  

var dict : [String : String] = [:] 表示空字典
var empty_dic = Dictionary<String, String>()
var dict : Dictionary<String,String> = Dictionary.init();
var airports : Dictionary<String, String> = ["TYP":"Tokyo", "DUB":"Boublin"]
var airports2 = ["TYP":"Tokyo", "DUB":"Boublin"]

字典的使用

var port: String = airport2["TYP"] //根据key获取value
port["one"] = "two" //添加键值对
```



4.swift 和 oc 交互 ，工程文件

```
swift 和 OC 混用会有两个新文件 

1、工程名-Swift.h 是 用于 oc 调用 swift 、是swift代码在工程中自动更新出的oc格式代码
 不可见，但是可以跳转进入，所有swift代码生成的类属性 都会在这个文件中转义一份oc的样式 

2、工程名-Bridging-Header.h 是用于 swift 调用 oc 的头文件，所有需要引入swift的OC都需要先在这个文件引入。
```



5. swift 有命名空间 直接取className 名字会有区别

```
swift的类名 转成 oc 自带了格式，并非直接名字。所以通过class去寻找指定类需要转className

在swift根据类名找xib也需要注意命名空间，一般是 工程名.类名

//获取xib
  class func nib() -> UINib {
      let className = NSStringFromClass(self)
      let postfix = className.components(separatedBy: ".").last
      return UINib(nibName: postfix!, bundle: nil)
  }

//获取对应className
- (Class)swiftClassFromString:(NSString *)className {
  	NSString *appName = 
  	[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"];
	NSString *classStringName = 
	[NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className];
  	return NSClassFromString(classStringName);
}
```



6. 闭包

```
Swift 3.0 中 @noescape  变成默认属性

@escaping  逃逸闭包

逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行

@autoclosure 自动闭包   自动闭包应用场景

顾名思义是一种自动创建的闭包，用于包装函数参数的表达式，可以说是一种简便语法

(1)默认非逃逸

(2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。

(3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。

(4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。

(5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。

(6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要在类型前面手动声明: @autoclosure @escaping 


自动闭包的使用




声明函数时，在参数的类型前面用inout修饰，在函数内部实现改变外部参数,方法调用的时候参数需要 &  (&在形参中表示“引用”实参)

var str = "789789"
getOne(&str)
print(str)

func getOne(_ b:inout String){
    b = "123456"
}
结果：123456
```



7. swift lazy属性 懒加载

    //定义一个闭包
    lazy var html: () -> String = {
       if let text = self.text {
            return "11111"
        } else {
            return "2222"
        }
    }
    //定义一个字符串
    lazy var second:String = {
        if let text = self.text {
            return "11111"
        } else {
            return "2222"
        }
    }()  
    //如果定义的不是闭包，而是需要返回值的，那么不要忘记最后的小括号，只有加了小括号，必包才会在调用的时候立刻执行。
    //要类型声明lazy var second:String，这样Xcode会进行类型检查。

    懒加载初始化的定义
    懒加载初始化只进入一次  并且在需要的时候才调用

    在Objective C中， 懒加载初始化是这样写的
    @property (strong,nonatomic) CAShapeLayer * shapelayer;
    -(CAShapeLayer *)shapelayer{   
    if (!_shapelayer) {       
          _shapelayer = [CAShapeLayer layer];    
     }    
         return _shapelayer;
    }

    Swift中，有两种方式来 懒加载初始化。 

    第一种，简单表达式

    lazy var first = NSArray(objects: "1","2")

    第二种，闭包

    lazy var second:String = {return "second" }()

8. 懒加载初始化的使用场景



​    
    1、属性本身依赖于外部因素才能初始化 
    completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀
    class Demo{    
    var url:NSString   
    lazy var completeURL:NSString = {       
       [unowned self] in       //防止闭包循环
       if self.url.hasPrefix("http://"){           
         return self.url        
      }else{            
         return "http://".stringByAppendingString(self.url)        
      }        
    }()    
    
    init(url:NSString){       
     self.url = url    
    }}
    
    2、属性需要复杂计算，消耗大量CPU
    
    lazy var second:Int = {       
    	var sum = 0        
    	for i in 1...100000{ sum += i}        
    	return sum        
    }()
    
    3、属性不确定是否会使用到
    
    官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化。
    
    4、定制化的初始化 
    
    有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护
    
    lazy var dataArray:NSMutableArray = {
      var array = NSMutableArray()        
      for  i in 1...100{
        array.addObject(NSNumber(integer: i))        
      }        
      return array        
    }()





11. 自定义表达式

```
infix  prefix  postfix 自定义表达式  实现 swift3.0  

比如定义一个  ** 表达式  

infix operator **   //这句话只能定义在文件，类的外面，其余类可以针对这个定义 做不同实现

//下面这里 实现是类似 ?? 方法 ，扩展optional    实现这么一个方法   static 方法

extension Optional {

	static func ** <T>(optional : T? , defaultValue : @autoclosure () -> T) -> T {}

}
```

12.weak 和 unowned 闭包内部防止循环引用

“用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 "无效的" 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。”

swift 打印内存地址

```
print(Unmanaged<AnyObject>.passUnretained(spacetwo as AnyObject).toOpaque())
```

swift 等号判断

```
var a: NSString = "abc", b = a, c: NSString = "abc"  
  
println(a == b) //true  
println(a == c) //true  
println(a === b) //true  
println(a === c) //false ＝＝＝ 运算符可以判断是否对同一对象的引用   比较内存地址
```



swift 代码补全

http://www.jianshu.com/p/bbbfc524ca93



13.注释

    // MARK: - 操作
    // TODO: - 记得做
    // FIXME: - 提醒



14.

NS_DESIGNATED_INITIALIZER   指定某个OC方法为 designated initializer  因为swift  继承oc类出来 实现init方法外必须要实现一个designated （指定构造方法） init方法 

15.

宏和 const static 的区别 多用static



16.

swift 不能调用oc 类方法

17.

swift delegate 代理调用 不再使用resonse响应去校验方法是否存在

直接optional去调用就可以  

  self.delegate?.GXQActionSheetClickAtIndex(index: type!, viewController: self)

**18.swift 枚举 和 oc枚举**

```
swift 枚举 
    var result = Planet.One;
    result = .two;
    switch result {
      case .one:
       print("执行One");
      case .two:
       print("执行Two");
      default:
       print("执行Default");
    }

元祖 枚举
 enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
    
    //元祖的方式可以把枚举作为一个计算类了，可带参数进switch的方便 
    //例如二维码和条码的大类，我们有N个不同的码，可能是二维码 也可能是条码
    //但是每个二维码又不一样的情况 我们就需要按大类判断。
    //没有元祖之前我们处理这个问题就是定义两个继承类 分别代表二维码和条码，都有一个枚举属性，通过这个属性来区分判断。？？？？？
    var productBarcode = Barcode.upc(8, 85909, 51226, 3)
    productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
    
    switch productBarcode {
    case .upc(let numberSystem, let manufacturer, let product, let check):
        print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
    case .qrCode(let productCode):
        print("QR code: \(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."
    
```

**OC枚举方式 :**

typedef NS_ENUM  推荐使用

typedef enum

**swift枚举方式 :**

```
@objc enum FPCheckResult: NSInteger{
    case success         //成功
    case sailed          //失败
    case passcodeNotSet //未设置手机密码
    case touchidNotSet  //未设置指纹
    case touchidNotAvailable //不支持指纹
}大驼峰命名名称 小驼峰命名成员

swift 定义的枚举在OC中使用 会自动把枚举名字添加到前面做前缀  比如FP_SUCCESS 适配在OC中是 FPCheckResultSuccess

不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的FPCheckResult例子中，Success，Failed，PasscodeNotSet和TouchidNotSet不是隐式得等于0，1，2和3。相反的，这些不同的枚举成员在FPCheckResult的一种显示定义中拥有各自不同的值。

oc 定义的枚举  大驼峰命名规则
注意：OC中定义的枚举在OC中可以不需要通过枚举名字获取，但在swift中需要用枚举.方法获取，所以把枚举名字写在枚举变量前面做前缀， swift解析的时候会自动去掉前缀。既方便oc又方便swift。
typedef NS_ENUM(NSInteger, FundType) {
    FundTypeMonetary   = 1,//公募货币基金
    FundTypeBond       = 2,//公募债基基金
};

多个成员值可以出现在同一行上，用逗号隔开：
enum Planet { 
    case mercury, venus, earth, mars, jupiter, saturn, uranus, nepturn 
} 

var directionToHead = CompassPoint.west 

一旦一个熟悉 被定义成一个枚举后，如上，或者switch 指定等。 就可以直接用点方法给属性设置其他枚举成员。



下面的枚举是对之前Planet这个枚举的一个细化，利用原始整型值来表示每个 planet 在太阳系中的顺序：
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
自动递增意味着Planet.venus的原始值是2，依次类推。
 
使用枚举成员的rawValue属性可以访问该枚举成员的原始值：
let earthsOrder = Planet.earth.rawValue 
// earthsOrder is 3 

通过rawValue去获取对应枚举成员
let possiblePlanet =Planet(rawValue: 7)
// possiblePlanet is of type Planet? and equals Planet.Uranus 


如果没有指定枚举类型 是无法获取rowValue的 
```

如果需要在oc中使用swift定义的枚举 需要加上 @objc前缀  如果是swift定义的协议 也是一样的

19.

swift 自定义运算符

新的运算符声明需在全局域使用operator关键字声明，可以声明为前置，中置或后置的。

当之前定义过的运算符 可以直接重载成其他参数类型 

```
func += <K,V>( left:inout [K:V], right:[K:V] ) {
    right.forEach { (key, value) in
        left.updateValue(value, forKey: key)
    }
}
func + <K,V>(left: [K:V], right:[K:V]) -> [K:V] {
    var result = left
    result += right
    return result
}
```

20.

swift写法

```

- (NSString *)cellIdentify{
    return @{@(HomeItemTypeAssetsHead).stringValue:@"AssetsHeadTableViewCell",
             @(HomeItemTypeRedPacket).stringValue:@"NewUserRedPacketTableViewCell",
             @(HomeItemTypeIntroduce).stringValue:@"IntroduceTableViewCell",
             @(HomeItemTypeProduct).stringValue:@"GXQRecommendProductCell",
             @(HomeItemTypeNotice).stringValue:@"HomeNoticeTableViewCell",
             @(HomeItemTypeAssetsCell).stringValue:@"HomeAssetsTableViewCell",
             @(HomeItemTypeXueBi).stringValue:@"HomeXuebiTableViewCell",
             @(HomeItemTypeCarousel).stringValue:@"HomeCarouselTableViewCell"}
    [@(self.type).stringValue];
}
```

21.

函数式

```
var newEvens = [Int]()
for i in 1...10 {
  if i % 2 == 0 {
         newEvens.append(i)
    } 
}
print(newEvens) // [2, 4, 6, 8, 10]

可以写成

var evens = Array(1...10).filter { $0 % 2 == 0 } 
print(evens) 
// [2, 4, 6, 8, 10]

```

22.

swift 绑定xib的时候 不能直接用className 去查找对应nib  因为swift存在域名 前面有工程名的前缀

swift viewController xib初始化的时候要实现init（）里面super.init（根据xib名字去初始化）

23.

        topImageView.mas_makeConstraints {
            $0?.top.leading().bottom().equalTo()(self)
            $0?.width.equalTo()(self.bgImageView.mas_width)?.multipliedBy()(0.0)
        }
        
        1.msonry可以校验宽度，比如占父类百分之多少宽度
        2.swift $0? 参数
        3.msonry可以校验宽度会引发的问题
        4.make.leading.equalTo(leftView.mas_trailing);  mas_right 和 mas_trailing 不是同一个东西，一套不能和另一套混用
柯里化

24.

swift 异常捕获

25.

swift强类型  float 和 int 不能相减



16. swift命名规则

```
对类、结构体、枚举和协议等类型命名，应该采用大驼峰法，如SplitViewController。

文件名，采用大驼峰法，如BlockOperation.swift。

扩展文件，有的时候扩展是定义在一个独立的文件中的，它的命名是“原始类型名+扩展名”作为扩展文件名，如NSOperation+Operations.swift。

变量和属性，采用应该采用小驼峰法，如studentNumber。

常量，采用大驼峰法，如MaxStudentNumber。

枚举成员，与常量类似，采用大驼峰法，如ExecutionFailed。

函数和方法，采用应该采用小驼峰法，如balanceAccount、isButtonPressed等。
```

27.

```
var nameOne: String?
nameOne = "one"
if let name = nameOne {
    print(name)
}
如果变量的可选值是 nil ，条件会判断为 false ，并且大括号中的代码会被跳过。如果不是nil，会将值赋给let后面的常量，这样代码块中就可以使用这个值了。

```

28.switch

```
使用switch 支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。
运行 switch 中匹配到的子句之后，程序会退出switch语句，并不会继续向下运行，所以不需要在每个子句结尾写break。

let age = 15
switch age {
case 0...10:
    print("000")
case let x:
    print(x)
default:
    print("111")
}

一定要有必执行项 （default，let x 这种）不然编译错误：switch must be exhaustive

fallthrough:【紧跟的后一个】case条件不能定义常量和变量
fallthrough 后面项不能是let x


```

29.for循环

```
for num in 0...3 {
    print(interestingNumbers[num])
}
和
for num in 0..<3 {
    print(interestingNumbers[num])
}
的区别 ... 指0到3之间包括下界(1，2，3，4) , ..< 不包括下界(0，1，2)
        
        
```

30.泛型

```
extension Array {
//Element 这个地方使用Element的原因是array中默认元素类型是Element
    public func my_map<T>(_ element: (Element) -> T) -> [T] {
        var array_new = Array<T>()
        for item in self {
            let item_new = element(item)
           array_new.append(item_new)
        }
        return array_new
    }
}

限制泛型类型，例如所有的泛型参数都要实现 NameSpaceProtocol 协议，如下两种写法
func getTwo<T>(_ E : T) where T : NameSpaceProtocol{
}
func getTwo<T : NameSpaceProtocol>(_ E : T){
}


```

31.Swift控制器初始化问题

```
子类的定义通过 : 后面紧跟父类名称的方式。
当然不是每个类都需要标准的根类，所以可以忽略父类。

1、指定或便捷初始化器在类中被调用；
2、为这个类的新实例分配内存。内存还没有被初始化；
3、这个类的指定初始化器确保所有由此类引入的存储属性都有一个值。现在这些存储属性的内存被初始化了；
4、指定初始化器上交父类的初始化器为其存储属性执行相同的任务；
5、这个调用父类初始化器的过程将沿着初始化器链一直向上进行，直到到达初始化器链的最顶部；
6、一旦达了初始化器链的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为完全初始化了，此时第一阶段完成。

swift 的初始化两阶段，第一阶段是类的分配地址 并且给类的属性分配一个地址
位于super.init 之前。如果没有父类，就应该是所有的属性都有值之后算第二阶段。

第二阶段就是super.init 之后，self已经具体实现完成，可以调用方法，并且可以进行定制，super.init 是为了完成到父类实现init的委托。这个是具体的实现。

安全检查
1、指定初始化器必须保证在向上委托给父类初始化器之前，其所在类引入的所有属性都要初始化完成。
2、指定初始化器必须先向上委托父类初始化器，然后才能为继承的属性设置新值。如果不这样做，指定初始化器赋予的新值将被父类中的初始化器所覆盖。
3、便捷初始化器必须先委托同类中的其它初始化器，然后再为任意属性赋新值（包括同类里定义的属性）
4、初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 self 作为值。
违背检查规则的都无法通过编译。

在OC中得 init方法内
- (instancetype)init
{
    NSLog(@"%@",self); //这个时候self已经被分配地址，他得属性不能通过点符号点出，可以指向，说明地址也是被分配了。
    self = [super init];//具体实现 后面才可以调用方法
    if (self) {
    }
    return self;
}

关于初始化的继承
规则 1
如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。

规则 2
如果子类提供了所有父类指定构造器的实现--不管是通过规则1继承过来的，还是通过自定义实现的--它将自动继承所有父类的便利构造器。因为便利构造器都是基于指定构造器的


初始化方法的问题
特别是swift继承oc类的情况

1.swift继承自swift 的情况下 父类的构造器，自动继承所有父类的指定构造器
2.如果实现了所有的父类指定构造器 将自动继承所有的便利构造器

swift继承自oc的时候会出现一种情况 就是 要求实现指定构造器
当AswiftController继承一个BOCcontroller的时候，BocController中必须要有一个指定构造方法
UIViewController默认的指定构造方法是
- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil NS_DESIGNATED_INITIALIZER;

或者我们自己指定一个指定构造方法，也就是说在OC中写一个构造方法，并用 NS_DESIGNATED_INITIALIZER 标示标出，那么在swift中得构造方法就必须实现这个构造方法，

OC控制器 A
swift控制器  B 继承自 A
OC控制器 C
swift控制器 B 继承自OC控制器 A ，然后又再另一个OC  C 调用 B 控制器 ，oc调用 直接alloc init 那么就会调用到 B 控制器中 的非指定构造器 init方法，在特定系统（8.几）运行过程中会报错，所以我们需要在swift 继承自OC的时候就复写指定构造器方法，并实现init方法，在方法中调用父类指定构造器。

Swift 实现的控制器 需要实现init方法
init() {
    super.init(nibName: nil, bundle: nil)
}
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
或者在B 的父类 A 中实现init方法，并在方法中通过指定构造器实现初始化(initWithNIB)
B：
init() {
    super.init()
}
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
A：
- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
    if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) {
    }
    return self;
}
- (instancetype)init{
    return [self initWithNibName:nil bundle:nil];
}


指定构造器纵向实现（委托父类的指定构造器），遍历构造器横向实现(调用本身的指定构造器)

如果遍历构造器接收参数和父类指定构造器一样，需要在前面加上override

可空初始化器

struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
```

32.结构体

```
使用方法和类差不多

struct NameSpaceTwo {
    var length: Int
    var height: Int
    
    func countTwo() -> Int {
        return height + length
    }
}

和类的区别
 struct 是 Value Type 而 class 是 Reference Type ， Value Type是值类型，reference type 是引用类型
 
在每次做 assignment 的時候，value type 都会复制一份完整相同的內容給另一個变量，而 class 則是把内容对应的内存地址給变量。

let spacetwo = NameSpaceTwo(protocolParam: "8888", length: 5, height: 5)
let spacethree = spacetwo

print(Unmanaged<AnyObject>.passUnretained(spacethree as AnyObject).toOpaque())
print(Unmanaged<AnyObject>.passUnretained(spacetwo as AnyObject).toOpaque())

let 的方式的 struct 内部参数不能改变

spacethree 和 spacetwo 的改变都不会对对方产生影响。



mutating 关键字
使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。
```

33.协议

``` 
协议中定义的方法，依然是不能有方法体，协议可以设置参数，参数必须要设置{get} 或者 {get set}

使用 extension 为现有的类型添加功能，比如添加一个计算属性的方法。你可以在任何地方使用 extension 来给任意类型添加协议，甚至是从外部库或者框架中导入的类型。

你可以像使用其他命名类型一样，创建一个有不同类型但是都实现同一个协议的对象集合。当你处理协议类型的值时，协议外定义的方法不可用。都被当成协议类型对象处理

```

34.类型转换

```
swift 中没有 toInt toString等转换方法

let convertedNumber = Int(b)
print(convertedNumber ?? "")


如果 possibleNumber不能转换，将为 nil

在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针，它是一个确定的值，用来表示值的缺失。任何类型的可选都可以被设置为 nil，不只是对象类型。


if let dic = dic["currentProfit"] as? [String : Any] 

不推荐直接强转，在if条件句中可以进行解包和强转，因为if条件句中失败不会导致崩溃。
等号两边任意一个失败都不会执行
类似floatValue这种一定会有返回值的就不能在if中做这种处理。
```

35.断言 

```
release 情况  断言在 swift 无效 断言错误信息有在控制台打出，oc正常
```

36.swift   get set 

```
var count: String {
       return ""
}


var _count: String = ""  //防止循环引用
var count: String {
    get {
        return _count
    }
    set {
        _count = newValue;
    }
}
```

37.变量定义

```
var count: String {
    return ""
}
上面这种不用等号的方式，  下面这张使用了等号，那么左右两边类型必须一样，而右边给了一个闭包，显然和String类型不一样，所以闭包需要执行，并返回里面的内容 "" 保证两边类型一致
var count: String = {
    return ""
}()
```

38.两位小数

```
round(combinationFee  * 100)/100
```

39.

```
swift 工程中得main方法入口

@UIApplicationMain

```

40

```
所有的 Swift 代码都将被 LLVM 编译为 native code，以极高的效率运行。

按照官方今天给出的 benchmark 数据，运行时比 Python 快 3.9 倍，比 objc 快 1.4 倍左右。

另一方面，Swift 的代码又是可以 Interactive 来“解释”执行的。新的 Xcode 中加入了 Playground 来对开发者输入的 Swift 代码进行交互式的相应，开发者也可是使用 swift 的命令行工具来交互式地执行 swift 语句。

但是, Swift 其实也不是被解释执行的，而是在每个指令后进对从开始以来的 swift 代码行了一遍编译，然后执行的。这样的做法下依然可以让人“感到”是在做交互解释执行，这门语言的编译速度和优化水平，可见一斑。同时 Playground 还顺便记录了每条语句的执行时候的各种情况，叫做一组 timeline。可以使用 timeline 对代码的执行逐步检查，省去了断点 debug 的时间，也非常方便。

```

41

```
swift 工程中得main方法入口

@UIApplicationMain


http://www.tuicool.com/articles/fAZ3yef
```

42

```
1.swift程序的入口是@UIApplicationMain , OC 是main.m 中的main方法

2.OC的类是以.h和.m组成的 , swift是一.swift结尾的

3.OC的类是以@interface 和 @end开始结尾 , swift是采用{}

4.OC里语句结束以分号(;) ,  swift里不需要分号,添加分号也不会出错

5.OC中创建一个视图,采用alloc/init,swift采用();

6.OC中创建视图采用initWithXXX;swift里变成(XXX:)

7.swift设置属性,全面采用点语法;

8.OC中添加视图使用self.view.addSubView;swift添加视图使用view.addSubView,不使用self,为了在闭包里和构造函数里区分会在闭包里和够构造函数里用self;

9.OC中枚举需要写全,swift中采用type.类型的形式;

10.OC里的方法是采用@selector;swift采用”方法名”形式;

11.swift中的枚举可以省略前面的tyoe,直接采用点语法,只能提示不太好;

12.OC中打印使用NSLog,swift使用print;

13.等号左右两边最号用对等的空格;
```

43 https://www.oschina.net/translate/swift-vs-objective-c-10-reasons-the-future-favors-swift

44.

```
swift的nil可以用于所有数据类型,包括Int,Double,String,对象，数据结构，枚举。而不是想objc那样，对象用nil，数据结构有时用NSNotFound，指针用NULL。
```

45.

```
Swift 3.0 的 open，public，internal，fileprivate，private 关键字 
fileprivate和 open
fileprivate 类似之前的private ，文件内私有，单个文件内可以互相访问，
现在的private 就是真正意义的私有，即使同文件内 只要跨类了 就不能访问

open 相当于 可以外部继承 public现在不能外部继承



import Foundation
 
/// final的含义保持不变
public final class FinalClass { }
 
// 这个类在ModuleA的范围外是不能被继承的，只能被访问
public class PublicClass {
 
    public func testPublic() {}
 
    // 这是错误的写法，因为class已经不能被继承，
    // 所以他的方法的访问权限不能大于类的访问权限
    open func testOpen() {}
 
    // final的含义保持不变
    public final func testPublicFinal() {}
}
 
// 在ModuleA的范围外可以被继承
open class OpenClass {
    // 这个属性在ModuleA的范围外不能被override
    public var size : Int = 0
 
    // 这个方法在ModuleA的范围外不能被override
    public func testPublic() {}
 
    // 这个方法在任何地方都可以被override
    open func testOpen() {}
 
    ///final的含义保持不变
    public final func testPublicFinal() {}
}


import Foundation
import ModuleA
 
// 这个写法是错误的，编译会失败,类访问权限标记的是public，只能被访问不能被继承
class SubA : PublicClass { }
 
// 这样写法可以通过,Class访问权限为 `open`.
class SubB : OpenClass {
 
    // 这样写也会编译失败,因为这个方法权限为public，不是`open'.
    override func testPublic() { }
 
    // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写
    // 这里不需要再声明为open，因为这个类是internal的
    override func testOpen() { }
}
 
open class SubC : OpenClass {
    // 这种写法会编译失败
    override func testPublicFinal() { }
 
    // 正确的写法，方法也需要标记为open
    open override func testOpen() { }
}
 
open class SubE : OpenClass {
    // 也可以显式的指出这个方法不能再被override
    public final override func testOpen() { }
}
```

46.UIView swift 初始化

```
Swift:必须添加init?(coder decoder: NSCoder)的原因


当我们重写类的时候经常提示要添加代码：

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
这个叫必要初始化器，这种情况一般会出现在继承了遵守NSCoding protocol的类，比如UIView系列的类、UIViewController系列的类。

为什么一定要添加：
这是NSCoding protocol定义的，遵守了NSCoding protoaol的所有类必须继承。只是有的情况会隐式继承，而有的情况下需要显示实现。

什么情况下要显示添加：
当我们在子类定义了指定初始化器(包括自定义和重写父类指定初始化器)，那么必须显示实现required init?(coder aDecoder: NSCoder)，而其他情况下则会隐式继承，我们可以不用理会。

什么情况下会调用：
当我们使用storyboard实现界面的时候，程序会调用这个初始化器。
注意要去掉fatalError，fatalError的意思是无条件停止执行并打印。
在obj-c中可以通过下面代码实现

        NSException *exception = [NSException exceptionWithName:@"HotTeaException" reason:@"The tea is too hot" userInfo:nil];
        @throw exception;
总结：
如果代码实现界面，那么我们只要根据编译器提示添加必要初始化器后，就不用理会，我们创建界面的工作可以在自定义的初始化器里实现。

补充：let vc = UIViewController()方式初始化类
UIViewController类视乎只有两个初始化器，一个是必要初始化器init?(coder aDecoder: NSCoder)，一个是指定初始化器init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?)，那么为什么我们可以用let vc = UIViewController()这种方式初始化类呢？原因可能是这个初始化方式是来自uikit,也就是调用了Object-c下的UIViewController初始化方法，是object-c bridge过来的。

针对继承自OC的ViewController  为了解决 nib初始化的问题

swift 关于指定构造器 和便利构造器的 实现 和继承之类的问题  

1.当子类继承了父类的时候，如果子类没有覆盖任何父类的指定构造器，那么它也不能建立便利构造器，并且自动继承所有父类的指定构造器。
2.如果子类自己建立了指定构造器，并且未覆盖父类的指定构造器，那么它将失去所有的父类构造器的使用。
```

47.defer



48.

```
Int UInt的区别 带U表示无符号整数，不带U表示有符号整数 至于后面的位数选择，编译器会根据当前运行环境自动选择

swift中 除了十进制，还可以使用十六进制 (0x) 八进制 (0o) 二进制 (0b)
以及可以使用千位分隔符  let million = 1_000_000

Double(fifteen_10) //这里实际是重新生成了一个Double类型的值，并非类型转换

type(of:PI) 查看类型

PI = 15 + 314e-2  正常编译

let PI_fifteen = PI + fifteen_10    错误

String已经不单单是一个字符数组，泊学收获

更人性化 可读性更高的语言，

swift写代码思考方式

例如写guard

一个表达式 json["num"] as? String 解析成功，我们就绑定这个结果，guard let result =   json["num"] as? String ,  同时考虑其他情况，guard let result =   json["num"] as? String ,let num = Double(result) 最后 else return nil 

然后我们就可以正常使用josn解析出来的num了

1、定义变量 （介绍var、let、强类型、类型推断type inference）元祖，可以存任意多个数值 能用常量解决的问题，就不要用变量

当定义一个变量并未赋值的时候，是无法进行类型推断的，这个时候就需要声明类型 ：String



```

49.

```
swift 协议

属性要求
协议能够要求其遵循者必须含有一些特定名称和类型的实例属性(instance property)或类属性 (type property)，也能够要求属性的(设置权限)settable 和(访问权限)gettable，但它不要求属性是存储型属性(stored property)还是计算型属性(calculate property)。
 
通常前置var关键字将属性声明为变量。在属性声明后写上{ get set }表示属性为可读写的。{ get }用来表示属性为可读的。即使你为可读的属性实现了setter方法，它也不会出错。

protocol SomeProtocol { 
    var musBeSettable : Int { get set } 
    var doesNotNeedToBeSettable: Int { get } 
} 
```

50.

```
Optional

Swift中的Optional作为一种类型，既可以存储一个值，也可以为空（也就是swift里的nil）,通常在类型后面加一个？表示它是Optional类型的：

var number： Int? = 32
其实?只不过是一个语法糖，Optional的实际类型是一个enum:

enum Optional<T>: _Reflectable, NilLiteralConvertible {
    case None
    case Some(T)
    //...
}
上面的var number： Int? = 32也就可以表示为：

var numbet: Optional<Int> = 32
当然我们习惯上更习惯于表示为Int?

Optional的作用

一个Optional对象只存在两种状态：包含一个值，或者为空，我们都可以通过解包（unwrap）来获取。下面一段出自The Swift Programming Language (Swift 3)

The concept of optionals doesn’t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return nil from a method that would otherwise return an object, with nil meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as NSNotFound) to indicate the absence of a value. This approach assumes that the method’s caller knows there is a special value to test against and remembers to check for it. Swift’s optionals let you indicate the absence of a value for any type at all, without the need for special constants.
Swift通过引入Optional解决了Objective-C中“有”与“无”的问题，使代码的安全性得到了很大的提高，同时我们也应该知道，Swift是一种类型安全的语言。

在某些场景下，Optional能起到很大的作用:

当一些属性值可以为空时，比如一个Person类中，middleName，spouse这类的属性都可以为空
当一个方法可以返回空值，比如类型转换函数，官方文档的例子
//try to convert a String into an Int
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
// 如果possibleNumber 是“hello”,则转换不会成功，就会返回nil
如果在一个字典中，使用key获取对应的value时，返回的也应该是Optional的值，因为你也可能找不到key对应的value，此时返回nil
一个方法可以返回一个值，如果方法内部产生了错误，也可以什么都不返回
Delegate 属性（不总是需要被赋值）
class中weak 类型的属性，他们所指向的值可以为空
一个大的资源可以随时被释放，以节约空间，所以正常情况下都是空的，只有使用时才会请求赋值。
Optional Binding

出于类型安全的考虑，我们不能再把Optional当作Boolean值处理。像下面这条语句在swift中会遇到编译错误

var myString: String? = "Hello"
if myString {
    print(myString)
}
但是你可以通过==和!=，将Optional值和nil做比较来判断它是否包含一个值。如果不包含任何值，则为空。

if myString != nil{
    print("myString contain a string value of \(myString!)")
}
在上面的语句里，当我们确定myString包含一个值时，我们通过在myString后面添加一个!来进行强制解包(forced unwrapping)，获取Optional内包含的值。

但是实际上，Swift提供了一种更加方便的形式来完成这一过程，所谓的Optional Binding,看下面的代码：

if let actualString = myString {
    print("myString contain a string value of \(actualString )")
} else {
    print("myString is nil")
}
上面代码的意思是，如果optional string 包含一个值，我们就把这个值赋给actualString，然后就可以在if语句里继续使用它了，所以不再需要对其进行解包了，因为actualStr这样我们就用Optinal binding 代替了强制解包(forced unwrapping)。我们也可以使用if var actualString = myString 来获取actualString，则这个actualString就是var类型的。

隐式解包Optional

相较于普通的Optional值，在Swift中我们还有一种特殊的Optional，在对它的成员或者方法进行访问时，编译器会自动进行解包，被称为隐式解包Optional(ImplicitlyUnwrappedOptional),在声明时，通过在类型后面添加!来告诉编译器这是一个隐式解包Optional：

let possisbleString: String!
隐式解包的Optional本质上与普通的Optional值并没有什么不同，只是在访问时，编译器会自动帮我们完成在变量后插入!的行为：

let possibleString: String! = "An implicity unwrapped optional string."
let implicitString: String = possibleString //此处我们不需要!来对possibleString 进行显示解包
很显然，隐式解包的写法会带来一个潜在的危险，如果尝试访问一个为空的隐式解包Optional, 就会遇到一个runtime error。那么Swift为什么要引入隐式解包Optional呢，王巍在他的Swift Tip解释了一下：

这一切都是历史的锅。因为Object-C中Cocoa的所有类型变量都是可以指向nil的，有一部分Cocoa的API中在参数或者返回时即使被声明为具体的类型，但是还是可能在某些特定的情况下是nil, 而同时也有另一部分API永远不会接受或者返回nil。在Objective-C时，这两种情况并没有加以区别，因为在OC中向nil发送消息是允许的，结果就是什么都不会发生，而在Cocoa API从OC转为Swift的module声明的自动化工具里，是无法判定是否存在nil的可能的，因此也无法决定哪些类型应该是实际的类型，而哪些类型应该声明为Optional。

在这种自动化转换中，最简单粗暴的应对方式是全部转为 Optional，然后让使用者通过 Optional Binding 来判断并使用。虽然这是最安全的方式，但对使用者来说是一件非常麻烦的事情，我猜不会有人喜欢每次用个 API 就在 Optional 和普通类型之间转来转去。这时候，隐式解包的 Optional 就作为一个妥协方案出现了。使用隐式解包 Optional 的最大好处是对于那些我们能确认的 API 来说，我们可直接进行属性访问和方法调用，会很方便。但是需要牢记在心的是，隐式解包不意味着 “这个变量不会是 nil，你可以放心使用” 这种暗示，只能说 Swift 通过这个特性给了我们一种简便但是危险的使用方式罢了。
我们可以在类初始化时使用隐式解包Optional，官方文档里这么描述的：Unowned References and Implicitly Unwrapped Optional Properties.

我们也可以像使用一个一般的Optional一样使用隐式解包Optional
比如判断是否为空：

if possibleString !=nil {
    //some action
}
比如使用if let 来进行optional binding:

if let implicitString = possibleString {
    print(implicitString)
}
当你知道变量可能为空的时候，不要使用隐式解包Optional。如果一个变量在它的声明周期里可能包含控制，那你总是需要使用一般的Optional

Optional Chaining

Optional Chaining，如同名字一样，我们可以通过一个链来安全的访问一个Optional的属性或者方法。
可以参看一个例子：

if let isPNG = imagePaths["star"]?.hasSuffix(".png") {
    print("The star image is in PNG format")
}
这里通过在imagePath["star"]后面添加?来获取star所对应的图片路径，如果不存在就直接是nil,如果存在则返回对应的path，然后紧接着调用path的hasSuffix方法。

使用Optional Chaining可以让我们摆脱很多不必要的判断和取值，从而精简代码。

??的使用

当Optional解包后的值为nil时，我们可以通过使用??来设置一个默认值。

let defaultImagePath = "/images/default.png"
let heartPath = imagePaths["heart"] ?? defaultImagePath
print(heartPath)
如果imagePaths中没有包含"heart"对应的value，则会把defaultImagePath赋给heartPath,也就会打印出/images/default.png

当然了，我们也可以将??链接起来，设置多重默认值：

let shapePath = imagePaths["cir"] ?? imagePaths["squ"] ?? defaultImagePath
这样每一次解包值为nil时都会设置默认的值。
```

51.

```
显式解包、隐式解包

隐式解包，就是在定义可选类型值的时候，加上“！”进行强制解包
显式解包，

if-let解包

if let x = someOptional{
  print("someOptional value is \(x)")
}

case let 解包 

if case .some(let x) = someOptional{
    print("someOptional value is \(x)") //如果为nil 情况 可不会输出东西 因为匹配的是Some!
}
if case let x? = someOptional{
    print("someOptional value is \(x)") //如果为nil 情况 可不会输出东西 因为匹配的是Some!
}

用处：
比如元祖枚举解包、 switch中得解包
var roles = [
    GameRole.Player(name: "玩家一"),
    GameRole.Player(name: "玩家二"),
    GameRole.Player(name: "玩家三"),
    GameRole.Player(name: "玩家四"),
    GameRole.NPC(name: "NPC1", faction: "光明"),
    GameRole.NPC(name: "NPC2", faction: "黑暗"),
    GameRole.NPC(name: "NPC3", faction: "精灵"),
    GameRole.NPC(name: "NPC4", faction: "黑暗"),
    GameRole.Monster(name: "怪物1", element: 1),
    GameRole.Monster(name: "怪物2", element: 2),
    GameRole.Monster(name: "怪物3", element: 4),
    GameRole.Monster(name: "怪物4", element: 5),
]

// 早前使用方法
// 遍历整个角色
for role in roles{
    // 因为是枚举 所以要switch来匹配
    switch role{
    case let .NPC(name,faction):
        print("有 \(name)-\(faction)出没")
    default:
        break
    }
}

简化上面的代码
for case let .NPC(name,faction) in roles {
    print("有 \(name)-\(faction)出没")
}
还可以继续加条件
for case let .NPC(name,faction) in roles where faction == "黑暗"{
    print("有 \(name)-\(faction)出没")
}

```





参考文献

[Swift3.0中文文档（非最新）](http://www.cocoachina.com/industry/20140613/8818.html)

[Swift3.0官方文档](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)