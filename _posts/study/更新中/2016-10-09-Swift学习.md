---
layout: post
category: 学习之路
title : "Swift 学习"
---

熟悉 Swift 3.0 过程中 学习到的东西。

Swift是强类型。

1.操作符

```
1...3 闭区间 包括 1、2、3

1..<3 开区间 包括 1、2

```



2.语法糖、自动识别类别

```
Array<String> 的语法糖： [String]
Dictionary<String, String> 的语法糖: [String : String]
var array: [String]?
//自动识别类型
var dict: [String : String] = [:] 
var arrayWithDict:[[String : String]]?
```



3.数组在Swift

```
// 创建数组
var array: [String] = []
var array = [String]()
var array = Array(repeating:0,count:5);  -> [0,0,0,0,0]

// 数组可以直接相加 直接加数组 
var anotherThreeDoubles = Array(repeating: "2.5", count: 2)
var sixDoubles = anotherThreeDoubles + anotherThreeDoubles
// sixDoubles类型是 [String], 包含元素:["2.5", "2.5", "2.5", "2.5"]
sixDoubles = sixDoubles + ["2.5"]

array = ["111","222","333"]
array[0...1] = ["444","555"];
print(array)
结果: ["444", "555", "333"]

array = ["111","222","333"]
array[0...2] = ["444","555"]; // 0...2 size 为3 ，后面数组size为 2
print(array)
结果: ["444", "555"]  //并不会出现两边因为数组size不一样产生错误，以更小size为准

array.

// 数组中只能存储同一类型的数据

// 数组常用方法
append(_ newElement: Element) 添加元素
insert(_:at:): 在某个位置插入元素  不能超出数组大小
remove(at:): 移除某个位置的元素
removeLast(): 移除最后一个元素
enumerated(): 该方法返回一个包含索引和对应位置的值的元祖(tuple)数组(Example)。


// 遍历数组
for i in 0..<array.count {
    print(array[i])
}
// forin 方式
for item in array {
    print(item)
}
// 设置遍历的区间
for item in array[0..<2] {
    print(item)
}
// enumerated 遍历
for en in array2.enumerated() {
    print(en)
    // 下标
    print(en.offset)
    // 值
    print(en.element)
}
// 下标和数值同时遍历   元祖
for (n,s) in array2.enumerated() {
     print(n , "==", s);
}
// 反序遍历
for s in array2.reversed() {
    print(s)
} 
// 遍历下标和数值 反序
for (xxx,ooo) in array2.enumerated().reversed() {
    print(xxx ,"====" ,ooo)
}
```



4.字典在Swift

```
字典构建方法  

var dict : [String : String] = [:] 表示空字典
var empty_dic = Dictionary<String, String>()
var dict : Dictionary<String,String> = Dictionary.init();
var airports : Dictionary<String, String> = ["TYP":"Tokyo", "DUB":"Boublin"]
var airports2 = ["TYP":"Tokyo", "DUB":"Boublin"]

字典的使用

var port: String = airport2["TYP"] //根据key获取value
port["one"] = "two" //添加键值对
```



4.swift 和 oc 交互 ，工程文件

```
swift 和 OC 混用会有两个新文件 

1、工程名-Swift.h 是 用于 oc 调用 swift 、是swift代码在工程中自动更新出的oc格式代码
 不可见，但是可以跳转进入，所有swift代码生成的类属性 都会在这个文件中转义一份oc的样式 
 被oc调用需要继承自NSObject

2、工程名-Bridging-Header.h 是用于 swift 调用 oc 的头文件，所有需要引入swift的OC都需要先在这个文件引入。
```



5. swift 有命名空间 直接取className 名字会有区别

```
swift的类名 转成 oc 自带了格式，并非直接名字。所以通过class去寻找指定类需要转className

在swift根据类名找xib也需要注意命名空间，一般是 工程名.类名

//获取xib
  class func nib() -> UINib {
      let className = NSStringFromClass(self)
      let postfix = className.components(separatedBy: ".").last
      return UINib(nibName: postfix!, bundle: nil)
  }

//获取对应className
- (Class)swiftClassFromString:(NSString *)className {
  	NSString *appName = 
  	[[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleName"];
	NSString *classStringName = 
	[NSString stringWithFormat:@"_TtC%d%@%d%@", appName.length, appName, className.length, className];
  	return NSClassFromString(classStringName);
}
```



6. 闭包

```
Swift 3.0 中 @noescape  变成默认属性

@escaping  逃逸闭包

逃逸的闭包常用于异步的操作，这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的生命周期才结束。当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行

@autoclosure 自动闭包   自动闭包应用场景

顾名思义是一种自动创建的闭包，用于包装函数参数的表达式，可以说是一种简便语法

(1)默认非逃逸

(2)闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包自动将表达式封装成闭包。

(3)自动闭包不接收任何参数，被调用时会返回被包装在其中的表达式的值。

(4)当闭包作为函数参数时，可以将参数标记 @autoclosure 来接收自动闭包。

(5)自动闭包能够延迟求值,因为代码段不会被执行直到你调用这个闭包。

(6)自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要在类型前面手动声明: @autoclosure @escaping 


自动闭包的使用




声明函数时，在参数的类型前面用inout修饰，在函数内部实现改变外部参数,方法调用的时候参数需要 &  (&在形参中表示“引用”实参)

var str = "789789"
getOne(&str)
print(str)

func getOne(_ b:inout String){
    b = "123456"
}
结果：123456
```



7. swift lazy属性 懒加载

    //定义一个闭包
    lazy var html: () -> String = {
       if let text = self.text {
            return "11111"
        } else {
            return "2222"
        }
    }
    //定义一个字符串
    lazy var second:String = {
        if let text = self.text {
            return "11111"
        } else {
            return "2222"
        }
    }()  
    //如果定义的不是闭包，而是需要返回值的，那么不要忘记最后的小括号，只有加了小括号，必包才会在调用的时候立刻执行。
    //要类型声明lazy var second:String，这样Xcode会进行类型检查。

    懒加载初始化的定义
    懒加载初始化只进入一次  并且在需要的时候才调用

    在Objective C中， 懒加载初始化是这样写的
    @property (strong,nonatomic) CAShapeLayer * shapelayer;
    -(CAShapeLayer *)shapelayer{   
    if (!_shapelayer) {       
          _shapelayer = [CAShapeLayer layer];    
     }    
         return _shapelayer;
    }

    Swift中，有两种方式来 懒加载初始化。 

    第一种，简单表达式

    lazy var first = NSArray(objects: "1","2")

    第二种，闭包

    lazy var second:String = {return "second" }()

8. 懒加载初始化的使用场景



​    
    1、属性本身依赖于外部因素才能初始化 
    completeURL表示完整的URL，这个变量依赖于自身的url是否含有http://前缀
    class Demo{    
    var url:NSString   
    lazy var completeURL:NSString = {       
       [unowned self] in       //防止闭包循环
       if self.url.hasPrefix("http://"){           
         return self.url        
      }else{            
         return "http://".stringByAppendingString(self.url)        
      }        
    }()    
    
    init(url:NSString){       
     self.url = url    
    }}
    
    2、属性需要复杂计算，消耗大量CPU
    
    lazy var second:Int = {       
    	var sum = 0        
    	for i in 1...100000{ sum += i}        
    	return sum        
    }()
    
    3、属性不确定是否会使用到
    
    官网的例子，注意，对于Manager来说，使用的时候，可能导入，也可能不倒入数据。从硬盘读取数据的代价是很大的，不导入数据的时候，不要初始化。
    
    4、定制化的初始化 
    
    有些初始化只需要初始化一次，在变量定义的地方初始化，有助于代码维护
    
    lazy var dataArray:NSMutableArray = {
      var array = NSMutableArray()        
      for  i in 1...100{
        array.addObject(NSNumber(integer: i))        
      }        
      return array        
    }()





11. 自定义表达式

```
infix  prefix  postfix 自定义表达式  实现 swift3.0  

比如定义一个  ** 表达式  

infix operator **   //这句话只能定义在文件，类的外面，其余类可以针对这个定义 做不同实现

//下面这里 实现是类似 ?? 方法 ，扩展optional    实现这么一个方法   static 方法

extension Optional {

	static func ** <T>(optional : T? , defaultValue : @autoclosure () -> T) -> T {}

}
```

12.weak 和 unowned 闭包内部防止循环引用

“用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 "无效的" 引用，它不能是 Optional 值，也不会被指向 nil。如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。”

swift 打印内存地址

```
print(Unmanaged<AnyObject>.passUnretained(spacetwo as AnyObject).toOpaque())
```

swift 等号判断

```
var a: NSString = "abc", b = a, c: NSString = "abc"  
  
println(a == b) //true  
println(a == c) //true  
println(a === b) //true  
println(a === c) //false ＝＝＝ 运算符可以判断是否对同一对象的引用   比较内存地址
```



swift 代码补全

http://www.jianshu.com/p/bbbfc524ca93



13.注释

    // MARK: - 操作
    // TODO: - 记得做
    // FIXME: - 提醒



14.

NS_DESIGNATED_INITIALIZER   指定某个OC方法为 designated initializer  因为swift  继承oc类出来 实现init方法外必须要实现一个designated （指定构造方法） init方法 

15.

宏和 const static 的区别 多用static



16.

swift 不能调用oc 类方法

17.

swift delegate 代理调用 不再使用resonse响应去校验方法是否存在

直接optional去调用就可以  

  self.delegate?.GXQActionSheetClickAtIndex(index: type!, viewController: self)

**18.swift 枚举 和 oc枚举**

```
swift 枚举 
    var result = Planet.One;
    result = .two;
    switch result {
      case .one:
       print("执行One");
      case .two:
       print("执行Two");
      default:
       print("执行Default");
    }

元祖 枚举
 enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}
    
    //元祖的方式可以把枚举作为一个计算类了，可带参数进switch的方便 
    //例如二维码和条码的大类，我们有N个不同的码，可能是二维码 也可能是条码
    //但是每个二维码又不一样的情况 我们就需要按大类判断。
    //没有元祖之前我们处理这个问题就是定义两个继承类 分别代表二维码和条码，都有一个枚举属性，通过这个属性来区分判断。？？？？？
    var productBarcode = Barcode.upc(8, 85909, 51226, 3)
    productBarcode = .qrCode("ABCDEFGHIJKLMNOP")
    
    switch productBarcode {
    case .upc(let numberSystem, let manufacturer, let product, let check):
        print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
    case .qrCode(let productCode):
        print("QR code: \(productCode).")
}
// Prints "QR code: ABCDEFGHIJKLMNOP."
    
```

**OC枚举方式 :**

typedef NS_ENUM  推荐使用

typedef enum

**swift枚举方式 :**

```
@objc enum FPCheckResult: NSInteger{
    case success         //成功
    case sailed          //失败
    case passcodeNotSet //未设置手机密码
    case touchidNotSet  //未设置指纹
    case touchidNotAvailable //不支持指纹
}大驼峰命名名称 小驼峰命名成员

swift 定义的枚举在OC中使用 会自动把枚举名字添加到前面做前缀  比如FP_SUCCESS 适配在OC中是 FPCheckResultSuccess

不像 C 和 Objective-C 一样，Swift 的枚举成员在被创建时不会被赋予一个默认的整数值。在上面的FPCheckResult例子中，Success，Failed，PasscodeNotSet和TouchidNotSet不是隐式得等于0，1，2和3。相反的，这些不同的枚举成员在FPCheckResult的一种显示定义中拥有各自不同的值。

oc 定义的枚举  大驼峰命名规则
注意：OC中定义的枚举在OC中可以不需要通过枚举名字获取，但在swift中需要用枚举.方法获取，所以把枚举名字写在枚举变量前面做前缀， swift解析的时候会自动去掉前缀。既方便oc又方便swift。
typedef NS_ENUM(NSInteger, FundType) {
    FundTypeMonetary   = 1,//公募货币基金
    FundTypeBond       = 2,//公募债基基金
};

多个成员值可以出现在同一行上，用逗号隔开：
enum Planet { 
    case mercury, venus, earth, mars, jupiter, saturn, uranus, nepturn 
} 

var directionToHead = CompassPoint.west 

一旦一个熟悉 被定义成一个枚举后，如上，或者switch 指定等。 就可以直接用点方法给属性设置其他枚举成员。



下面的枚举是对之前Planet这个枚举的一个细化，利用原始整型值来表示每个 planet 在太阳系中的顺序：
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
自动递增意味着Planet.venus的原始值是2，依次类推。
 
使用枚举成员的rawValue属性可以访问该枚举成员的原始值：
let earthsOrder = Planet.earth.rawValue 
// earthsOrder is 3 

通过rawValue去获取对应枚举成员
let possiblePlanet =Planet(rawValue: 7)
// possiblePlanet is of type Planet? and equals Planet.Uranus 


如果没有指定枚举类型 是无法获取rowValue的 
```

如果需要在oc中使用swift定义的枚举 需要加上 @objc前缀  如果是swift定义的协议 也是一样的

19.

swift 自定义运算符

新的运算符声明需在全局域使用operator关键字声明，可以声明为前置，中置或后置的。

当之前定义过的运算符 可以直接重载成其他参数类型 

```
func += <K,V>( left:inout [K:V], right:[K:V] ) {
    right.forEach { (key, value) in
        left.updateValue(value, forKey: key)
    }
}
func + <K,V>(left: [K:V], right:[K:V]) -> [K:V] {
    var result = left
    result += right
    return result
}
```

20.

swift写法

```

- (NSString *)cellIdentify{
    return @{@(HomeItemTypeAssetsHead).stringValue:@"AssetsHeadTableViewCell",
             @(HomeItemTypeRedPacket).stringValue:@"NewUserRedPacketTableViewCell",
             @(HomeItemTypeIntroduce).stringValue:@"IntroduceTableViewCell",
             @(HomeItemTypeProduct).stringValue:@"GXQRecommendProductCell",
             @(HomeItemTypeNotice).stringValue:@"HomeNoticeTableViewCell",
             @(HomeItemTypeAssetsCell).stringValue:@"HomeAssetsTableViewCell",
             @(HomeItemTypeXueBi).stringValue:@"HomeXuebiTableViewCell",
             @(HomeItemTypeCarousel).stringValue:@"HomeCarouselTableViewCell"}
    [@(self.type).stringValue];
}
```

21.

函数式

```
var newEvens = [Int]()
for i in 1...10 {
  if i % 2 == 0 {
         newEvens.append(i)
    } 
}
print(newEvens) // [2, 4, 6, 8, 10]

可以写成

var evens = Array(1...10).filter { $0 % 2 == 0 } 
print(evens) 
// [2, 4, 6, 8, 10]
```

22.

swift 绑定xib的时候 不能直接用className 去查找对应nib  因为swift存在域名 前面有工程名的前缀

swift viewController xib初始化的时候要实现init（）里面super.init（根据xib名字去初始化）

23.

        topImageView.mas_makeConstraints {
            $0?.top.leading().bottom().equalTo()(self)
            $0?.width.equalTo()(self.bgImageView.mas_width)?.multipliedBy()(0.0)
        }
        
        1.msonry可以校验宽度，比如占父类百分之多少宽度
        2.swift $0? 参数
        3.msonry可以校验宽度会引发的问题
        4.make.leading.equalTo(leftView.mas_trailing);  mas_right 和 mas_trailing 不是同一个东西，一套不能和另一套混用
柯里化

24.

swift 异常捕获

25.

swift强类型  float 和 int 不能相减



16. swift命名规则

```
对类、结构体、枚举和协议等类型命名，应该采用大驼峰法，如SplitViewController。

文件名，采用大驼峰法，如BlockOperation.swift。

扩展文件，有的时候扩展是定义在一个独立的文件中的，它的命名是“原始类型名+扩展名”作为扩展文件名，如NSOperation+Operations.swift。

变量和属性，采用应该采用小驼峰法，如studentNumber。

常量，采用大驼峰法，如MaxStudentNumber。

枚举成员，与常量类似，采用大驼峰法，如ExecutionFailed。

函数和方法，采用应该采用小驼峰法，如balanceAccount、isButtonPressed等。
```

27.

```
var nameOne: String?
nameOne = "one"
if let name = nameOne {
    print(name)
}
如果变量的可选值是 nil ，条件会判断为 false ，并且大括号中的代码会被跳过。如果不是nil，会将值赋给let后面的常量，这样代码块中就可以使用这个值了。
```

28.switch

```
使用switch 支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。
运行 switch 中匹配到的子句之后，程序会退出switch语句，并不会继续向下运行，所以不需要在每个子句结尾写break。

let age = 15
switch age {
case 0...10:
    print("000")
case let x:
    print(x)
default:
    print("111")
}

一定要有必执行项 （default，let x 这种）不然编译错误：switch must be exhaustive

fallthrough:【紧跟的后一个】case条件不能定义常量和变量
fallthrough 后面项不能是let x


```

29.for循环

```
for num in 0...3 {
    print(interestingNumbers[num])
}
和
for num in 0..<3 {
    print(interestingNumbers[num])
}
的区别 ... 指0到3之间包括下界(1，2，3，4) , ..< 不包括下界(0，1，2)
        
        
```

30.泛型

```
extension Array {
//Element 这个地方使用Element的原因是array中默认元素类型是Element
    public func my_map<T>(_ element: (Element) -> T) -> [T] {
        var array_new = Array<T>()
        for item in self {
            let item_new = element(item)
           array_new.append(item_new)
        }
        return array_new
    }
}

限制泛型类型，例如所有的泛型参数都要实现 NameSpaceProtocol 协议，如下两种写法
func getTwo<T>(_ E : T) where T : NameSpaceProtocol{
}
func getTwo<T : NameSpaceProtocol>(_ E : T){
}

```

31.Swift控制器初始化问题

```
子类的定义通过 : 后面紧跟父类名称的方式。
当然不是每个类都需要标准的根类，所以可以忽略父类。

1、指定或便捷初始化器在类中被调用；
2、为这个类的新实例分配内存。内存还没有被初始化；
3、这个类的指定初始化器确保所有由此类引入的存储属性都有一个值。现在这些存储属性的内存被初始化了；
4、指定初始化器上交父类的初始化器为其存储属性执行相同的任务；
5、这个调用父类初始化器的过程将沿着初始化器链一直向上进行，直到到达初始化器链的最顶部；
6、一旦达了初始化器链的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为完全初始化了，此时第一阶段完成。

swift 的初始化两阶段，第一阶段是类的分配地址 并且给类的属性分配一个地址
位于super.init 之前。如果没有父类，就应该是所有的属性都有值之后算第二阶段。

第二阶段就是super.init 之后，self已经具体实现完成，可以调用方法，并且可以进行定制，super.init 是为了完成到父类实现init的委托。这个是具体的实现。

安全检查
1、指定初始化器必须保证在向上委托给父类初始化器之前，其所在类引入的所有属性都要初始化完成。
2、指定初始化器必须先向上委托父类初始化器，然后才能为继承的属性设置新值。如果不这样做，指定初始化器赋予的新值将被父类中的初始化器所覆盖。
3、便捷初始化器必须先委托同类中的其它初始化器，然后再为任意属性赋新值（包括同类里定义的属性）
4、初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 self 作为值。
违背检查规则的都无法通过编译。

在OC中得 init方法内
- (instancetype)init
{
    NSLog(@"%@",self); //这个时候self已经被分配地址，他得属性不能通过点符号点出，可以指向，说明地址也是被分配了。
    self = [super init];//具体实现 后面才可以调用方法
    if (self) {
    }
    return self;
}

关于初始化的继承
规则 1
如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。

规则 2
如果子类提供了所有父类指定构造器的实现--不管是通过规则1继承过来的，还是通过自定义实现的--它将自动继承所有父类的便利构造器。因为便利构造器都是基于指定构造器的


初始化方法的问题
特别是swift继承oc类的情况

1.swift继承自swift 的情况下 父类的构造器，自动继承所有父类的指定构造器
2.如果实现了所有的父类指定构造器 将自动继承所有的便利构造器

swift继承自oc的时候会出现一种情况 就是 要求实现指定构造器
当AswiftController继承一个BOCcontroller的时候，BocController中必须要有一个指定构造方法
UIViewController默认的指定构造方法是
- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil NS_DESIGNATED_INITIALIZER;

或者我们自己指定一个指定构造方法，也就是说在OC中写一个构造方法，并用 NS_DESIGNATED_INITIALIZER 标示标出，那么在swift中得构造方法就必须实现这个构造方法，

OC控制器 A
swift控制器  B 继承自 A
OC控制器 C
swift控制器 B 继承自OC控制器 A ，然后又再另一个OC  C 调用 B 控制器 ，oc调用 直接alloc init 那么就会调用到 B 控制器中 的非指定构造器 init方法，在特定系统（8.几）运行过程中会报错，所以我们需要在swift 继承自OC的时候就复写指定构造器方法，并实现init方法，在方法中调用父类指定构造器。

Swift 实现的控制器 需要实现init方法
init() {
    super.init(nibName: nil, bundle: nil)
}
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
或者在B 的父类 A 中实现init方法，并在方法中通过指定构造器实现初始化(initWithNIB)
B：
init() {
    super.init()
}
required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
A：
- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
    if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) {
    }
    return self;
}
- (instancetype)init{
    return [self initWithNibName:nil bundle:nil];
}


指定构造器纵向实现（委托父类的指定构造器），遍历构造器横向实现(调用本身的指定构造器)

如果遍历构造器接收参数和父类指定构造器一样，需要在前面加上override

可空初始化器

struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
```

32.结构体

```
使用方法和类差不多

struct NameSpaceTwo {
    var length: Int
    var height: Int
    
    func countTwo() -> Int {
        return height + length
    }
}

和类的区别
 struct 是 Value Type 而 class 是 Reference Type ， Value Type是值类型，reference type 是引用类型
 
在每次做 assignment 的時候，value type 都会复制一份完整相同的內容給另一個变量，而 class 則是把内容对应的内存地址給变量。

let spacetwo = NameSpaceTwo(protocolParam: "8888", length: 5, height: 5)
let spacethree = spacetwo

print(Unmanaged<AnyObject>.passUnretained(spacethree as AnyObject).toOpaque())
print(Unmanaged<AnyObject>.passUnretained(spacetwo as AnyObject).toOpaque())

let 的方式的 struct 内部参数不能改变

spacethree 和 spacetwo 的改变都不会对对方产生影响。



mutating 关键字
使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。
```

33.协议

``` 
协议中定义的方法，依然是不能有方法体，协议可以设置参数，参数必须要设置{get} 或者 {get set}

使用 extension 为现有的类型添加功能，比如添加一个计算属性的方法。你可以在任何地方使用 extension 来给任意类型添加协议，甚至是从外部库或者框架中导入的类型。

你可以像使用其他命名类型一样，创建一个有不同类型但是都实现同一个协议的对象集合。当你处理协议类型的值时，协议外定义的方法不可用。都被当成协议类型对象处理

```

34.类型转换

```
swift 中没有 toInt toString等转换方法

let convertedNumber = Int(b)
print(convertedNumber ?? "")


如果 possibleNumber不能转换，将为 nil

在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针，它是一个确定的值，用来表示值的缺失。任何类型的可选都可以被设置为 nil，不只是对象类型。


if let dic = dic["currentProfit"] as? [String : Any] 

不推荐直接强转，在if条件句中可以进行解包和强转，因为if条件句中失败不会导致崩溃。
等号两边任意一个失败都不会执行
类似floatValue这种一定会有返回值的就不能在if中做这种处理。
```

35.断言 

```
release 情况  断言在 swift 无效 断言错误信息有在控制台打出，oc正常
```

36.swift   get set 

```
var count: String {
       return ""
}


var _count: String = ""  //防止循环引用
var count: String {
    get {
        return _count
    }
    set {
        _count = newValue;
    }
}
```

37.变量定义

```
var count: String {
    return ""
}
上面这种不用等号的方式，  下面这张使用了等号，那么左右两边类型必须一样，而右边给了一个闭包，显然和String类型不一样，所以闭包需要执行，并返回里面的内容 "" 保证两边类型一致
var count: String = {
    return ""
}()
```

38.两位小数

```
round(combinationFee  * 100)/100
```

39.

```
swift 工程中得main方法入口

@UIApplicationMain
```

40

```
所有的 Swift 代码都将被 LLVM 编译为 native code，以极高的效率运行。

按照官方今天给出的 benchmark 数据，运行时比 Python 快 3.9 倍，比 objc 快 1.4 倍左右。

另一方面，Swift 的代码又是可以 Interactive 来“解释”执行的。新的 Xcode 中加入了 Playground 来对开发者输入的 Swift 代码进行交互式的相应，开发者也可是使用 swift 的命令行工具来交互式地执行 swift 语句。

但是, Swift 其实也不是被解释执行的，而是在每个指令后进对从开始以来的 swift 代码行了一遍编译，然后执行的。这样的做法下依然可以让人“感到”是在做交互解释执行，这门语言的编译速度和优化水平，可见一斑。同时 Playground 还顺便记录了每条语句的执行时候的各种情况，叫做一组 timeline。可以使用 timeline 对代码的执行逐步检查，省去了断点 debug 的时间，也非常方便。
```

41

```
swift 工程中得main方法入口

@UIApplicationMain


http://www.tuicool.com/articles/fAZ3yef
```

42

```
1.swift程序的入口是@UIApplicationMain , OC 是main.m 中的main方法

2.OC的类是以.h和.m组成的 , swift是以.swift结尾的

3.OC的类是以@interface 和 @end开始结尾 , swift是采用{}

4.OC里语句结束以分号(;) ,  swift里不需要分号,添加分号也不会出错，单行需要分号区分
 
5.OC中创建一个视图,采用alloc/init,swift采用();

6.OC中创建视图采用initWithXXX;swift里变成(XXX:)

7.swift设置属性,全面采用点语法;

8.OC中添加视图使用self.view.addSubView;swift添加视图使用view.addSubView,不使用self,为了在闭包里和构造函数里区分会在闭包里和够构造函数里用self;

9.OC中枚举需要写全,swift中采用type.类型的形式;

10.OC里的方法是采用@selector;swift采用”方法名”形式;

11.swift中的枚举可以省略前面的tyoe,直接采用点语法,只能提示不太好;

12.OC中打印使用NSLog,swift使用print;

13.等号左右两边最号用对等的空格;
```

43 https://www.oschina.net/translate/swift-vs-objective-c-10-reasons-the-future-favors-swift

44.

```
swift的nil可以用于所有数据类型,包括Int,Double,String,对象，数据结构，枚举。而不是想objc那样，对象用nil，数据结构有时用NSNotFound，指针用NULL。
```

45.

```
Swift 3.0 的 open，public，internal，fileprivate，private 关键字 
fileprivate和 open
fileprivate 类似之前的private ，文件内私有，单个文件内可以互相访问，
现在的private 就是真正意义的私有，即使同文件内 只要跨类了 就不能访问

open 相当于 可以外部继承 public现在不能外部继承



import Foundation
 
/// final的含义保持不变
public final class FinalClass { }
 
// 这个类在ModuleA的范围外是不能被继承的，只能被访问
public class PublicClass {
 
    public func testPublic() {}
 
    // 这是错误的写法，因为class已经不能被继承，
    // 所以他的方法的访问权限不能大于类的访问权限
    open func testOpen() {}
 
    // final的含义保持不变
    public final func testPublicFinal() {}
}
 
// 在ModuleA的范围外可以被继承
open class OpenClass {
    // 这个属性在ModuleA的范围外不能被override
    public var size : Int = 0
 
    // 这个方法在ModuleA的范围外不能被override
    public func testPublic() {}
 
    // 这个方法在任何地方都可以被override
    open func testOpen() {}
 
    ///final的含义保持不变
    public final func testPublicFinal() {}
}


import Foundation
import ModuleA
 
// 这个写法是错误的，编译会失败,类访问权限标记的是public，只能被访问不能被继承
class SubA : PublicClass { }
 
// 这样写法可以通过,Class访问权限为 `open`.
class SubB : OpenClass {
 
    // 这样写也会编译失败,因为这个方法权限为public，不是`open'.
    override func testPublic() { }
 
    // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写
    // 这里不需要再声明为open，因为这个类是internal的
    override func testOpen() { }
}
 
open class SubC : OpenClass {
    // 这种写法会编译失败
    override func testPublicFinal() { }
 
    // 正确的写法，方法也需要标记为open
    open override func testOpen() { }
}
 
open class SubE : OpenClass {
    // 也可以显式的指出这个方法不能再被override
    public final override func testOpen() { }
}
```

46.UIView swift 初始化

```
Swift:必须添加init?(coder decoder: NSCoder)的原因


当我们重写类的时候经常提示要添加代码：

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
这个叫必要初始化器，这种情况一般会出现在继承了遵守NSCoding protocol的类，比如UIView系列的类、UIViewController系列的类。

为什么一定要添加：
这是NSCoding protocol定义的，遵守了NSCoding protoaol的所有类必须继承。只是有的情况会隐式继承，而有的情况下需要显示实现。

什么情况下要显示添加：
当我们在子类定义了指定初始化器(包括自定义和重写父类指定初始化器)，那么必须显示实现required init?(coder aDecoder: NSCoder)，而其他情况下则会隐式继承，我们可以不用理会。

什么情况下会调用：
当我们使用storyboard实现界面的时候，程序会调用这个初始化器。
注意要去掉fatalError，fatalError的意思是无条件停止执行并打印。
在obj-c中可以通过下面代码实现

        NSException *exception = [NSException exceptionWithName:@"HotTeaException" reason:@"The tea is too hot" userInfo:nil];
        @throw exception;
总结：
如果代码实现界面，那么我们只要根据编译器提示添加必要初始化器后，就不用理会，我们创建界面的工作可以在自定义的初始化器里实现。

补充：let vc = UIViewController()方式初始化类
UIViewController类视乎只有两个初始化器，一个是必要初始化器init?(coder aDecoder: NSCoder)，一个是指定初始化器init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: NSBundle?)，那么为什么我们可以用let vc = UIViewController()这种方式初始化类呢？原因可能是这个初始化方式是来自uikit,也就是调用了Object-c下的UIViewController初始化方法，是object-c bridge过来的。

针对继承自OC的ViewController  为了解决 nib初始化的问题

swift 关于指定构造器 和便利构造器的 实现 和继承之类的问题  

1.当子类继承了父类的时候，如果子类没有覆盖任何父类的指定构造器，那么它也不能建立便利构造器，并且自动继承所有父类的指定构造器。
2.如果子类自己建立了指定构造器，并且未覆盖父类的指定构造器，那么它将失去所有的父类构造器的使用。
```

47.defer



48.

```
Int UInt的区别 带U表示无符号整数，不带U表示有符号整数 至于后面的位数选择，编译器会根据当前运行环境自动选择

swift中 除了十进制，还可以使用十六进制 (0x) 八进制 (0o) 二进制 (0b)
以及可以使用千位分隔符  let million = 1_000_000

Double(fifteen_10) //这里实际是重新生成了一个Double类型的值，并非类型转换

type(of:PI) 查看类型

PI = 15 + 314e-2  正常编译

let PI_fifteen = PI + fifteen_10    错误

String已经不单单是一个字符数组，泊学收获

更人性化 可读性更高的语言，

swift写代码思考方式

例如写guard

一个表达式 json["num"] as? String 解析成功，我们就绑定这个结果，guard let result =   json["num"] as? String ,  同时考虑其他情况，guard let result =   json["num"] as? String ,let num = Double(result) 最后 else return nil 

然后我们就可以正常使用josn解析出来的num了

1、定义变量 （介绍var、let、强类型、类型推断type inference）元祖，可以存任意多个数值 能用常量解决的问题，就不要用变量

当定义一个变量并未赋值的时候，是无法进行类型推断的，这个时候就需要声明类型 ：String



```

49.

```
swift 协议

属性要求
协议能够要求其遵循者必须含有一些特定名称和类型的实例属性(instance property)或类属性 (type property)，也能够要求属性的(设置权限)settable 和(访问权限)gettable，但它不要求属性是存储型属性(stored property)还是计算型属性(calculate property)。
 
通常前置var关键字将属性声明为变量。在属性声明后写上{ get set }表示属性为可读写的。{ get }用来表示属性为可读的。即使你为可读的属性实现了setter方法，它也不会出错。

protocol SomeProtocol { 
    var musBeSettable : Int { get set } 
    var doesNotNeedToBeSettable: Int { get } 
} 
```

50.

```
Optional

Swift中的Optional作为一种类型，既可以存储一个值，也可以为空（也就是swift里的nil）,通常在类型后面加一个？表示它是Optional类型的：

var number： Int? = 32
其实?只不过是一个语法糖，Optional的实际类型是一个enum:

enum Optional<T>: _Reflectable, NilLiteralConvertible {
    case None
    case Some(T)
    //...
}
上面的var number： Int? = 32也就可以表示为：

var numbet: Optional<Int> = 32
当然我们习惯上更习惯于表示为Int?

Optional的作用

一个Optional对象只存在两种状态：包含一个值，或者为空，我们都可以通过解包（unwrap）来获取。下面一段出自The Swift Programming Language (Swift 3)

The concept of optionals doesn’t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return nil from a method that would otherwise return an object, with nil meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as NSNotFound) to indicate the absence of a value. This approach assumes that the method’s caller knows there is a special value to test against and remembers to check for it. Swift’s optionals let you indicate the absence of a value for any type at all, without the need for special constants.
Swift通过引入Optional解决了Objective-C中“有”与“无”的问题，使代码的安全性得到了很大的提高，同时我们也应该知道，Swift是一种类型安全的语言。

在某些场景下，Optional能起到很大的作用:

当一些属性值可以为空时，比如一个Person类中，middleName，spouse这类的属性都可以为空
当一个方法可以返回空值，比如类型转换函数，官方文档的例子
//try to convert a String into an Int
let possibleNumber = "123"
let convertedNumber = Int(possibleNumber)
// convertedNumber is inferred to be of type "Int?", or "optional Int"
// 如果possibleNumber 是“hello”,则转换不会成功，就会返回nil
如果在一个字典中，使用key获取对应的value时，返回的也应该是Optional的值，因为你也可能找不到key对应的value，此时返回nil
一个方法可以返回一个值，如果方法内部产生了错误，也可以什么都不返回
Delegate 属性（不总是需要被赋值）
class中weak 类型的属性，他们所指向的值可以为空
一个大的资源可以随时被释放，以节约空间，所以正常情况下都是空的，只有使用时才会请求赋值。
Optional Binding

出于类型安全的考虑，我们不能再把Optional当作Boolean值处理。像下面这条语句在swift中会遇到编译错误

var myString: String? = "Hello"
if myString {
    print(myString)
}
但是你可以通过==和!=，将Optional值和nil做比较来判断它是否包含一个值。如果不包含任何值，则为空。

if myString != nil{
    print("myString contain a string value of \(myString!)")
}
在上面的语句里，当我们确定myString包含一个值时，我们通过在myString后面添加一个!来进行强制解包(forced unwrapping)，获取Optional内包含的值。

但是实际上，Swift提供了一种更加方便的形式来完成这一过程，所谓的Optional Binding,看下面的代码：

if let actualString = myString {
    print("myString contain a string value of \(actualString )")
} else {
    print("myString is nil")
}
上面代码的意思是，如果optional string 包含一个值，我们就把这个值赋给actualString，然后就可以在if语句里继续使用它了，所以不再需要对其进行解包了，因为actualStr这样我们就用Optinal binding 代替了强制解包(forced unwrapping)。我们也可以使用if var actualString = myString 来获取actualString，则这个actualString就是var类型的。

隐式解包Optional

相较于普通的Optional值，在Swift中我们还有一种特殊的Optional，在对它的成员或者方法进行访问时，编译器会自动进行解包，被称为隐式解包Optional(ImplicitlyUnwrappedOptional),在声明时，通过在类型后面添加!来告诉编译器这是一个隐式解包Optional：

let possisbleString: String!
隐式解包的Optional本质上与普通的Optional值并没有什么不同，只是在访问时，编译器会自动帮我们完成在变量后插入!的行为：

let possibleString: String! = "An implicity unwrapped optional string."
let implicitString: String = possibleString //此处我们不需要!来对possibleString 进行显示解包
很显然，隐式解包的写法会带来一个潜在的危险，如果尝试访问一个为空的隐式解包Optional, 就会遇到一个runtime error。那么Swift为什么要引入隐式解包Optional呢，王巍在他的Swift Tip解释了一下：

这一切都是历史的锅。因为Object-C中Cocoa的所有类型变量都是可以指向nil的，有一部分Cocoa的API中在参数或者返回时即使被声明为具体的类型，但是还是可能在某些特定的情况下是nil, 而同时也有另一部分API永远不会接受或者返回nil。在Objective-C时，这两种情况并没有加以区别，因为在OC中向nil发送消息是允许的，结果就是什么都不会发生，而在Cocoa API从OC转为Swift的module声明的自动化工具里，是无法判定是否存在nil的可能的，因此也无法决定哪些类型应该是实际的类型，而哪些类型应该声明为Optional。

在这种自动化转换中，最简单粗暴的应对方式是全部转为 Optional，然后让使用者通过 Optional Binding 来判断并使用。虽然这是最安全的方式，但对使用者来说是一件非常麻烦的事情，我猜不会有人喜欢每次用个 API 就在 Optional 和普通类型之间转来转去。这时候，隐式解包的 Optional 就作为一个妥协方案出现了。使用隐式解包 Optional 的最大好处是对于那些我们能确认的 API 来说，我们可直接进行属性访问和方法调用，会很方便。但是需要牢记在心的是，隐式解包不意味着 “这个变量不会是 nil，你可以放心使用” 这种暗示，只能说 Swift 通过这个特性给了我们一种简便但是危险的使用方式罢了。
我们可以在类初始化时使用隐式解包Optional，官方文档里这么描述的：Unowned References and Implicitly Unwrapped Optional Properties.

我们也可以像使用一个一般的Optional一样使用隐式解包Optional
比如判断是否为空：

if possibleString !=nil {
    //some action
}
比如使用if let 来进行optional binding:

if let implicitString = possibleString {
    print(implicitString)
}
当你知道变量可能为空的时候，不要使用隐式解包Optional。如果一个变量在它的声明周期里可能包含控制，那你总是需要使用一般的Optional

Optional Chaining

Optional Chaining，如同名字一样，我们可以通过一个链来安全的访问一个Optional的属性或者方法。
可以参看一个例子：

if let isPNG = imagePaths["star"]?.hasSuffix(".png") {
    print("The star image is in PNG format")
}
这里通过在imagePath["star"]后面添加?来获取star所对应的图片路径，如果不存在就直接是nil,如果存在则返回对应的path，然后紧接着调用path的hasSuffix方法。

使用Optional Chaining可以让我们摆脱很多不必要的判断和取值，从而精简代码。

??的使用

当Optional解包后的值为nil时，我们可以通过使用??来设置一个默认值。

let defaultImagePath = "/images/default.png"
let heartPath = imagePaths["heart"] ?? defaultImagePath
print(heartPath)
如果imagePaths中没有包含"heart"对应的value，则会把defaultImagePath赋给heartPath,也就会打印出/images/default.png

当然了，我们也可以将??链接起来，设置多重默认值：

let shapePath = imagePaths["cir"] ?? imagePaths["squ"] ?? defaultImagePath
这样每一次解包值为nil时都会设置默认的值。
```

51.

```
显式解包、隐式解包

隐式解包，就是在定义可选类型值的时候，加上“！”进行强制解包
显式解包，

if-let解包

if let x = someOptional{
  print("someOptional value is \(x)")
}

case let 解包 

if case .some(let x) = someOptional{
    print("someOptional value is \(x)") //如果为nil 情况 可不会输出东西 因为匹配的是Some!
}
if case let x? = someOptional{
    print("someOptional value is \(x)") //如果为nil 情况 可不会输出东西 因为匹配的是Some!
}

用处：
比如元祖枚举解包、 switch中得解包
var roles = [
    GameRole.Player(name: "玩家一"),
    GameRole.Player(name: "玩家二"),
    GameRole.Player(name: "玩家三"),
    GameRole.Player(name: "玩家四"),
    GameRole.NPC(name: "NPC1", faction: "光明"),
    GameRole.NPC(name: "NPC2", faction: "黑暗"),
    GameRole.NPC(name: "NPC3", faction: "精灵"),
    GameRole.NPC(name: "NPC4", faction: "黑暗"),
    GameRole.Monster(name: "怪物1", element: 1),
    GameRole.Monster(name: "怪物2", element: 2),
    GameRole.Monster(name: "怪物3", element: 4),
    GameRole.Monster(name: "怪物4", element: 5),
]

// 早前使用方法
// 遍历整个角色
for role in roles{
    // 因为是枚举 所以要switch来匹配
    switch role{
    case let .NPC(name,faction):
        print("有 \(name)-\(faction)出没")
    default:
        break
    }
}

简化上面的代码
for case let .NPC(name,faction) in roles {
    print("有 \(name)-\(faction)出没")
}
还可以继续加条件
for case let .NPC(name,faction) in roles where faction == "黑暗"{
    print("有 \(name)-\(faction)出没")
}

```

52.

```
避免对 可选类型 强解包

If you have an identifier foo of type FooType? or FooType!, don't force-unwrap it to get to the underlying value (foo!) if possible.

如果你有个 FooType? 或 FooType! 的 foo，尽量不要强行展开它以得到基本类型（foo!）。

理由： if let 绑定可选类型产生了更安全的代码，强行展开很可能导致运行时崩溃。




if let x = foo {
    // Use unwrapped `x` value in here
} else {
    // If appropriate, handle the case where the optional is nil
}

这一段的重要性，直接在if块解包 
少用强解

if let rateString = dic?["incomeRate"] as? String  {
  let rate = NSString(string: rateString).floatValue
}
比较
let rate  = NSString(string: incomeRate!).floatValue //可能出现转换失败导致的崩溃


```



52.下标

```
extension Int {
    subscript(index: Int) -> Int {
        return self
    }
}

print(3333[0])
subscript //在Extention中写下标方法
```

53.协议的get set约束 只针对协议对象生效

```
protocol myProtocol {
    var count: Int {get}
}

struct myStruct: myProtocol {
    var count: Int 
}
场景1.
var s: myProtocol = myStruct(count: 5)
s.count = 4 //会编译出错，原因就是read-only

场景2.
var s = myStruct(count: 5)
s.count = 4 //正常编译
```

54.swift中的可选协议 只能用在类，结构体和枚举不能用,且要加上@objc，变成可选后调用需要注意可选情况

```
import Foundation

@objc protocol myProtocol {
    @objc optional func some()
}
class myStruct: myProtocol {
    var count: Int

    init() {
        self.count = 5
    }
    func some() {
        print("dfadsf")
    }
}
var s: myProtocol = myStruct()
s.some?()

```

55.协议扩展的作用

```
swift协议扩展可以提供更多的方法的实现,不能不实现
协议扩展的约束
比如我定义一个协议扩展，但是我需要实现者满足某个条件(实现了另一个协议)
这种情况下，使用where来限制

extension Collection where Iterator.Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}

```



swift 运行时



http://blog.csdn.net/u013378438/article/details/52060925



swift 3.0 dispatch_once 取消后的解决办法

http://blog.csdn.net/mydo/article/details/52635754





56.swift 协议中得引用循环

ARC

ARC 苹果版本的自动内存管理的编译时间特性。它代表了自动引用计数(Automatic Reference Counting)。也就是对于一个对象来说，只有在引用计数为0的情况下内存才会被释放。

**Strong（强引用）**

让我们从什么是强引用说起。它实质上就是普通的引用(指针等等)，但是它的特殊之处在于它能够通过使对象的引用计数+1来保护对象，避免引用对象被ARC机制销毁。本质上来讲，任何对象只要有强引用，它就不会被销毁掉。记住这点对我接下来要讲的引用循环等其他知识来说很重要。

强引用在[Swift](http://lib.csdn.net/base/swift)中无处不在。事实上，当你声明一个属性时，它就默认是一个强引用。一般来说，当对象之间的关系为线性时，使用强引用是安全的。当对象之间的强引用是从父层级流向子层级时，用强引用通常也是ok的。

下面是一些强引用的例子

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class Kraken {  
2. ​    let tentacle = Tentacle() //strong reference to child.  
3. }  
4. ​
5. class Tentacle {  
6. ​    let sucker = Sucker() //strong reference to child  
7. }  
8. ​
9. class Sucker {}  

示例代码展示了线性关系。Kraken有一个指向Tentacle实例对象的强引用，而Tentacle又有一个指向Sucker实例对象的强引用。引用关系从父层级(Kraken)一直流到子层级(Sucker)。

同样的，在动画blocks中，引用关系也类似：

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. UIView.animateWithDuration(0.3) {  
2. ​    self.view.alpha = 0.0  
3. }  

由于animateWithDuration是UIView的一个静态方法，这里的闭包作为父层级，self作为子层级。

那么当一个子层级想引用父层级会怎么样呢？这里我们就要用到 weak 和 unowned 引用了。

**Weak 和 unowned 引用**

**weak**

weak 引用并不能保护所引用的对象被ARC机制销毁。强引用能使被引用对象的引用计数+1，而弱引用不会。此外，若弱引用的对象被销毁后，弱引用的指针会被清空。这样保证了当你调用一个弱引用对象时，你能得到一个对象或者nil. 

在swift中，所有的弱引用都是非常量的可选类型(对比 var 和 let) ，因为当没有强引用对象引用的的时候,弱引用对象能够并且会变成nil。 

例如，这样的代码不会通过编译 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class Kraken {  
2. ​    weak let tentacle = Tentacle() //let is a constant! All weak variables MUST be mutable.  
3. }  

因为tentacle是一个let常量。Let常量在运行的时候不能被改变。因为弱引用变量在没有被强引用的条件下会变成nil，所以Swift 编译器要求你必须用var来定义弱引用对象。 

值得注意的地方是，使用弱引用变量能够避免你出现可能的引用循环。当两个对象相互强引用的时候会出现一个引用循环。如果2个对象相互引用对方，ARC就不能给这两个对象发出合适的释放信息，因为这两个对象彼此相互依存。下图是从苹果官方简洁的图片，它很好的解释了这种情况: 

![44.png](http://cc.cocimg.com/api/uploads/20160129/1454052936680325.png)

一个比较恰当的例子就是通知APIs，看一下下面的代码: 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class Kraken {  
2. ​    var notificationObserver: ((NSNotification) -> Void)?  
3. ​    init() {  
4. ​        notificationObserver = NSNotificationCenter.defaultCenter().addObserverForName("humanEnteredKrakensLair", object: nil, queue: NSOperationQueue.mainQueue()) { notification in  
5. ​            self.eatHuman()  
6. ​        }  
7. ​    }  
8. ​      
9. ​    deinit {  
10. ​        if notificationObserver != nil {  
11. ​            NSNotificationCenter.defaultCenter.removeObserver(notificationObserver)  
12. ​        }  
13. ​    }  
14. }  

在这种情况下我们有一个引用循环。你会发现，Swift中的闭包的表现类似与[Objective-C](http://lib.csdn.net/base/objective-c)的blocks。如果在闭包范围之外声明变量，那么在闭包中使用这个变量时，会对该变量产生另一个强引用。唯一的例外是使用值类型的变量，比如Swift中的 Ints、Strings、Arrays以及Dictionaries等。

在这里，当你调用eatHuman( ) 时，NSNotificationCenter就保留了一个闭包以强引用方式捕获self。经验告诉我们，你应该在deinit方法中清除通知监听对象。这段代码的问题在于我们没有清除掉block直到deinit.但是deinit 永远都不会被ARC机制调用，因为闭包对Kraken实例有强引用。 

另外在NSTimers和NSThread也可能会出现这种情况。 

解决这种情况的方法就是在闭包的捕获列表中使用对self的弱引用。这样就能够打破强引用循环。那么，我们的对象引用图就会像这样： 

![26.png](http://cc.cocimg.com/api/uploads/20160129/1454052989898014.png)

把self变成weak不会让self 的引用计数+1，因此ARC机制就能在合适的时间释放掉对象。 

想要在闭包使用 weak 和 unowned 变量，你应该用[]把它们括起来。如：

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. let closure = { [weak self] in   
2. ​    self?.doSomething() //Remember, all weak variables are Optionals!  
3. }  

在上面的代码中，为什么要把 weak self 要放在方括号内？看上去简直秀逗了！在Swift中，我们看到方括号就会想到数组。你猜怎么着？你可以在在闭包内定义多个捕获值！例如： 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. let closure = { [weak self, unowned krakenInstance] in //Look at that sweet Array of capture values.  
2. ​    self?.doSomething() //weak variables are Optionals!  
3. ​    krakenInstance.eatMoreHumans() //unowned variables are not.  
4. }  

这样看上去更像是数组了，对吧？现在你知道为什么把捕获值放在方括号里面了吧。那么用我们已了解的东西，通过在闭包捕获列表中加上[weak self]，我们就可以解决之前那段有引用循环的通知代码。 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. NSNotificationCenter.defaultCenter().addObserverForName("humanEnteredKrakensLair", object: nil, queue: NSOperationQueue.mainQueue()) { [weak self] notification in //The retain cycle is fixed by using capture lists!  
2. ​    self?.eatHuman() //self is now an optional!  
3. }  

其他我们用到weak和unowned变量的情况是当你使用协议在多个类之间实现代理时，因为Swift中类使用的是reference semantics。在Swift中，结构体和枚举同样能够遵循协议，但是它们用的是value semantics。如果像这样一个父类带上一个子类使用委托使用了代理: 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class Kraken: LossOfLimbDelegate {  
2. ​    let tentacle = Tentacle()  
3. ​    init() {  
4. ​        tentacle.delegate = self  
5. ​    }  
6. ​      
7. ​    func limbHasBeenLost() {  
8. ​        startCrying()  
9. ​    }  
10. }  
11. ​
12. protocol LossOfLimbDelegate {  
13. ​    func limbHasBeenLost()  
14. }  
15. ​
16. class Tentacle {  
17. ​    var delegate: LossOfLimbDelegate?  
18. ​      
19. ​    func cutOffTentacle() {  
20. ​        delegate?.limbHasBeenLost()  
21. ​    }  
22. }  

在这里我们就需要用weak变量了。在这种情况下，Tentacle以代理属性的形式对Kraken有着一个强引用，而Kraken在它的Tentacle属性中对Tentacle也有一个强引用。我们通过在代理声明前面加上weak来解决这个问题： 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. weak var delegate: LossOfLimbDelegate?  

是不是发现这样写不能通过编译？不能通过编译的原因是非 class类型的协议不能被标识成weak。这里，我们必须让协议继承:class，从而使用一个类协议将代理属性标记为weak。 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. protocol LossOfLimbDelegate: class { //The protocol now inherits class  
2. ​    func limbHasBeenLost()  
3. }  

我们什么时候用 :class，通过[苹果官方文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID281)： 

“Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics.” 

本质上来讲，当你有着跟我上述代码一样的引用关系，你就用:class。在结构体和枚举的情况下，没有必要用:class，因为结构体和枚举是value semantics，而类是 reference semantics.  

**UNOWNED **

weak引用和unowned引用有些类似但不完全相同。Unowned 引用，像weak引用一样，不会增加对象的引用计数。然而，在Swift里，一个unowned引用有着非可选类型的优点。这样相比于借助和使用optional binding更易于管理。这和隐式可选类型（[Implicity Unwarpped Optionals](http://www.krakendev.io/when-to-use-implicitly-unwrapped-optionals/)）区别不大。此外，unowned引用是non-zeroing(非零的) ,这表示着当一个对象被销毁时，它指引的对象不会清零。也就是说使用unowned引用在某些情况下可能导致 [dangling pointers](https://www.blackhat.com/presentations/bh-usa-07/Afek/Whitepaper/bh-usa-07-afek-WP.pdf)(野指针url)。你是不是跟我一样想起了用Objective -C的时候, unowned引用映射到了 unsafe_unretained引用。 http://www.krakendev.io/when-to-use-implicitly-unwrapped-optionals/

看到这里是不是有点蛋疼了。既然Weak和unowned引用都不会增加引用计数，它们都能用于解除引用循环。那么我们该在什么使用它们呢？根据苹果[文档](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html)： 

“Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.”

翻译：在引用对象的生命周期内，如果它可能为nil，那么就用weak引用。反之，当你知道引用对象在初始化后永远都不会为nil就用unowned. 

现在你就知道了：就像是[implicitly unwrapped optional](http://www.krakendev.io/when-to-use-implicitly-unwrapped-optionals/)（隐式可选类型），如果你能保证在使用过程中引用对象不会为nil，用unowned 。如果不能，那么就用weak 

下面就是个很好的例子。Class 里面的闭包捕获了self，self永远不会为nil。 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class RetainCycle {  
2. ​    var closure: (() -> Void)!  
3. ​    var string = "Hello"  
4. ​    init() {  
5. ​        closure = {  
6. ​            self.string = "Hello, World!"  
7. ​        }  
8. ​    }  
9. }  
10. //Initialize the class and activate the retain cycle.  
11. let retainCycleInstance = RetainCycle()  
12. retainCycleInstance.closure() //At this point we can guarantee the captured self inside the closure will not be nil. Any further code after this (especially code that alters self's reference) needs to be judged on whether or not unowned still works here.  

在这种情况下，闭包用强引用形式捕获了self，而self也通过闭包属性保留了一个对闭包的强引用，这就出现了引用循环。只要给闭包添加[unowned self] 就能打破引用循环： 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. closure = { [unowned self] in  
2. ​    self.string = "Hello, World!"  
3. }  

在这个例子中，由于我们在初始化RetainCycle类后立即调用了闭包，所以我们可以认为self永远不会为nil。

苹果在[unowned references](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID57)也说明了这点： 

“Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.”

如果你知道你引用的对象会在正确的时机释放掉，且它们是相互依存的，而你不想写一些多余的代码来清空你的引用指针，那么你就应该使用unowned引用而不是weak引用。

像下面这种懒加载在闭包中使用self就是一个使用unowned的很好例子： 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class Kraken {  
2. ​    let petName = "Krakey-poo"  
3. ​    lazy var businessCardName: () -> String = { [unowned self] in  
4. ​        return "Mr. Kraken AKA " + self.petName  
5. ​    }  
6. }  

我们需要用unowned self 来避免引用循环。Kraken 和 businessCardName在它们的生命周期内都相互持有对方。它们相互持有，因此总是被同时销毁，满足使用unowned 的条件。 

然而，不要把下面的懒加载变量与闭包混淆： 

**[js]** [view plain](http://blog.csdn.net/lichang719/article/details/50624361#) [copy](http://blog.csdn.net/lichang719/article/details/50624361#) [print](http://blog.csdn.net/lichang719/article/details/50624361#)[?](http://blog.csdn.net/lichang719/article/details/50624361#)

1. class Kraken {  
2. ​    let petName = "Krakey-poo"  
3. ​    lazy var businessCardName: String = {  
4. ​        return "Mr. Kraken AKA " + self.petName  
5. ​    }()  
6. }  

在懒加载变量中调用closure时，由于没有retain closure，所以不需要加 unowned self。变量只是简单的把闭包的结果assign 给了自己，闭包在使用后就被立即销毁了。下面的截图很好的证明了这点。(截图是厚着脸皮评论区Алексей的拷贝） 

![下载.jpg](http://cc.cocimg.com/api/uploads/20160129/1454053485567250.jpg)





参考文献

[Swift3.0中文文档（非最新）](http://www.cocoachina.com/industry/20140613/8818.html)

[Swift3.0官方文档](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94)







# Swift开发必备技巧：static和class的使用

#### 发表于2015-01-28 14:12| 17193次阅读| 来源Swifter| 8 条评论| 作者王巍

[移动开发](http://www.csdn.net/tag/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/news)[Objective-C](http://www.csdn.net/tag/objective-c/news)[Swift](http://www.csdn.net/tag/swift/news)[开发经验](http://www.csdn.net/tag/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/news)[iOS](http://www.csdn.net/tag/ios/news)[Apple](http://www.csdn.net/tag/apple/news)[编程语言](http://www.csdn.net/tag/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/news)

**摘要：**Swift中表示“类型范围作用域”这一概念有着两个不同的关键字，分别为static和class，而在OC等其他语言中，开发者不会特地区分变量/类方法和静态变量/静态函数。本文作者王巍在这篇Tip中详解了static和class的使用。	

Swift中表示 “类型范围作用域” 这一概念有两个不同的关键字，它们分别是static和class。这两个关键字确实都表达了这个意思，但是在其他一些语言，包括Objective-C中，我们并不会特别地区分类变量/类方法和静态变量/静态函数。但是在Swift中，这两个关键字却是不能用混的。

在非class的类型上下文中，我们统一使用static来描述类型作用域。这包括在enum和struct中表述类型方法和类型属性时。在这两个值类型中，我们可以在类型范围内声明并使用存储属性，计算属性和方法。static适用的场景有这些：

**[cpp]** [view plain](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[copy](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/591221)[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/591221/fork)

1. struct Point {  
2. ​    let x: Double  
3. ​    let y: Double  
4. ​    // 存储属性  
5. ​    static let zero = Point(x: 0, y: 0)  
6. ​    // 计算属性  
7. ​    static var ones: [Point] {  
8. ​        return [Point(x: 1, y: 1),  
9. ​                Point(x: -1, y: 1),  
10. ​                Point(x: 1, y: -1),  
11. ​                Point(x: -1, y: -1)]  
12. ​    }  
13. ​    // 类型方法  
14. ​    static func add(p1: Point, p2: Point) -> Point {  
15. ​        return Point(x: p1.x + p2.x, y: p1.y + p2.y)  
16. ​    }  
17. }  

enum的情况与这个十分类似，就不再列举了。

class关键字相比起来就明白许多，是专门用在class类型的上下文中的，可以用来修饰类方法以及类的计算属性。要特别注意class中现在是不能出现存储属性的，我们如果写类似这样的代码的话：

**[cpp]** [view plain](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[copy](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/591221)[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/591221/fork)

1. class MyClass {  
2. ​    class var bar: Bar?  
3. }  

编译时会得到一个错误：

> class variables not yet supported

这主要是因为在Objective-C中就没有类变量这个概念，为了运行时的统一和兼容，暂时不太方便添加这个特性。Apple表示今后将会考虑在某个升级版本中实装class类型的类存储变量，现在的话，我们只能在class中用class关键字声明方法和计算属性。

有一个比较特殊的是protocol。在Swift中class、struct和enum都是可以实现protocol的。那么如果我们想在protocol里定义一个类型域上的方法或者计算属性的话，应该用哪个关键字呢？答案是使用class进行定义，但是在实现时还是按照上面的规则：在class里使用class关键字，而在struct或enum中仍然使用static——虽然在protocol中定义时使用的是class：

**[cpp]** [view plain](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[copy](http://www.csdn.net/article/2015-01-28/2823738-swift-static-class#)[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/591221)[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/591221/fork)

1. protocol MyProtocol {  
2. ​    class func foo() -> String  
3. }  
4. struct MyStruct: MyProtocol {  
5. ​    static func foo() -> String {  
6. ​        return "MyStruct"  
7. ​    }  
8. }  
9. enum MyEnum: MyProtocol {  
10. ​    static func foo() -> String {  
11. ​        return "MyEnum"  
12. ​    }  
13. }  
14. class MyClass: MyProtocol {  
15. ​    class func foo() -> String {  
16. ​        return "MyClass"  
17. ​    }  
18. }  





```
protocol ImageFactory {
    func createImage(color: UIColor) -> UIImage?
}

extension ImageFactory {
    func createImage(color: UIColor) -> UIImage? {
        let rect = CGRect(x: 0.0, y: 0.0, width: 1.0, height: 1.0)
        UIGraphicsBeginImageContext(rect.size)
        let context = UIGraphicsGetCurrentContext()
        context?.setFillColor(color.cgColor)
        context?.fill(rect)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image ?? nil
    }
}
```



swift工程引用OC pod库  不需要通过桥文件 直接import对应的库名称



selector 在传参使用的时候，花费了我很多的时间，确定切实可用的形式是：self.button?.addTarget(self, action: #selector(play(sender:)), for: .touchUpInside)，并且特别注意 sender: 参数必须和实际函数中的一致。



swift 工程 引用 Swift pod库 

Swift写的 pod 中遇到的错误：import 了对应的 module后还是提示未定义

```
Swift写的需要暴露的部分需要使用public or open修饰，所有需要暴露出去的内容都需要修饰，否则默认其他module是无法使用的

public 只能被本module内容 继承重写
open  可以被其他module内容 继承重写
```

