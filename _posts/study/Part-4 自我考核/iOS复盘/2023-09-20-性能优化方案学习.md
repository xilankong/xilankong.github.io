---
 layout: post
 category: iOS学习总结
 title : "iOS性能优化方案"
---

量化，监控，治理，提升


##### 启动优化


变化：

优化前，只有postmain的时间，大概是 平均在1.5   premain 1.2s
优化后，postmain 平均 700ms  90分位 1.3s    premain 700ms

问题

1、大仓变成全组件化接入，动态库使用过多（动态库的加载 rebase、bind都很耗时）
2、启动任务杂乱添加，无规范，部分业务初始化耗时大
3、load、静态函数的乱用，pageIn的耗时累计

premain前的优化 

1、动态库  减少400ms左右  1.2 - 800
2、+load、静态优化，无用代码资源清理，70ms - 100ms   （扫Mach-o的__DATA __objc_selrefs和__TEXT __objc_methname）
3、后续尝试二进制重排和 page in重命名

postmain部分的优化操作

- 搭建自注册启动机制，按时机节点注册启动项（startPushManager、loginSucss回调处理）
- 能滞后的SDK初始化都滞后（特别是部分依赖配置项接口的启动逻辑），能减少的IO操作、UI操作都减少（userdefault、plist读取、db、IO，读取大张启动图改成小切图读取等）

首屏业务展示部分

- 闪屏和rootVC的同时加载、首页资源下载后置，减少无效页面的初始化
- 首页缓存单独管理，启动时异步线程优先读取，减少缺省情况
- 启动速度快于数据读取速度，减少首次启动接口诉求，优先展示核心数据


工具、防止劣化
- hook obj_sendMsg 获取系统测试阶段的打点统计所有方法耗时，输出火焰图数据，
- 按启动任务输出CSV表格 方便测试验收，对比版本变化
- 流水线监听无用资源、代码的自动扫描， +load方法的统计（静态代码扫描）

- 准入限制
    - 新增动态库
    - 新增 +load 和静态初始化
    - 新增启动任务 Code Review

- 本地测试工具
  - Static Initializer：分析 C++ 静态初始化
  - App Launch：Xcode 11 后新出的模板，可以认为是 Time Profiler + System Trace


剩余的动态库：

FB的一堆库，twitter的库、libpag、下载库、zego库、音视频的一些库


低端机启动、长尾数据的处理

- 精简化启动任务、首屏UI
- 对低内存部分机器的 比如_Text 读取解密耗时的处理
- 主题功能的后置，主动改被动

push等openURL方式进场的启动逻辑

- 后置一些非必要场景的创建，比如我就是来歌房空降的，首页的内容就无需太早构建


埋点节点

- 进程开始时间
- main函数开始
- didFinishLaunch
- firstViewDidAppear





#####  流畅度优化

原本没有流畅度指标，线下有FPS的测算，bugly有统计核心页面的FPS
流畅度的反馈流程页很长，用户反馈-开发打点调试 - 分析 - 优化 周期长，无明确指标，无页面维度量化指标


1、制定流畅度标准

- 采集标准
  - 数据采集标准，CADisplayLink统计的FPS值 （上线性能影响最小，可较大量数据采集分析）

- 流畅度评估标准
  - 页面维度的FPS标准，50分位  90分位
  - 低版本


2、耗时原因分析

- 资源下载 + 播放缓冲 cpu 、内存消耗大，特别是资源下载
- 歌词组件刷新列表耗时，积少成多的UI调用（UI过度渲染）cell中view过多
- 圆角等离屏渲染场景
- 音视频资源渲染  

治理

工具
- 火焰图 + hook objc_msgsend
- instrument

优化的点

- 封面图加载优化，头像挂件等动效图优先首帧解码渲染 SDWebImage，超出图片大小的内存占用部分下采样处理
- 大卡片的复用资源的光栅化处理 圆角的离屏渲染处理
- 取消自动布局，通过模型固化cell高度，减少自动布局耗时，根据模型预排版
- 低端机效果降级，比如圆角、蒙层、渐变等都取消
- 利用RunLoop空闲时间执行预缓存任务


播放优化

- CDN的竞速
- 换链接口的优化，本地缓存
- 
- 双播放器的缓存策略 预加载播放器加载下一视频到首帧，滑动过程不渲染，锚定位结束 到 滑动结束中间进行对应视频的预加载
- 参考runloop部分


在IM场景、评论列表等场景预演过 异步渲染 texture


提升，防止劣化

- hook objc_msgsend 输出火焰图
- 添加规则，让代码读懂火焰图
  - 调用了耗时接口
  - 大量调用同时发生
  - 自动UI测试，自动生成报告


Matrix接入 






#####  包大小优化



原包大小  ipa  130+ ，优化后64


1、armv7架构移除  30M

2、无效图片清理、无用代码清理    
fengniao + 流水线提示 + 手动二次检查后删除

3、图片都用XCAsset管理、大图转webp，非必须资源后置下载，比如歌房礼物特效、特殊玩法的舞台特效

4、UI协助压图

5、未使用的多语言资源

6、转静态库

7、本地hippy兜底包处理



后续尝试：

isInitialized 的结果会保存到元类的 class_rw_t 结构体的 flags 信息里


__TEXT 段迁移
使用 __TEXT 段迁移技术，在链接阶段使用 -rename_section 选项将 __TEXT,__text 迁移到 __BD_TEXT,__text，减少苹果对可执行文件的加密范围，提升可执行文件的压缩效率，从而减少 Download Size。

防止劣化

1、流水线扫描防止劣化，扫描每个字库的大小变更 并通知提示  10KB





5、组件化







6、播放优化






7、wnsSDK





##### IO 文件管理

1、歌房动画资源的播放，选mp4的原因，是否有明显IO消耗




##### 内存管理

https://wetest.qq.com/labs/367


主要内存问题

1、图片缓存 VM imageIO
UIImage imageName 的方式获取图片释放不及时 （系统本身有bitmap数据的缓存机制，即使UIImageView置空了，也不会马上销毁）
imageWithContentsOfFile 方式不会有缓存，但是有频繁IO、解码操作

网图用SDWebImage处理，本地图片大而用的少的图用 imageWithContentsOfFile，自己设定内存监控，进出房间，定时触发内存回收,给系统发内存告警通知

    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:UIApplicationDidReceiveMemoryWarningNotification object:[UIApplication sharedApplication]];
    });

2、跨端Hippy游戏 字符串未释放，长时间循环增长
JSScriptCore


3、PAGView\VAP\Lotties 都是内存大户


4、 buffer数据

音频流打分数据截取用的framebuffer池子异常，持续构建未释放，打分频繁触发



大图渲染：
苹果的CATiledLayer去加载。原理是分片渲染，滑动时通过指定目标位置，通过映射原图指定位置的部分图片数据解码渲染。这里不再累述，有兴趣的小伙伴可以自行了解下官方API。



1、FOOM
【QMAPM已实现】内存快照方案
https://cloud.tencent.com/developer/news/716328

- 获取最新的所有被注册到 runtime 中的对象 objc_copyClassList
- malloc_get_all_zones 获取所有已分配内存  遍历每个zone中管理的内存节点 获取 libmalloc 管理的存活的所有内存节点的指针和大小  分析引用关系
- 获取到的内存节点，逐个对象信息获取、分析
- 写入本地文件，下次启动后上报


采集过程 CFRunLoopObserverCreateWithHandler  监听 kCFRunLoopBeforeWaiting 在空闲时间处理
1、挂起所有非采集线程。
2、获取所有的内存节点，内存对象引用关系以及相应的辅助信息。
3、写入文件。
4、恢复线程状态。

8P App 占用 1G 内存时，采集用时 1.5-2 秒，采集时额外内存消耗 10-20MB，生成的文件 zip 后大小在 5-20MB。

- 可配置频控，单个用户每天多少次，每次间隔时间
- uid + 设备id投放


2、VC泄漏
MLeaksFinder
NSSet存放 objectPtrs,在dealloc后10秒内还没销毁的，就算泄露

3、大内存分配

通过hook malloc_logger函数来分析内存分配情况
// malloc_logger本身是个函数指针，只需要指向自己的malloc_logger实现 就能实现hook，注意要实现原有默认实现，避免覆盖
malloc_logger = (malloc_logger_t *)qmapm_stack_logger;


https://juejin.cn/post/6844904056863850504


4、内存触顶




1、bugly监控的原理


2、FBAllocationTracker 原理



WSMemoryDetector 拆解




内存泄漏检测
OOMDetector
https://mp.weixin.qq.com/s/r0Q7um7P1p2gIb0aHldyNw

内存泄漏
https://www.cnblogs.com/kenshincui/p/13153681.html



大内存分配检测 bugly  分配场景、分配堆栈，内存大小
取的是vmInfo的phys_footprint，理论上说是准确的。

- WebPAllocateDecBuffer
- KSKitAudioPCMDecoder   readFile:ioData:error 
- PNGReadPlugin / ImageIO啊



【QMAPM已实现】App内统计+MetricKit双口径
1. 在每次达到进程内存可用上限的90%时记录为触顶一次，触顶率=触顶次数/设备数。
（1）iOS13及以上，可以精确获取到当前进程可用内存上限
（2）iOS13以下，根据设备物理内存大小的55%作为可用内存（估算值）
2. MetricKit 的OOM率也已支持


【QMAPM已实现】通过malloc_logger指针在每次产生内存分配时，检查是否超过阈值，超过阈值的则记录堆栈并上报；对于频繁realloc场景的记录也做了记录限频降低对性能的影响


Instruments Allocation


##### MetricKit

















##### crash防护















图片处理和性能优化

http://labmain.com/2019/12/18/iOS图片内存管理和性能优化/
