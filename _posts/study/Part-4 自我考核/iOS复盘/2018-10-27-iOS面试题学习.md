---
layout: post
category: iOS学习总结
title : "iOS面试题"
tags: 面试题
---

> 如果你不知道你接下来需要补充学习哪一部分知识，做点面试题吧。





## 底层知识

### 1、对象的创建

![img](https://user-gold-cdn.xitu.io/2020/1/5/16f761c270c257de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```
Person *p = [Person alloc];
Person *p1 = [p init];
Person *p2 = [p init];
NSLog(@"p ==> %@", p);
NSLog(@"p1 ==> %@", p1);
NSLog(@"p2 ==> %@", p2);

输出地址都是一样的

init 仅仅是把 alloc 创建的对象返回，

new 相当于 alloc + init

alloc 调用calloc 分配内存，接着就是 initInstanceIsa(cls, hasCxxDtor)  初始化isa
```

2、Tagged Pointer





### 3、isa是什么

`isa`成员变量在`64位`CPU架构下是8字节，且排在`objc_class`结构体的前8字节。

从`objc_object`的结构可以说明，当系统为一个对象分配好内存，并初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是`isa`。

**`isa`将对象和类关联起来，起到了中间桥梁的作用。**

```
1、isa是isa_t结构，采用 联合体+位域 的搭配来设计：在不同的位上显示不同的内容，以此来节省储存空间，进而优化内存。
2、isa包含了cls和bits两个成员变量，这两个成员变量在64位CPU架构下的长度都是8字节，所以isa在64位CPU架构下的长度也是8字节。
3、isa的位域上存储了一些对象与类的信息，并将对象与类关联起来，起到中间桥梁的作用。
4、isa指向：

对象的isa指针 指向 对象的所属类（如person对象的isa指向Person类）
类的isa指针 指向 类的元类（如Person类的isa指向Person元类）
元类的isa指针 指向 根元类（如Person元类的isa指向NSObject元类）

根元类的isa指针 指向自身（是个圆圈）


元类的继承关系向上传递（如Teacher元类 继承自 Person元类）
```

### 4、方法缓存原理

```
1、cache_t 能缓存调用过的方法
2、cache_t 的三个成员变量
   _buckets : struct bucket_t * , 也就是指针数组，表示一系列的哈希桶（已调用的方法的 SEL 和 IMP 就缓存在这），一个桶可以存一个方法。
   _mask : 侧面反映哈希桶的总数
   _occupied : 代表当前已经缓存的方法数
   
3、当缓存的方法达到临界点（桶总数的3/4）时，下次再缓存新的方法时，首先会丢弃旧的桶，同时开辟新的内存，也就是扩容（扩容后就全是新桶，每个方法都需要重新缓存），_occupied此时为1。

4、当多个线程同时调用一个方法时
   多线程读缓存 : 读缓存由汇编实现，无锁且高效，优于并没有改变 _buckets 和 _mask, 所以并无安全隐患
   多线程写缓存 : OC 用一个全局的互斥锁来保证不会出现写两次缓存的情况
   多线程读写缓存 : OC使用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。

```

### 5、了解一个OC对象

```
一个NSObject对象占用多少内存

new一个NSObject对象解析出来其实就是一个结构体,里面有个isa指针
struct NSObject_IMP {
		Class isa;
};
isa  指针在64位架构占用8个字节


扩展：

一个指针占用多少个字节：64位计算器 8个字节，32位计算器  4个字节，地址就是指针，指针指向地址，而地址是内存单元的编号，一个指针占用几个字节，等于是一个地址的内存单元编号有多长。

4*8 = 32

那一个对象占的就是  8 字节
```



6、block原理

block的本质

```
struct __main_block_impl_0 {

  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int a;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
  
  
关键结构体命名规则：前部分是__所在内部方法名_block_impl_方法体内第几个block

如：__main_block_impl_0

main方法内的第1个block

类似第二个命名为__main_block_impl_1


__main_block_impl_0 的函数地址赋给 block，就是我们平时的block定义

__block_impl 机构体：

struct __block_impl {
	void *isa;
	int Flags;
	int Reserved;
	void *FuncPtrl;  指向我们写在block里面内容函数的地址
}

block的执行是通过  impl  找到 FuncPtrl 然后职级调用函数地址



```

block的捕获列表：

局部变量、static变量

全局变量 不捕获



block的isa指针指向哪里呢，指向_NSConcreteStackBlock 类对象

block最终都是继承自NSBlock类型

```
三类block

在内存角度来看，block分为 全局 、栈 和 堆 三种类型，

有强引用的block就属于堆内存block,   __NSMallocBlock__

只用到外部局部变量、成员属性变量、没有强指针引用的block属于栈block   __NSStackBlock__

只引用全局变量或静态变量的block，生命周期和程序生命周期一样的block就是全局block   __NSGlobalBlock__

```





7、KVO本质（简直）



person在呗添加KVO监听之后发生了什么：

```
person  ->   NSKVONotifying_Person

isa指针会指向 person 子类  NSKVONotifying_Person

NSKVONotifying_Person 里的get、set方法进行了重写，class方法也重写了
```

KVO的本质是什么：

```
当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。

如何手动触发KVO
答. 被监听的属性的值被修改时，就会自动触发KVO。如果想要手动触发KVO，则需要我们自己调用willChangeValueForKey和didChangeValueForKey方法即可在不改变属性值的情况下手动触发KVO，并且这两个方法缺一不可。
```











## 基础部分



#### 1、线程和进程有什么区别

```
进程是一个程序执行的实例，是资源分配的最小单位

线程是进程中的一个实例，是操作系统可以识别的最小执行和调度单位
```

那么，线程和进程与堆、栈之间的关系？

```
栈是线程独有的，保存其运行状态和局部自动变量，栈空间是线程安全的，栈被自动分配到进程的内存空间，栈内存无需开发管理，系统自动管理

堆在操作系统初始化进程的时候分配，运行过程可以要求更多额外的堆内存，但是需要返回，不然呢就是内存泄露
```



#### 2、说一下线程之间的通信

```
例如在多线程并发条件下，为了让线程之间可以更方便的共同完成一个任务，需要一些协调通信，采取的通信方式就是 等待、唤起。

也就是  wait()  和 notify()、 notifyAll()
```



#### 3、当用一个不存在的key来查找两个不同长度的字典，那么哪个效率会高？

```
表面上看可能是一样快，因为字典底层都用了哈希表，查找的时间复杂度为 O(1)，（最差的时候是O(n)）都是一样的，但是可能会由于两个哈希表的负载因子不同，倒是查找的时间也是不同的。
```



#### 4、什么是指针常量和常量指针

```
指针常量是 常量，指针修饰它，这个常量的值是一个指针 int a； int *const b = &a;

常量指针本质是指针，常量修饰它  const int *p; 
```



#### 5、不借用第三个变量，如何交换两个变量的值？

```
算术运算

int a,b;
a=10;b=12;
a=b-a; //a=2;b=12
b=b-a; //a=2;b=10
a=b+a; //a=12;b=10

位运算 异或

int a=10,b=12; //a=1010^b=1100;
a=a^b; //a=0110^b=1100;
b=a^b; //a=0110^b=1010;
a=a^b; //a=1100=12;b=1010;


栈实现

int exchange(int x,int y) 
{ 
stack S; 
push(S,x); 
push(S,y); 
x=pop(S); 
y=pop(S); 
}
```



#### 6、用递归算法求1到n的和

```
func add(n: Int) -> Int {
    var sum = 0
    if n > 0 {
        sum = n + add(n: n - 1)
    } else {
        sum = 0
    }
    return sum
}
```

#### 7、100个数字，求最大值的时间复杂度

```
需要一轮遍历   O(n)
```



#### 8、http 的 POST 和 GET 啥区别？

```
最直观的区别就是GET是获取数据、POST是提交数据

GET请求的数据会附在URL之后

POST把提交的数据则放置在是HTTP包的包体中

GET请求URL受浏览器影响 所以有长度限制

POST没有，一般服务器会做POST数据长度的限制

POST的数据传输不是直接拼接URL 所以相对安全一些

```



#### 9、http和https的区别，说一下http和https的请求过程？

```
http + ssl/tls = https

主要介绍一下，ssl的验证过程  保证安全和数据完整性
```



#### 10、如何用HTTP实现长连接？

```
web端：
Connection:keep-alive

服务器在闲置时候会向客户端发生侦测包，默认闲置时间是2个小时

移动端：
基于tcp的长连接，socket编程技术

```



#### 11、HTTP2.0针对同一个域名的多个请求，会建立多少个tcp连接？

```
https://www.cnblogs.com/zlingh/p/5887143.html
```





#### 12、聊下HTTP post的body体使用form-urlencoded和multipart/form-data的区别。

```
application/x-www-form-urlencoded：窗体数据被编码为名称/值对。这是标准的编码格式。

multipart/form-data：窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分
```



#### 13、通信底层原理

```
OSI采用了分层的结构化技术，共分七层：

物理层：为设备间的数据通信提供传输媒体和互连设备，光纤、无线信道等等

数据链路层：为网络层提供数据传送服务的，包括链路连接的建立、拆除和分离；对帧的收发顺序控制

网络层：数据传送的单位是分组或者包，网络层在给两个不同地理位置的主机之间提供

传输层：定义了一些传输数据的协议和端口号，TCP, UDP；主要从下层接收的数据进行分段和传输，到达目的地后再重组

会话层：通过传输层建立数据传输通道，主要在你的系统之间发起会话或者接受会话请求(IP、MAC、主机名称)

表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取，主要做的就是把应用层提供的信息变换为能够共同理解的形式，提供字符代码，数据格式，控制信息格式，加密等的统一表示。

应用层：为用户的应用程序提供网络服务

TCP/IP 采用四层结构：

网络接口层：硬件、帧头帧尾的添加

网络互联层：确定目标计算机的IP地址

传输层：TCP，确定如何传输

应用层：app
```



#### 14、介绍一下XMPP？

```
XMPP是一种以XML为基础的开放式实时通信协议。

XMPP 是一种很类似于http协议的一种数据传输协议，它的过程就如同“解包装–〉包装”的过程，用户只需要明白它接受的类型，并理解它返回的类型，就可以很好的利用xmpp来进行数据通讯。基于可扩展标记语言（XML）的协议 

XMPP基本结构：客户端 服务器 网关 

通信能够在这三者的任意两个之间双向发生。服务器同时承担了客户端信息记录，连接管理和信息的路由功能。网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS（短信），MSN，ICQ等。基本的网络形式是单客户端通过TCP/IP连接到单服务器，然后在之上传输XML。


XMPP核心协议通信的基本模式就是先建立一个stream，然后协商一堆安全之类的东西，中间通信过程就是客户端发送XML Stanza，一个接一个的。服务器根据客户端发送的信息以及程序的逻辑，发送XML Stanza给客户端。但是这个过程并不是一问一答的，任何时候都有可能从一方发信给另外一方。通信的最后阶段是关闭流，关闭TCP/IP连接。


客户端1  <--> XMPP服务器  <--> 客户端2

两个客户端可以分别和服务器通信，但是客户端之间的通信必须经过服务器


用于一些即时通信
```



#### 15、ssl / tls证书 作用

```
保障通信双方的可靠性，通信的安全和数据的完整性
```

https和ssl在握手方向有什么区别？

```
一个是连接握手，一个是安全校验握手
```



#### 16、socket连接和 http 连接区别

```
Http是基于Tcp的，而Socket是一套编程接口让我们更方便的使用Tcp/Ip协议；

Http是应用层协议，在Tcp/Udp上一层。

1、Http是基于"请求-响应"的，服务器不能主动向客户端推送数据，只能借助客户端请求到后向客户端推送数据，而Sokcet双方随时可以互发数据；

2、Http不是持久连接的，Socket用Tcp是持久连接；

3、Http基于Tcp，Socket可以基于Tcp/Udp；

4、Http连接是通过Socket实现的；

5、Http连接后发送的数据必须满足Http协议规定的格式：请求头、请求头和请求体，而Socket连接后发送的数据没有格式要求。
```

Socket的实现原理及 Socket之间是如何通信的

```
网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。

建立网络通信连接至少要一对端口号（socket）。

socket本质是编程接口（API），对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；

HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

socket分为客户端和服务端，客户端发送连接请求，服务端等待连接请求

当服务端socket监听到客户端socket的请求时，就响应客户端套接字的请求，建立一个新的线程，把服务端套接字描述发送给客户端，一旦客户端确认了此描述，双方正式建立连接，而服务端socket继续处于监听状态，等待其他连接请求
```



#### 17、说一下HTTP协议以及经常使用的code码的含义。

```
一些常见的状态代码为：

200 - 服务器成功返回网页
300 - 重定向之类
404 - 请求的网页不存在
503 - 服务器暂时不可用
```



#### 18、网络拥塞控制、tcp的慢启动

```
不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

简单来说 拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。

原理：

请求发送，每次按窗口数发送数据，收到一个确认就把窗口值加一，逐渐递增，这就是慢开始算法

当网络拥塞，窗口重新回 1 最大慢开始门限变为出现问题的网络拥塞窗口值的一半 这就是拥塞避免算法

然后再次循环。
```



#### 19、TCP 三次握手、四次挥手，为什么 断开连接是4次挥手呢

```

因为TCP连接的时候，最后一次握手表示收到服务器确认的请求可以携带需要发给服务器的数据，三次是最短可能

四次挥手是确保客户端 没有消息要发给服务端，服务端也没有消息要发给客户端了，也可以不用四次，但是就会增加空等待的资源浪费

```





#### 20、聊一聊二叉树搜索（Binary search tree）

```

```





https://www.jianshu.com/p/d6a2eabc8549



https://zhuanlan.zhihu.com/p/33695619



leetCode

剑指offer



### 参考

[网络知识整理](https://xilankong.github.io/ios开发基础/2016/10/30/网络知识学习整理.html)





## OC 部分



#### extern的作用

告诉编译器，这个全局变量在本文件找不到就去其他文件去找。如有必要需要使用#import "x.h"这样编译器才知道到哪里去找。使用extern前要保证对应变量被编译过，想要访问全局变量可以使用extern关键字（全局变量定义不能有static修饰）。

```
比如 A文件中 我声明的全局变量 NSInteger age = 10; 但是属性也不能直接获取。 如下在B文件中可以获取到 ：

extern NSInteger age;
age ++;

NSLog(@"%d",age); // 11

如果不想让age被找到，声明为static

```



#### const的作用

```
常量定义，修饰一个常量

int a = 1;
int b = 2;

int const *p = &a
// 如果const修饰的是*p，那么*p的值是不能改变的，也就是p中存放的a的地址中的值无法改变，但是p的值是可以改变的（也就是p此时可以改变指向）
p = &b;
printf("---");
printf("%p",&b);
printf("---");
printf("%p",p);
printf("---");
printf("%d",*p);

//输出 ---0x7ffeea7e89f8---0x7ffeea7e89f8---2


int *const p = &a;
// 如果const修饰的是p，那么p的值是不能改变的，也就是p中存放的a的地址无法改变（p是int类型的指针变量）。但是*p是可以变化的，我们并没有用const去修饰*p，所以可以通过*p去改变a的值
*p = b;

```



#### static的作用

```
static NSInteger staticValue = 0;

static关键字修饰局部变量：

当static关键字修饰局部变量时，只会初始化一次且在程序中只有一份内存

关键字static不可以改变局部变量的作用域，但可延长局部变量的生命周期（直到程序结束才销毁）

static关键字修饰全局变量：

当static关键字修饰全局变量时，作用域仅限于当前文件，外部类是不可以访问到该全局变量的（即使在外部使用extern关键字也无法访问）

如果需要直接访问  需要引用头文件

```



#### 宏定义

```
宏定义属于预编译指令，在程序运行之前已经编译好了的

#define M_PI  3.14159265358979323846264338327950288

#define SELF(x)  x  //NSLog(@"Hello %@",SELF(name));

#define PLUS(x,y) x + y  //printf("%d",PLUS(3,2));

#define MIN(A,B) A < B ? A : B  // int a = MIN(1,2);

#define NSLog(format, ...) do { \                                                             				fprintf(stderr, "<%s : %d> %s\n",                          				   \
             [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String],  \
             __LINE__, __func__);                                                        \
             (NSLog)((format), ##__VA_ARGS__);                                           \
              fprintf(stderr, "-------\n");                                              \
             } while (0)

```



#### 1、block分几种？分别是怎么样产生的？block的实质是什么？

```
在内存角度来看，block分为 全局 、栈 和 堆 三种类型，

有强引用的block就属于堆内存block, 

只用到外部局部变量、成员属性变量、没有强指针引用的block属于栈block

只引用全局变量或静态变量的block，生命周期和程序生命周期一样的block就是全局block

block的实质是一个对象，一个结构体
```



#### 2、__block修饰的变量为什么能在block里面能改变其值？

```
__block修饰符标记后，block就会访问标记变量本身内存地址，而未标记对象则访问截获拷贝后的变量的内存地址
```



#### 3、block应该用copy关键字还是strong关键字？

```
block 使用 copy 是从 MRC 遗留下来的“传统”

在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区。

在 ARC 中写不写都行

对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
```



#### 4、@property 的本质是什么？

```
@property = ivar + getter + setter;

“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）

“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。

```

#### 5、ivar、getter、setter 是如何生成并添加到类中的

引申一个问题：@synthesize 和 @dynamic 分别有什么作用？

```
完成属性（@property）定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。

我们也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字。
@synthesize lastName = _myLastName;

或者通过 @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。

@property有两个对应的词，

一个是@synthesize（合成实例变量），一个是@dynamic。

如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;

// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)
1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。
```



#### 5、用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？

```
用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。

//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。

```

这里还有一个引申问题：

```
NSMutableArray 如果用 copy修饰了会出现什么问题?

Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSArray0 addObject:]: unrecognized selector sent to instance 0x600000a100c0'

由于使用的是copy属性，本身的可变属性默认有一个不可变的拷贝 NSArray ，所以我们用这个可变数组去添加元素的时候，找不到对应方法而发生crash。
```



#### 6、浅拷贝和深拷贝的区别？

```
浅拷贝（copy）：只复制指向对象的指针，而不复制引用对象本身。
深拷贝（mutableCopy）：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。

只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）

```



#### 8、如何让自己的类用copy修饰符

```
若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：
    1. 需声明该类遵从 NSCopying 协议
    2. 实现 NSCopying 协议的方法。
        // 该协议只有一个方法: 
        - (id)copyWithZone:(NSZone *)zone;
        // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。

```



#### 9、ViewController生命周期

```
按照执行顺序排列：
1. initWithCoder：通过nib文件初始化时触发。
2. awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。     

//如果不是nib初始化 上面两个换成 initWithNibName:bundle:

3. loadView：开始加载视图控制器自带的view。
4. viewDidLoad：视图控制器的view被加载完成。  
5. viewWillAppear：视图控制器的view将要显示在window上。
6. updateViewConstraints：视图控制器的view开始更新AutoLayout约束。
7. viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。
8. viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。
9. viewDidAppear：视图控制器的view已经展示到window上。 
10. viewWillDisappear：视图控制器的view将要从window上消失。
11. viewDidDisappear：视图控制器的view已经从window上消失。
```



#### 10、OC的反射机制

```
1). class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@"student"); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);
2). SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@"setName");  
        [stu performSelector:selector withObject:@"Mike"];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
```

#### 11、self 和 super

```
self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。

```



#### 12、id 和 NSObject＊的区别

```
id是一个 objc_object 结构体指针，定义是
typedef struct objc_object *id
id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。

NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。

不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。

```

引申： id 和 instancetype 的区别

```
instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！

相同点：
都可以作为方法的返回类型

不同点：
instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象
instancetype只能作为返回值，不能像id那样作为参数
```



#### 13、NSDictionary的实现原理是什么？

```
一：字典原理

NSDictionary（字典）是使用hash表来实现key和value之间的映射和存储的

方法：- (void)setObject:(id)anObject forKey:(id)aKey;

Objective-C中的字典NSDictionary底层其实是一个哈希表



```

引申：字典的查询工作原理

```
字典的工作原理 ？怎100w个中是怎么快速去取value？


```



#### 14、你们的App是如何处理本地数据安全的（比如用户名的密码）？

```
本地尽量不存储用户隐私数据、敏感信息

使用如AES256加密算法对数据进行安全加密后再存入SQLite中

或者数据库整体加密

存放在keychain里面

向Keychain中存储数据时，不要使用kSecAttrAccessibleAlways，而是使用更安全的kSecAttrAccessibleWhenUnlocked或kSecAttrAccessibleWhenUnlockedThisDeviceOnly选项。 

AES  DES
```



#### 15、遇到过BAD_ACCESS的错误吗？你是怎样调试的？

90%的错误来源在于对一个已经释放的对象进行release操作, 或者说对一个访问不到的地址进行访问，可能是由于些变量已经被回收了，亦可能是由于使用栈内存的基本类型的数据赋值给了id类型的变量。

例如：

```
id x_id = [self performSelector:@selector(returnInt)];
    
- (int)returnInt { return 5; }

上面通过id去接受int返回值，int是存放在栈里面的，堆内存地址如何找得到，自然就是 EXC_BAD_ACCESS。

```

**处理方法**

1、xcode可以用僵尸模式打印出对象 然后通过对象查找对应的代码位置

```
1、Edit Scheme - Diagnositics - Memory Management 勾选 Zombie Objects 和 Malloc Stack

2、会打印出 
cyuyan[7756:17601127] *** -[UIViewController respondsToSelector:]: message sent to deallocated instance 0x7fe71240d390

这句开启僵尸模式后打出来的输出，包含了我们需要的 进程pid、崩溃地址，终端通过下面命令查看堆栈日志来找到崩溃代码

3、查找日志
sudo malloc_history 7756 0x7fe71240d390
```



2、在 other c flags中加入-D FOR_DEBUG（记住请只在Debug Configuration下加入此标记）。这样当你程序崩溃时，Xcode的console上就会准确地记录了最后运行的object的方法。重写一个object的respondsToSelector方法，打印报错前的

```
#ifdef _FOR_DEBUG_  
-(BOOL) respondsToSelector:(SEL)aSelector {  
    printf("SELECTOR: %s\n", [NSStringFromSelector(aSelector) UTF8String]);  
    return [super respondsToSelector:aSelector];  
}  
#endif
```

3、通过instruments的Zombies

**引申：怎么定位到野指针的地方。如果还没定位到，这个对象被提前释放了，怎么知道该对象在什么地方释放的**

```
一种是多线程，一种是野指针。这两种Crash都带随机性，我们要让随机crash变成不随机

把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。

1、Edit Scheme - Diagnositics - Memory Management 勾选 Malloc Scribble

暂时未解决

```



#### 16、如何设计一个通知中心

```
单例设计一个NotificationCenter，NSPointerArray 保存 observer，对象销毁 observer自动变null

```



#### 17、KVO、KVC的实现原理

**KVC（ 键值编码 ）实现**

```
1.KVC是基于runtime机制实现的

2、可以访问私有成员变量、可以间接修改私有变量的值

[object setValue:@"134567" forKey:@"uid"];

就会被编译器处理成:
// 首先找到对应sel
SEL sel = sel_get_uid("setValue:forKey:");
// 根据object->isa找到sel对应的IMP实现指针
IMP method = objc_msg_lookup (object->isa,sel);
// 调用指针完成KVC赋值
method(object, sel, @"134567", @"uid");

KVC键值查找原理

setValue:forKey:搜索方式

1、首先搜索setKey:方法.(key指成员变量名, 首字母大写)
2、上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名。(这个类方法是NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)
3、如果没有找到成员变量, 调用setValue:forUnderfinedKey:

valueForKey:的搜索方式

1、首先按getKey, key, isKey的顺序查找getter方法, 找到直接调用. 如果是BOOL、int等内建值类型, 会做NSNumber的转换.
2、上面的getter没找到, 查找countOfKey, objectInKeyAtindex, KeyAtindexes格式的方法. 如果countOfKey和另外两个方法中的一个找到, 那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法.
3、还没找到, 查找countOfKey, enumeratorOfKey, memberOfKey格式的方法. 如果这三个方法都找到, 那么就返回一个可以响应NSSet所有方法的代理集合.
4、还是没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey, key, iskey的顺序搜索成员名.
5、再没找到, 调用valueForUndefinedKey.

```



**KVO实现  键值观察、观察者模式的一种应用**

```
简答

1.KVO是基于runtime机制实现的

2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制

3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person

4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法

5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。

深入

1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：?NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter?方法，setter?方法会负责在调用原?setter?方法之前和之后，通知所有观察对象属性值的更改情况。

2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；

3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。

4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。）?因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。

5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath?的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath?的属性值已经变更；之后，?observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter?方法这种继承方式的注入是在运行时而不是编译时实现的。

```



#### 19、category为什么不能添加属性？

```
category 它是在运行期决议的，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。

extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。

但是category则完全不一样，它是在运行期决议的。 
就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的。

那为什么 使用Runtime技术中的关联对象可以为类别添加属性。

其原因是：关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。

如合清理关联对象？

runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。（详见Runtime的源码）
```

http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/

#### 20、说一下runloop和线程的关系

```
runloop与线程是一一对应的

runloop是来管理线程的

线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）
```



#### 21、说一下autoreleasePool的实现原理

```
autoreleasePool是一个延时release的机制， 在自动释放池被销毁或耗尽时，会向池中的所有对象发送release消息，释放所有autorelease对象。

ARC下，我们使用@autoreleasepool{}来使用一个自动释放池

AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage作为结点以双向链表的形式组合而成。整个链表以堆栈的形式运作。
1、每一个指针代表一个加入到释放池的对象 或者是哨兵对象，哨兵对象是在 @autoreleasepool{} 构建的时候插入的

2、当自动释放池 pop的时候，所有哨兵对象之后的对象都会release

3、链表会在一个Page空间占满时进行增加，一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入。


主线程：

主线程runloop中注册了两个Observer，回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。

第一个oberver监听 当从休眠状态即将进入loop的时候 ，这个时候，构建自动释放池

第二个oberver监听 当准备进入休眠状态的时候，调用 objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池


子线程：

runloop默认不开启，不会自动创建自动释放池，在需要使用自动释放池的时候，需要我们手动创建、添加自动释放池，此时如果所有的异步代码都写在自动释放池中，也可以理解为当子线程销毁的时候，自动释放池释放

```

http://blog.sunnyxx.com/2014/10/15/behind-autorelease/

http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/#jtss-tsina



#### 22、说一下简单工厂模式，工厂模式以及抽象工厂模式？

```
简单工厂模式：根据外部信息就可以决定创建对象，所有产品都通过工厂判断就创建，体系结构很明显，缺点就是集中了所有的产品创建逻辑，耦合太重。

工厂模式：产品的各自创建逻辑下发到各自的工厂类中，一定程度达到解耦合。 多态性，产品构建逻辑可以具体到对应的产品工厂类中，更加清晰。 当我需要新产品的时候，只需要添加一个新的产品工厂，实现抽象工厂的产品产出方法，产出对应的产品。不影响客户逻辑。

抽象工厂模式：当有多个产品线，需要多个工厂分别生产不同的产品线产品，这个时候我们抽象出工厂逻辑，产品也抽象出产品类型，工厂抽象类只需要构建返回抽象产品的方法即可，更深程度的解耦。具体的什么工厂产什么产品逻辑下发到实际工厂实现。 即使添加新产品也不影响抽象工厂和抽象产品的逻辑。

```



#### 23、如何设计一个网络请求库

```
网络请求库需要的功能：

1、在任意位置发起请求

2、请求表单的创建 (url拼接、参数填充、http请求方法确认)

3、UI-Loading

4、数据解析

5、异常处理

6、结果提示

自己分装的 一个 API 网络请求库 
```



#### 24、说一下多线程，你平常是怎么用的？

```
常用的有 GCD 和 NSOperation 、NSThread 

NSThread 用于获取当前线程等操作

GCD 和 NSOperation 实现多线程操作不需要自己管理线程，操作简单

GCD block的使用方式比NSOperation 适合简单操作，NSOperation 对象级操作方法更多，更复杂操作适用
```



#### 25、说一下UITableViewCell的卡顿你是怎么优化的？

```
一般简单的UITableViewCell都不会卡顿，TableView本身有Cell重用机制，但一些复杂的自适应高度的cell比较容易产生卡顿。

1、避免cell的过多重新布局，差别太大的cell之间不要选择重用。

2、提前计算并缓存cell的高度，内容

3、尽量减少动态添加View的操作

4、减少所有对主线程有影响的无意义操作

5、cell中的图片加载用异步加载，缓存等

6、局部更新cell

7、减少不必要的渲染时间，比如少用透明色之类的
```



#### 28、什么是ARC？（ARC是为了解决什么问题诞生的？）

```
ARC全称是 Automatic Reference Counting，是Objective-C的内存管理机制。简单地来说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。

ARC的使用是为了解决对象retain和release匹配的问题。以前手动管理造成内存泄漏或者重复释放的问题将不复存在。

以前需要手动的通过retain去为对象获取内存，并用release释放内存。所以以前的操作称为MRC (Manual Reference Counting)。

```



#### 29、请解释以下keywords的区别： assign vs weak,  _block vs  _weak

```
weak和assign都是引用计数不变，两个的差别在于，weak用于object type，就是指针类型，而assign用于简单的数据类型，如int BOOL 等。

assign看起来跟weak一样，其实不能混用的，assign的变量在释放后并不设置为nil（和weak不同），当你再去引用时候就会发生错误，崩溃，EXC_BAD_ACCESS.

assign 可以修饰对象么？ 可以修饰，编译器不会报错，但是访问过程中对象容易野指针

__block 用于标记需要在block内部修改的变量，__weak 用于防止引用循环



其他关键字

 assign，weak，unsafe_unretained，strong，retain ，copy，readonly，readwrite , nonatomic，natomic及 __weak，__block ，@synthesize 和 @dynamic 
```



#### 30、使用atomic一定是线程安全的吗？

```
atomic只能保证操作也就是存取属性的时候的存取方法是线程安全的，并不能保证整个对象就是线程安全的。

比如NSMutableArray 设置值得时候是线程安全的，但是通过objectAtIndex访问的时候就不再是线程安全的了。还是需要锁来保证线程的安全。

```



#### 31、描述一个你遇到过的retain cycle例子

```
VC中一个强引用block里面使用self

代理使用强引用

sqllite多线程抢写入操作
```



#### 32、+(void)load;  +(void)initialize; 有什么用处？方法分别在什么时候调用的?

```
+(void)load;

当类对象被引入项目时, runtime 会向每一个类对象发送 load 消息。
load 方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类, 子类优先于分类。
由于 load 方法会在类被 import 时调用一次,而这时往往是改变类的行为的最佳时机，在这里可以使用例如 method swizlling 来修改原有的方法。
load 方法不会被类自动继承。

+(void)initialize;

也是在第一次使用这个类的时候会调用这个方法，也就是说 initialize 也是懒加载

总结：

在 Objective-C 中，runtime 会自动调用每个类的这两个方法
1.+load 会在类初始加载时调用
2.+initialize 会在第一次调用类的类方法或实例方法之前被调用
这两个方法是可选的，且只有在实现了它们时才会被调用
两者的共同点：两个方法都只会被调用一次

```



#### 33、谈一谈消息发送 或者 对runtime的理解, 说一下工作中是如何使用runtime的？看过runtime源码吗？

```
runtime是 oc 语言特性，方法调用采用消息发送的方式，直到项目运行阶段才能最终确定，并且还可以动态添加成员变量与方法。

项目中用的多的runtime应该是方法实现的替换，动态属性的添加，KVO，performSelector，消息转发之类

```



#### 34、如何高性能的给UIImageView加个圆角？

```
如何高性能的给 UIImageView 加个圆角?

不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。

self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;

正确的解决方案：使用绘图技术

- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}
还有一种方案：使用了贝塞尔曲线"切割"个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。

UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];

```



#### 36、设计一个检测主线程卡顿的方案

```
卡顿的原因就是耗时长，设计一个检测主线程方法执行时间过长的方案
```



#### 37、说几个你在工作中使用到的线程安全的例子

```
多线程同时操作同一个数据源的时候

AFNetworking 对于session的构建等都是线程安全的
```



#### 38、用过哪些锁？哪些锁的性能比较高？谈下Objective C都有哪些锁机制，你一般用哪个？

```
常用的锁有 NSLock、@synchronized代码块、信号量 dispatch_semaphore_t

信号量性能最高

@synchronized代码块 最方便
```



#### 32、说一下静态库和动态库之间的区别

```
静态库 

.a 、.framework 结尾
是一个已经编译好了的集合，使用的时候连接器会把静态库合并到可执行文件中。


动态库  
.tbd 或 .framework结尾

编译过程不会被链接到目标代码中, 只会将动态库头文件添加到目标app的可执行文件，程序运行的时候被添加在独立于app的内存区域。

```



#### 36、说一下你对架构的理解？ 技术架构如何搭建？

```
设计一个架构 需要考虑多个层次

1、代码风格、例如 代码整齐，一个类不能干两个事情，目录设定要清晰一眼就知道是干什么的，不要设置什么common module之类的目录，面向协议开发，瘦Controller啊等

2、规范业务块的分层，例如 MVC 或者 MVVM，统一的业务处理分层，让业务代码更清晰，耦合性也低

3、基础层的定义， 开发帮助库，例如 网络库，数据持久化库，路由库，要求易于扩展、易于测试，易于理解，让开发小伙伴上手快，接口方法设定要灵活，减少开发小伙伴的使用成本

4、组件化，一个架构本身也需要良好的封装，合理的组件化可以让功能更清晰，耦合性也更低，

大的组件化就是项目层级，把不常改动的基础库沉底，比如放pod中，经常扩展的内容放在工程里面，独立的业务块可以通过工程的方式依赖

小的组件化就是UI方面，统一封装管理UI轮子，避免一个东西出现很多份的情况

```

[参考文章一 ](https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)

[参考文章二](https://link.jianshu.com/?t=https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html)



#### 37、为什么一定要在主线程里面更新UI？

```
UIKit 不是线程安全的，容易产生UI更新上的混乱
```



#### 39、讲讲你用Instrument优化动画性能的经历吧

```
core animation的使用

time profiler 的使用
```



#### 40、loadView是干嘛用的？

```
self.view的初始化，根据xib初始化或者init初始化
```



#### 41、viewWillLayoutSubView

```
controller layout触发的时候，开发者有机会去重新layout自己的各个subview。说UI熟悉的一定要知道。

当子View发生frame的变动的时候会触发layoutsubView，我们可以在这个方法中提前做一些预处理
```



#### 42、GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？

```
两种queue，串行和并行。

main queue是串行，global queue是并行。

有些开发者为了在工作线程串行的处理任务会自己建立一个serial queue。背后是苹果维护的线程池，各种queue要用线程都是这个池子里取的。

```



#### 43、用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？

```
sqlite 一个线程A操作写入、一个线程B操作读取，在第一个线程等待写入的过程中也发起写入，写入操作在普通的事务操作 begin trancaction  commit transaction ，这种情况就会死锁

两个线程都争取写入操作，因为在A线程等待变成排他锁的过程中处于待定锁状态，并不会拒绝B线程的保留锁的获取，导致B线程一直不释放共享锁，A就一直得不到排他锁，造成死锁。


单个线程可以死锁（main thread里dispatch_sync到main queue），

多个线程直接也可以死锁（A，B线程互相持有对方需要的资源且互相等待）。
```

[关于sqllite锁](https://xilankong.github.io/ios开发基础/2016/08/27/持久化方式和文件存储知识学习整理.html)



#### 44、NSString如何计算字符的个数？

```
- (int)myStrLength:(NSString *)str {
    int length = 0;
    char * p_str = [str cStringUsingEncoding:NSUTF8StringEncoding];
    for (int i = 0; i < [str lengthOfBytesUsingEncoding:NSUTF8StringEncoding]; i++) {
        if (*p_str) {
            p_str++;
            length++;
        } else {
            p_str++;
        }
    }
    return length;
}
```



#### 45、PKI体系（其实就是CA证书验证体系）当中加密和签名有什么区别？

```
签名密钥对用于数据的完整性检测，保证防伪造与防抵赖，签名私钥的遗失，并不会影响对以前签名数据的验证，因此，签名私钥无须备份，因此，签名密钥不需要也不应该需要第三方来管理，完全由持有者自己产生；

加密密钥对用于数据的加密保护，若加密私钥遗失，将导致以前的加密数据无法解密，这在实际应用中是无法接受的，加密私钥应该由可信的第三方（即通常所说的CA）来备份，以保证加密数据的可用性，因此，加密密钥对可以由第三方来产生，并备份。

一个加密 一个保证完整性
```



#### 47、数据库建表的时候索引有什么用？

```
可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
```



#### 49、iOS下如何实现指定线程数目的线程池？

```
使用信号量

GCD的信号量机制（dispatch_semaphore）

信号量是一个整型值，有初始计数值；可以接收通知信号和等待信号。当信号量收到通知信号时，计数+1；当信号量收到等待信号时，计数-1；如果信号量为0，线程会阻塞，直到线程信号量大于0，才会继续下去。

使用信号量机制可以实现线程的同步，也可以控制最大并发数。以下是控制最大并发数的代码。


dispatch_queue_t workConcurrentQueue = dispatch_queue_create("cccccccc", DISPATCH_QUEUE_CONCURRENT);
dispatch_queue_t serialQueue = dispatch_queue_create("sssssssss",DISPATCH_QUEUE_SERIAL);
dispatch_semaphore_t semaphore = dispatch_semaphore_create(3);
for (NSInteger i = 0; i < 10; i++) {
dispatch_async(serialQueue, ^{
dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
dispatch_async(workConcurrentQueue, ^{
    NSLog(@"thread-info:%@开始执行任务%d",[NSThread currentThread],(int)i);
    sleep(1);
    NSLog(@"thread-info:%@结束执行任务%d",[NSThread currentThread],(int)i);
    dispatch_semaphore_signal(semaphore);});
});
}
NSLog(@"主线程...!");

说明：从执行结果中可以看出，虽然将10个任务都异步加入了并发队列，但信号量机制控制了最大线程并发数，始终是3个线程在执行任务。此外，这些线程也没有阻塞线程。
```





#### 50、函数式编程当中的 first-class function是什么意思呢？

```
函数是一等公民

函数能像参数那样被传递到另一个函数、从另一个函数那像值一样被返回出来、函数可以赋值给变量或者存在数据结构中。
```





#### 51.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？

```
可能造成tableView卡顿的原因有：

1.最常用的就是cell的重用， 注册重用标识符

如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell

如果有很多数据的时候，就会堆积很多cell。

如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell

2.避免cell的重新布局

cell的布局填充等操作 比较耗时，一般创建时就布局好

如可以将cell单独放到一个自定义类，初始化时就布局好

3.提前计算并缓存cell的属性及内容

当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度

而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell

4.减少cell中控件的数量

尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，

不适用的可以先隐藏

5.不要使用ClearColor，无背景色，透明度也不要设置为0

渲染耗时比较长

6.使用局部更新

如果只是更新某组的话，使用reloadSection进行局部更

7.加载网络数据，下载图片，使用异步加载，并缓存

8.少使用addView 给cell动态添加view

9.按需加载cell，cell滚动很快时，只加载范围内的cell

10.不要实现无用的代理方法，tableView只遵守两个协议

11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可

12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。

13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；

14.使用正确的数据结构来存储数据。

```



#### 53、让你设计一种机制检测UIViewController的内存泄漏，你会怎么做？Instrument是如何检测内存泄漏的

```
swizzle NavigationController 的 push 和 pop方法

pop了控制器后过几秒钟进行一遍判断，如果为nil表示已销毁，没有则表示内存泄露

dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [weakSelf assertNotDealloc];
});
```



#### 54、通过[UIImage imageNamed:]生成的对象什么时候被释放？

```
这种图片加载方式带有图片缓存的功能，使用这种方式加载图片后，图片会自动加入系统缓存中，并不会立即释放到内存。一些资源使程序中经常使用的图片资源，
使用这种方式会加快程序的运行减少IO操作，但对于项目中只用到一次的图片，如果采用这种方案加载，会增导致程序的内存使用增加。

非缓存的加载方式
(UIImage *)imageWithContentsOfFile:(NSString *)path
(UIImage *)
:(NSData *)data
```



#### 55、applicationWillEnterForeground和applicationDidBecomeActive都会在哪些场景下被调用？举例越多越好。

```
后台进入前台

通知中心回来

正常启动app
```



#### 56、如何终止正在运行的工作线程？

```
block 中 return;

[thread cancle]
```



#### 57、穷举iOS下所有的本地持久化方案。

```
plist

preference  NSUserDefault

NSKeyedArchiver

SQLite3

coreData

沙盒
```



#### 58、项目中网络层如何做安全处理

```
1、尽量使用https

https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。

2、不要传输明文密码

不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh token去申请新的token。

3、Post并不比Get安全

事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。

4、不要使用301跳转

301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。

5、http请求都带上MAC

所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication

Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request

params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。

6、http请求使用临时密钥

高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES

key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES

key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。

7、AES使用CBC模式

不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。
```



#### 59、假如Controller太臃肿，如何优化？

```
1.将网络请求抽象到单独的类中

方便在基类中处理公共逻辑；

方便在基类中处理缓存逻辑，以及其它一些公共逻辑；

方便做对象的持久化。

2.将界面的封装抽象到专门的类中

构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。

3.构造 ViewModel

借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。

4.专门构造存储类

专门来处理本地数据的存取。

5.整合常量

```



#### 60、M、V、C相互通讯规则你知道的有哪些？

```
MVC 是一种设计思想，一种框架模式，是一种把应用中所有类组织起来的策略，它把你的程序分为三块，分别是：

M（Model）：实际上考虑的是“什么”问题，你的程序本质上是什么，独立于 UI 工作。是程序中用于处理应用程序逻辑的部分，通常负责存取数据。

C（Controller）：控制你 Model 如何呈现在屏幕上，当它需要数据的时候就告诉 Model，你帮我获取某某数据；当它需要 UI 展示和更新的时候就告诉 View，你帮我生成一个 UI 显示某某数据，是 Model 和 View 沟通的桥梁。

V（View）：Controller 的手下，是 Controller 要使用的类，用于构建视图，通常是根据 Model 来创建视图的。

要了解 MVC 如何工作，首先需要了解这三个模块间如何通信。

MVC通信规则

http://cc.cocimg.com/api/uploads//20171127/1511752329535960.jpg

Controller to Model

可以直接单向通信。Controller 需要将 Model 呈现给用户，因此需要知道模型的一切，还需要有同 Model 完全通信的能力，并且能任意使用 Model 的公共 API。

Controller to View

可以直接单向通信。Controller 通过 View 来布局用户界面。

Model to View

永远不要直接通信。Model 是独立于 UI 的，并不需要和 View 直接通信，View 通过 Controller 获取 Model 数据

View to Controller

View 不能对 Controller 知道的太多，因此要通过间接的方式通信。

Target

action。首先 Controller 会给自己留一个 target，再把配套的 action 交给 View 作为联系方式。那么 View

接收到某些变化时，View 就会发送 action 给 target 从而达到通知的目的。这里 View 只需要发送

action，并不需要知道 Controller 如何去执行方法。

代理。有时候 View 没有足够的逻辑去判断用户操作是否符合规范，他会把判断这些问题的权力委托给其他对象，他只需获得答案就行了，并不会管是谁给的答案。

DataSoure。View 没有拥有他们所显示数据的权力，View 只能向 Controller 请求数据进行显示，Controller 则获取 Model 的数据整理排版后提供给 View。

Model 访问 Controller

同样的 Model 是独立于 UI 存在的，因此无法直接与 Controller 通信，但是当 Model 本身信息发生了改变的时候，会通过下面的方式进行间接通信。

Notification & KVO一种类似电台的方法，Model 信息改变时会广播消息给感兴趣的人 ，只要 Controller 接收到了这个广播的时候就会主动联系 Model，获取新的数据并提供给 View。

从上面的简单介绍中我们来简单概括一下 MVC 模式的优点。

1.低耦合性

2.有利于开发分工

3.有利于组件重用

4.可维护性
```



#### 60、什么是MVVM，请设计View model需要考虑哪些？MVC缺点是什么

```
M + V + VM , VM的作用主要用于简化Controller的负担，但是VM的设计中不可以没有C，其实应该是 M + V + C +VM , C 作为 关联 V 和 VM 的纽带，V 最好不要直接关联VM。


MVC缺点

胖VC ，VC 和V、和M耦合很重


MVP

Controller/Presenter负责逻辑的处理  View 不和 Model通信

```



#### 61、NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?

```
1.不准

2.不准的原因如下：

1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。

2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。

当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。

PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。

方法一：

1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。

self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];

[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];

2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；

- (void)timerMethod2 {
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
[thread start];
}
- (void)newThread
{
@autoreleasepool
{
[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] run];
}
}
总结：

一开始的时候系统就为我们将主线程的main runloop隐式的启动了。

在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop

方法二：

使用示例

使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。

关于数据结构mach_timebase_info的定义如下：

struct mach_timebase_info {uint32_t numer;uint32_t denom;};
#include
#include
static const uint64_t NANOS_PER_USEC = 1000ULL;
static const uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;
static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;
static mach_timebase_info_data_t timebase_info;
static uint64_t nanos_to_abs(uint64_t nanos) {
return nanos * timebase_info.denom / timebase_info.numer;
}
void example_mach_wait_until(int seconds)
{
mach_timebase_info(&timebase_info);
uint64_t time_to_wait = nanos_to_abs(seconds * NANOS_PER_SEC);
uint64_t now = mach_absolute_time();
mach_wait_until(now + time_to_wait);
}
方法三：直接使用GCD替代！
 
 cgd timer
 

self.gcdTime = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
// 开始时间支持纳秒级别
dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)2 * NSEC_PER_SEC);
// 2秒执行一次
uint64_t dur = (uint64_t)(2.0 * NSEC_PER_SEC);
// 最后一个参数是允许的误差，即使设为零，系统也会有默认的误差
dispatch_source_set_timer(self.gcdTime, start, dur, 0);
// 设置回调
dispatch_source_set_event_handler(self.gcdTime, ^{
    NSLog(@"---%@---%@",[NSThread currentThread],self);
});


取消定时器：dispatch_cancel(self.gcdTimer);
```



#### 62、你知道哪些设计模式，并简要叙述？

```
1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。
2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。
3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。
4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。
5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。
6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。
```



#### 63、import 跟 #include 有什么区别，@class呢，#import<> 跟 #import”” 有什么区别？

```
1. #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。
2. @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3. #import<> 用来包含系统的头文件，#import””用来包含用户头文件。
```



#### 64、tableView的重用机制能简单说一下么？

```
cell池
visibleCells 当前显示的cells

reusableTableCells 保存重用的cells

dequeueReusableCellWithIdentifier 获取重用cell

超出屏幕的时候 更新 reusableTableCells
reload的时候  更新 reusableTableCells

reusableTableCells为空的话  reloadRowsAtIndex 也会更新

```



#### 65、写一个线程安全的单例模式 - 保证线程安全的方式（加锁和GCD栅栏，队列组相关知识）

```
加锁访问不就好了么

```



#### 66、在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？

```
UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。
```



#### 67、自定义库要注意些什么

```
抽象和封装，方便使用。

首先是对问题有充分的了解，比如构建一个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个解压请求，框架完成复杂文件的解压操作，

并且在适当的时候通知给使用者，如解压完成、解压出错等。

在框架内部去构建对象的关系，通过抽象让其更为健壮、便于更改。其次是API的说明文档。

```



#### 68、对于Objective-C，你认为它最大的优点和最大的不足是什么

```
最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以

对项目buildsetting里的other linker flags进行修改（第三方静态库引用者修改）

Bulding Setting里设置的other linker flags添加的有-Objc，而-Objc得作用就是将加载的静态库中的分类一并加载到程序的可执行文件，如果不添加这个参数，很有可能会出现selector not recognized问题，主要是找不到分类定义的方法。
-Objc添加后就会出现多个静态库定义同样的方法、全局变量等，然后就会出现上面的问题duplicate symbol。
```



#### 69、NSOperationQueue

你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和G.C.D的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。

```
使用NSOperationQueue用来管理子类化的NSOperation对象，控制其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别是 NSOperation和NSOperationQueue是多线程的面向对象抽象。

项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接口简单，建议在复杂项目中使用。

项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。

```



#### 70、程序内存分区

程序内存分区
以下是比较常用的五分区方式，当然也不排除网上有其他的分区方式。

```
栈
栈的大小在编译时就已经确定了，一般是2M；栈是一块从高到低地址的连续区域，存放临时变量和执行函数时的内存等。栈内存分配分为动态和静态，静态如自动变量（局部变量）等，动态如alloc等。

堆
堆是从低到高地址的不连续区域，类似链表；用来存放malloc或new申请的内存。

全局/静态
存放静态/全局变量；全局区细分为未初始化/初始化区。

常量
存放常量；程序中使用的常量会到常量区获取。
可以看看这个例子来理解一下。

...int a;//a在全局未初始化区int a = 10;//a在全局初始化区 10在常量区static int a = 10;//a在静态区 10在常量区//程序入口int main(...) {   int a = 10;//a在栈区 10在常量区
   static int a = 10;//a在静态区 10在常量区
   char *a = (char *)malloc(10); //a在栈区 malloc后的内存在堆区
   ...
}
代码
存放二进制代码，运行程序就是执行代码，代码要执行就要加载进内存（RAM运行内存）。


```



#### 71、指针函数 / 函数指针 / Block

**指针函数**

C语言的概念；本质是函数，返回指针。

```
char *fun() {    char *p = "";    return p;
}
```

**函数指针**

C语言的概念；本质是指针，指向函数。

```
int fun(int a,int b) {    return a + b;
}int (*func)(int,int);
func = fun;
func(1,2);//3
```

**Block**

OC语言的概念；表示一个代码块，OC中视为对象；挺像C函数指针的。

```
//typedeftypedef int (^SumBlock)(int a,int b);
SumBlock sumBlock = ^(int a,int b) {    return a + b;
};
sumBlock(1,2);//3//普通
 int (^sumBlock)(int a,int b) = ^(int a,int b) {    return a + b;
};
sumBlock(1,2);//3
```



#### 72、iOS类和结构体有什么区别

```
1：类指针赋值时只是复制了地址，结构体是复制内容；
2：类不能有同名同参数个数的方法，结构体可以；
3：结构体方法实现编译时就确定了，类方法实现可动态改变；
4：内存分配不一样，结构体在栈，类在堆；
5：结构体可以多重继承，类只能单继承。
```



#### 73、线程安全方法

```
线程安全：多线程环境下保证数据的完整性。

队列

把操作放入队列线性执行，可用GCD和NSOperationQueue。

锁/信号量

用锁/信号量形成操作互斥。

让操作原子化

让操作原子执行，系统提供了一些原子执行的方法。

```

###### 了解更多

[iOS-线程安全](https://juejin.im/entry/59cbbd1f6fb9a00a664a468f)



#### 74、NSOperationQueue和GCD区别联系

```
区别

NSOperationQueue没有串行/并发队列，但可以设置最大并发数；
NSOperationQueue支持方法和block，GCD只支持block；
NSOperationQueue可以暂停/取消操作；
NSOperationQueue支持更多的功能，比如KVO和自定义操作；
NSOperationQueue可以设置操作的优先级，GCD只能设置队列的优先级。

联系

提供的功能是相似的；
NSOperationQueue是GCD的封装。

```



#### 75、对程序性能的优化你有什么建议?

```
1.使用复用机制
2.尽可能设置 View 为不透明
3.避免臃肿的 XIB 文件
4.不要阻塞主线程
5.图片尺寸匹配 UIImageView，避免巨大图片
6.选择合适的容器
8.View 的复用和懒加载机制
9.缓存  服务器的响应信息（response）、 图片、计算值。比如：UITableView 的 row heights。
10.关于图形绘制、减少离屏渲染(设置圆角和阴影的时候可以选用绘制的方法)
11.处理 Memory Warnings
在 AppDelegate 中实现 - [AppDelegate applicationDidReceiveMemoryWarning:] 代理方法。
在 UIViewController 中重载 didReceiveMemoryWarning 方法。
监听 UIApplicationDidReceiveMemoryWarningNotification 通知。
12.复用高开销的对象
14.优化 UITableView
通过正确的设置 reuseIdentifier 来重用 Cell。
尽量减少不必要的透明 View。
尽量避免渐变效果、图片拉伸和离屏渲染。
当不同的行的高度不一样时，尽量缓存它们的高度值。
如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且缓存服务器的 response。
使用 shadowPath 来设置阴影效果。
尽量减少 subview 的数量，对于 subview 较多并且样式多变的 Cell，可以考虑用异步绘制或重写 drawRect。
尽量优化 - [UITableView tableView:cellForRowAtIndexPath:] 方法中的处理逻辑，如果确实要做一些处理，可以考虑做一次，缓存结果。
选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的。
对于 rowHeight、sectionFooterHeight、sectionHeaderHeight 尽量使用常量。
15.选择合适的数据存储方式
在 iOS 中可以用来进行数据持有化的方案包括：
NSUserDefaults。只适合用来存小数据。
XML、JSON、Plist 等文件。JSON 和 XML 文件的差异在「选择正确的数据格式」已经说过了。
使用 NSCoding 来存档。NSCoding 同样是对文件进行读写，所以它也会面临必须加载整个文件才能继续的问题。
使用 SQLite 数据库。可以配合 FMDB 使用。数据的相对文件来说还是好处很多的，比如可以按需取数据、不用暴力查找等等。
使用 CoreData。也是数据库技术，跟 SQLite 的性能差异比较小。但是 CoreData 是一个对象图谱模型，显得更面向对象；SQLite 就是常规的 DBMS。
16.减少应用启动时间
快速启动应用对于用户来说可以留下很好的印象。尤其是第一次使用时。
保证应用快速启动的指导原则：
尽量将启动过程中的处理分拆成各个异步处理流，比如：网络请求、数据库访问、数据解析等等。
避免臃肿的 XIB 文件，因为它们会在你的主线程中进行加载。重申：Storyboard 没这个问题，放心使用。
注意：在测试程序启动性能的时候，最好用与 Xcode 断开连接的设备进行测试。因为 watchdog 在使用 Xcode 进行调试的时候是不会启动的。
17.使用 Autorelease Pool （内存释放池）
18.imageNamed 和 imageWithContentsOfFile，imageName会缓存图片
```



#### 76、NSURLConnection 和NSURLSession 的区别是 么? NSURLProtocol是做什么的?

```
1.下载
NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。
而使用NSURLSessionDownloadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码
2.请求方法的控制
NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。
NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。
使用NSURLSession进行断点下载更加便捷.
NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进
```



#### 77、如果项目开始容错处理没做？如何防止拦截潜在的崩溃？

```
例：

1、category给类添加方法用来替换掉原本存在潜在崩溃的方法。

2、利用runtime方法交换技术，将系统方法替换成类添加的新方法。

3、利用异常的捕获来防止程序的崩溃，并且进行相应的处理。

总结：

1、不要过分相信服务器返回的数据会永远的正确。

2、在对数据处理上，要进行容错处理，进行相应判断之后再处理数据，这是一个良好的编程习惯。

```



#### 78、容错处理你们一般是注意哪些？

```
在团队协作开发当中，由于每个团队成员的水平不一，很难控制代码的质量，保证代码的健壮性，经常会发生由于后台返回异常数据造成app崩溃闪退的情况，为了避免这样的情况项目中做一些容错处理，显得格外重要，极大程度上降低了因为数据容错不到位产生崩溃闪退的概率。

例如：

1.字典

2.数组；

3.野指针；

4.NSNull   @"{\"value\": null}";  这种json解析出来的时候，NSNull如果去执行方法，就会 unrecognized selector

等~

```



#### 79、内存泄漏可能会出现的几种原因，聊聊你的看法？

```
第一种可能：第三方框架不当使用；

第二种可能：block循环引用；

第三种可能：delegate循环引用；

第四种可能：NSTimer循环引用 如 和 VC的循环引用

第五种可能：非OC对象内存处理

第六种可能：地图类处理

第七种可能：大次数循环内存暴涨



追问一：非OC对象如何处理？

非OC对象，其需要手动执行释放操作例：CGImageRelease(ref)，否则会造成大量的内存泄漏导致程序崩溃。

其他的对于CoreFoundation框架下的某些对象或变量需要手动释放、C语言代码中的malloc等需要对应free。

```



#### 80、常用锁有以下几种：

```

1.@synchronized 关键字加锁

2. NSLock 对象锁

3. NSCondition

4. NSConditionLock 条件锁

5. NSRecursiveLock 递归锁

6. pthread_mutex 互斥锁（C语言）

7. dispatch_semaphore 信号量实现加锁（GCD）

8. OSSpinLock

9.pthread_rwlock

10.POSIX Conditions

11.os_unfair_lock

追问一：自旋和互斥对比？

自旋锁和互斥锁

相同点：都能保证同一时间只有一个线程访问共享资源。都能保证线程安全。

不同点：

互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。

自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。

自旋锁的效率高于互斥锁。

使用自旋锁时要注意：

由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪费CPU时间。

持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能导致整个系统挂起。

使用任何锁都需要消耗系统资源（内存资源和CPU时间），这种资源消耗可以分为两类：

1.建立锁所需要的资源

2.当线程被阻塞时所需要的资源

追问二：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！

cpp实现：


两种锁的加锁原理：

互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。

自旋锁：线程一直是running(加锁——>解锁)，死循环检测锁的标志位，机制不复杂。
```



#### 81、优化你是从哪几方面着手

```
一、首页启动速度

启动过程中做的事情越少越好（尽可能将多个接口合并）

不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）

在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）

尽量减小包的大小

优化方法：

量化启动时间

启动速度模块化

辅助工具（友盟，听云，Flurry）

二、页面浏览速度

json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）

数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）

数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）

内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）

延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）

算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）

三、操作流畅度优化：

Tableview 优化（tableview cell的加载优化）

ViewController加载优化（不同view之间的跳转，可以提前准备好数据）

四、数据库的优化：

数据库设计上面的重构

查询语句的优化

分库分表（数据太多的时候，可以分不同的表或者库）

五、服务器端和客户端的交互优化：

客户端尽量减少请求

服务端尽量做多的逻辑处理

服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）

通信协议的优化。（减少报文的大小）

电量使用优化（尽量不要使用后台运行）

```



#### 82、怎么防止别人动态在你程序生成代码？怎么防止反编译？

```
（这题是听错了面试官的意思）

面试官意思是怎么防止别人反编译你的app？

1.本地数据加密

iOS应用防反编译加密技术之一：对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息

2.URL编码加密

iOS应用防反编译加密技术之二：对程序中出现的URL进行编码加密，防止URL被静态分析

3.网络传输数据加密

iOS应用防反编译加密技术之三：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据

4.方法体，方法名高级混淆

iOS应用防反编译加密技术之四：对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码

5.程序结构混排加密

iOS应用防反编译加密技术之五：对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低

```



#### 84、你理解的多线程？

```
1.可能会追问，每种多线程基于什么语言？

2.生命周期是如何管理？

3.你更倾向于哪种？追问至现在常用的两种你的看法是？

第一种：pthread

.特点：

1）一套通用的多线程API

2）适用于Unix\Linux\Windows等系统

3）跨平台\可移植

4）使用难度大

b.使用语言：c语言

c.使用频率：几乎不用

d.线程生命周期：由程序员进行管理

第二种：NSThread

a.特点：

1）使用更加面向对象

2）简单易用，可直接操作线程对象

b.使用语言：OC语言

c.使用频率：偶尔使用

d.线程生命周期：由程序员进行管理

第三种：GCD

a.特点：

1）旨在替代NSThread等线程技术

2）充分利用设备的多核（自动）

b.使用语言：C语言

c.使用频率：经常使用

d.线程生命周期：自动管理

第四种：NSOperation

a.特点：

1）基于GCD（底层是GCD）

2）比GCD多了一些更简单实用的功能

3）使用更加面向对象

b.使用语言：OC语言

c.使用频率：经常使用

d.线程生命周期：自动管理

多线程的原理

同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）

多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）

如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象

思考：如果线程非常非常多，会发生什么情况？

CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源

每条线程被调度执行的频次会降低（线程的执行效率降低）

多线程的优点

能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）

多线程的缺点

开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享

你更倾向于哪一种？

倾向于GCD：

GCD

技术是一个轻量的，底层实现隐藏的神奇技术，我们能够通过GCD和block轻松实现多线程编程，有时候，GCD相比其他系统提供的多线程方法更加有效，当然，有时候GCD不是最佳选择，另一个多线程编程的技术

NSOprationQueue 让我们能够将后台线程以队列方式依序执行，并提供更多操作的入口，这和 GCD 的实现有些类似。

这种类似不是一个巧合，在早期，MacOX

与 iOS 的程序都普遍采用Operation

Queue来进行编写后台线程代码，而之后出现的GCD技术大体是依照前者的原则来实现的，而随着GCD的普及，在iOS 4 与 MacOS X

10.6以后，Operation Queue的底层实现都是用GCD来实现的。

那这两者直接有什么区别呢？

1.    GCD是底层的C语言构成的API，而NSOperationQueue及相关对象是Objc的对象。在GCD中，在队列中执行的是由block构成的任务，这是一个轻量级的数据结构；而Operation作为一个对象，为我们提供了更多的选择；

2.    在NSOperationQueue中，我们可以随时取消已经设定要准备执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停止已经加入queue的block(其实是有的，但需要许多复杂的代码)；

3.    NSOperation能够方便地设置依赖关系，我们可以让一个Operation依赖于另一个Operation，这样的话尽管两个Operation处于同一个并行队列中，但前者会直到后者执行完毕后再执行；

4.    我们能将KVO应用在NSOperation中，可以监听一个Operation是否完成或取消，这样子能比GCD更加有效地掌控我们执行的后台任务；

5.    在NSOperation中，我们能够设置NSOperation的priority优先级，能够使同一个并行队列中的任务区分先后地执行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分block任务的优先级，也需要大量的复杂代码；

6.    我们能够对NSOperation进行继承，在这之上添加成员变量与成员方法，提高整个代码的复用度，这比简单地将block任务排入执行队列更有自由度，能够在其之上添加更多自定制的功能。

总的来说，Operation

queue

提供了更多你在编写多线程程序时需要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代码，为我们提供简单的API入口。从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。但是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的GCD或许是个更好的选择，而Operation

queue 为我们提供能更多的选择。

倾向于：NSOperation

NSOperation相对于GCD：

1，NSOperation拥有更多的函数可用，具体查看api。NSOperationQueue 是在GCD基础上实现的，只不过是GCD更高一层的抽象。

2，在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。

3，NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）

4，GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序（通过调整权重）。NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。

使用NSOperation的情况：各个操作之间有依赖关系、操作需要取消暂停、并发管理、控制操作之间优先级，限制同时能执行的线程数量.让线程在某时刻停止/继续等。

使用GCD的情况：一般的需求很简单的多线程操作，用GCD都可以了，简单高效。

从编程原则来说，一般我们需要尽可能的使用高等级、封装完美的API，在必须时才使用底层API。

当需求简单，简洁的GCD或许是个更好的选择，而Operation queue 为我们提供能更多的选择。
```



#### 85、SD原理以及最大支持多少个下载数？

```
6
```



#### 86、runtime动态创建一个类，需要注意什么？

```

```



#### 87、有一个很长字符串，你用什么算法搜索到abc的位置？

```
1、暴力匹配

2、KMP查找

3、后缀树
```



#### 88、代码文件编译生成过程，编译和链接有什么区别，链接做了什么事情

```
将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言。

由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模型。链接主要解决模块间的相互引用问题。分为地址和空间分配，符号解析和重定位几个步骤。

在编译阶段生成目标文件时，会暂时搁置那些外部引用，而这些外部引用就是在链接时进行确定的，链接器在链接时，会根据符号名称去相应模块中寻找对应符号。待符号确定之后，链接器会重写之前那些未确定的符号的地址，这个过程就是重定位。链接一般分为静态链接、载入时动态链接以及运行时动态链接三种。
```



#### 89、用C语言实现一个通知流程，说思路即可！

```

```



#### 90、A B 线程执行到一半去执行C线程，用OC和C各自怎么实现！

```
wait notify


dispatch_wait

dispatch_notify
```



#### 91、快排的原理

```
选定一个基准数，左右根据基准数进行调控，小的往基准数左边放，小的往右边放，递归执行
```



#### 92、C语言中strlen和sizeof的区别

sizeof是求数据类型所占的空间大小,而strlen是求字符串的长度



#### 93、推送的原理

```
1、 注册：为应用程序申请消息推送服务。此时你的设备会向APNs服务器发送注册请求。
2、 APNs服务器接受请求，并将deviceToken返给你设备上的应用程序
3、客户端应用程序将deviceToken发送给后台服务器程序，后台接收并储存。
4、 后台服务器向APNs服务器发送推送消息
5、 APNs服务器将消息发给deviceToken对应设备上的应用程序

```



https://www.jianshu.com/p/2595dfc5e7cd



#### 94、一个页面可以由几个控制器共同管理吗

```

```



#### 95、项目上线或者版本迭代，有过被拒吗？是什么原因？怎么解决？

```
产品销售权限啊


```



#### 97、tableViewCell的自适应如何实现，如何保证性能

```

```



#### 98、cocoaPods的实现思路，为什么没有使用cocoaPods管理自己的SDK

```

```



#### 99、请说明并比较以下关键词：atomic, nonatomic

```
atomic修饰的对象会保证setter和getter的完整性，任何线程对其访问都可以得到一个完整的初始化后的对象。

因为要保证操作完成，所以速度慢。它比nonatomic安全，但也并不是绝对的线程安全，例如多个线程同时调用set和get就会导致获得的对象值不一样。绝对的线程安全就要用关键词synchronized。

atomic只是get set线程安全，不代表就一定线程安全了

nonatomic修饰的对象不保证setter和getter的完整性，所以多个线程对它进行访问，它可能会返回未初始化的对象。正因为如此，它比atomic快，但也是线程不安全的。
```



#### 100、你平时做过什么有技术难点的东西，然后怎么解决的

```
性能优化

1、启动时间优化： 动态库、启动耗时检测、动态库加载时间检测、优化

启动的时候做了什么，有哪些地方是可以优化的。，动态库链接内存占用

2、FPS优化：App卡顿检测统计、流畅度优化

是哪些原因导致的卡顿，卡顿的可优化区间

CPU coreGraphics绘制耗时
GPU 渲染耗时

image展示优化，UIImageView 加载优化

YYAsyncLayer如何异步绘制？ 原理

3、内存优化、内存的原理，虚拟内存等

3、耗电、发热优化：cpu和gpu使用的平衡

4、Xcode编译优化：xcode编译优化、代码风格优化、pod库自动脚本打成二进制库、

5、打包优化


理一理深层次的优化，系统层面、硬件原理层面

自动回收池原理

图片缓存 decode of images in the background
```



#### 101、聊一聊你之前公司的项目

```
总结你的架构能力 (app整体架构如何)

业务处理能力 (承担哪些责任)

技术使用能力 (用到了哪些技术)
```



#### 102、Swift和OC混编遇到了什么问题

```
1、编译速度问题 5分钟变为 10分钟

2、经常丢失断点、丢失提示、llbd打印信息错误等

这种情况，请仔细检查你的桥接文件：项目名-Bridging-Header，是否导入了第三方库。若导入了第三方库，则该库是否是以Cocoapods来管理的，比如AFNetWorking是通过 Cocoapods 管理的，那么在桥接文件中，你应该

@import AFNetWorking;

而不是 import "AFNetWorking.h"，或者以这种#import导入该三方的其他文件


3、命名空间的问题
```



#### 103、Swift 引入后 编译优化的一些思考

```
1. 尽可能的移除pch中的文件、XX-Swift.h文件千万不要图方便放到pch文件中，不然每次编译都需要全局编译

2. 尽可能的减少Objective-C与Swift的混编，减小bridge文件的大小、通过模块化，实现OC与Swift之间的隔离 通过路由的方式进行模块通信，降低耦合度，路由中间件也可以减少业务中头文件的频繁交叉、繁复引用，降低耦合性

3. 模块头文件引用以@import or import <> 库引用的方式

4. 通过中间件减少业务中头文件的交叉、繁复引用，降低耦合性

5. 通过将第三方库、基础组件二进制化减少编译时间，把很少改动或者基本不会改的库编译成二进制framework

6. 组件化的时候注意组件之间的依赖关系

- 业务组件尽可能不依赖业务组件，如果依赖关系过强，就需要考虑是否业务拆分有问题
- 业务组件只依赖基础组件与第三方库
- 基础组件不依赖业务组件
- 基础组件尽量不依赖基础组件 

```



#### 104、项目优化的一些思考

```
项目的优化分为编译优化 和 运行优化

编译优化指的是 优化方向是优化我们的开发过程，例如编译速度，代码效率，迭代效率，扩展性等

运行优化指的是 优化方向是app的运行，例如，列表流畅度、交互体验、网络延时等等


编译优化：

Swift编译速度慢的原因：

1、本身方法实现耗时太多：在xcode中开启编译时长检查，方法编译时间超出设置值就会有黄色警告

2、过多的编译器类型检查：例如过多的optation 类型

3、头文件的引用问题，尽可能的移除pch中的文件、XX-Swift.h文件千万不要图方便放到pch文件中，不然每次编译都需要全局编译

4、swift工程引用OC pod库  不需要通过桥文件 直接import对应的库名称，也尽量少在bridge文件中对OC库的头文件进行引用，影响Xcode编译效率,同时会导致lldb调试问题和断点问题

5、 


pod库太多：把一些稳定的 不需要变更的库，打成二进制包




懒加载的使用
```



#### 105、iOS系统框架介绍

![](https://xilankong.github.io/resource/cocoa.png)



#### 107、如何拦截AFNetworking，我希望在请求发出去之前添加一些头部信息

```
runtime覆盖request方法，但是很蠢
```



#### 108、日志上报，错误日志上报，业界有哪些方法 案例

```
exception catch

信号异常 catch
```



#### 109、一个app进入后台之后如何唤起

```
app没死可以通过通知

app已死可以通过VoIP
```



#### 110、如果没有API 没有百度，你要怎么解决一个问题，有实际处理过类似情况么，比如把一个1M的文件尽可能的压缩

```
压缩的原理是什么

分析要做的事情原理，回归事物本质
```



#### 110、100个随机数字，想要找到最大值，时间复杂度是？

```
O(n)
```



111、数据库都有哪些类型



#### 112、iOS虚拟内存的使用

```
当我们向系统申请内存时，系统并不会直接返回物理内存的地址，而是**返回一个虚拟内存地址**。从系统角度来说，每一个进程都有相同大小的虚拟内存空间。
只有当进程开始使用申请到的虚拟内存时，系统才会将虚拟地址映射到物理地址上，从而让程序使用真实的物理内存。
```



#### 113、OC 与 JS的交互  JockeyJS这一套的逻辑

```
JS是如何捕获OC的协议的




```



#### 114、swift 和 OC 都是动态强类型语言

```
静态类型语言：是一种编译器无法自动检测类型的语言。 java

动态类型语言：是一种编译器能够自动检测类型的语言。

强类型语言：强类型语言也称为强类型定义语言。是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。

弱类型语言：弱类型语言也称为弱类型定义语言。与强类型定义相反。像vb，php，js等就属于弱类型语言。
```



#### 115、什么是ABI？

```
应用程序二进制接口，应用程序与操作系统之间，一个应用和它的库之间或者应用的组成部分之间的低接口。

API 表示的是源代码和库之间的接口，ABI允许编译好的目标代码在使用人ABI的系统中无需改动就能运行
```



#### 116、REST、HTTP、JSON是什么？

RESTful api     Representational State Transfer  资源表现层状态转化架构

```
（1）每一个URI代表一种资源；
（2）客户端和服务器之间，传递这种资源的某种表现层；
（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。
```



#### 117、delegate解决了什么问题，Notification与它有什么不同？

```
delegate  一对一的通信原理，完成消息回调

Notification 是一对多，与对象之间无需建立直接关系
```



#### 118、LLVM与Clang的区别？

```
Clang 是编译器前端

Clang 的作用是 语法、语义分析器，生成中间代码

LLVM是编译器后端

LLVM的作用是代码优化器和后端生成目标程序

从宏观上来说，LLVM包含了Clang
```



#### 119、Class、objc的区别是什么？

```
objc为实例对象，表示的是通过类构建的一个实例本身，实例对象是一个objc_object 类型的结构体，包含一个 Class类型的isa属性 用于表明其所属的类

Class为类对象，表示的是类本身
```



#### 120、不通过继承，代码复用（共享）的方式有哪些

```
protocol 协议

extension 扩展 

runtime
```



#### 121、编译选项 whole module optmization 优化了什么

```
编译器对你的代码进行分析的时候，再也不会局限于一个文件当中了，而是整个module。有什么用呢，有了这一特性，编译器可以对你的代码了解得更多，能更好的做好编译工作。
```



#### 122、在一个app中间有一个button，在你手触摸屏幕点击后，到这个button收到点击事件，中间发生了什么

```
响应链大概有以下几个步骤

1. 设备将touch到的UITouch和UIEvent对象打包, 放到当前活动的Application的事件队列中
2. 单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow
3. UIWindow使用hitTest:withEvent:方法查找touch操作的所在的视图view

RunLoop这边：

1. 主线程的RunLoop被唤醒
2. 通知Observer，处理Timer和Source 0
3. Springboard接受touch event之后转给App进程中
4. RunLoop处理Source 1，Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。
5. RunLoop处理完毕进入睡眠，此前会释放旧的autorelease pool并新建一个autorelease pool

```



### 123、main()之前的过程有哪些？

1、系统先读取App的可执行文件（Mach-O文件），获取到dyld的路径，并加载dyld（动态库链接程序）。

2、dyld去初始化运行环境、开启缓存策略（冷热启动）、加载依赖库（读取文件、验证、注册到系统核心）、我们的可执行文件、链接依赖库，并调用每个依赖库的初始化方法。

3、在上一步runtime被初始化，当所有的依赖库初始化后，程序可执行文件进行初始化，这个时候runtime会对项目中的所有类进行类结构初始化，然后调用所有类的+load方法。

```
1、runtime初始化方法 _objc_init 中最后注册了两个通知：

map_images： 主要是在镜像加载进内容后对其二进制内容进行解析，初始化里面的类结构等

load_images： 主要是调用call_load_methods 按照继承层次依次调用Class的 +load方法 然后是Category的+ load方法。(call_load_methods 调用load 是通过方法地址直接调用的load方法，并不是通过消息机制，这就是为什么分类中的load方法并不会覆盖主类以及其他同主类的分类里的load 方法实现了。)

2、runtime 调用项目中所有的load方法时，所有的类的结构已经初始化了,此时在load方法中可以使用任何类创建实例并给他们发送消息。
```

4、最后dyld返回main函数地址，main函数被调用。dyld会缓存上一次把信息加载内存的缓存，所以第二次比第一次启动快一点





#### 124、block为什么防止引用循环为什么要外部weak 内部 strong

```
因为block截获self之后self属于block结构体中的一个由__strong修饰的属性会强引用self， 所以需要使用__weak修饰的weakSelf防止循环引用。
block使用的__strong修饰的weakSelf是为了在block（可以理解为函数）生命周期中self不会提前释放。strongSelf实质是一个局部变量（在block这个“函数”里面的局部变量），当block执行完毕就会释放自动变量strongSelf，不会对self进行一直进行强引用。
```



#### 125、iOS 中内省的几个方法？class方法和objc_getClass方法有什么区别?

```

内省方法
判断对象类型:
-(BOOL) isKindOfClass: 判断是否是这个类或者这个类的子类的实例
-(BOOL) isMemberOfClass: 判断是否是这个类的实例
判断对象or类是否有这个方法
-(BOOL) respondsToSelector: 判读实例是否有这样方法
+(BOOL) instancesRespondToSelector: 判断类是否有这个方法

object_getClass(obj)返回的是obj中的isa指针；而[obj class]则分两种情况：一是当obj为实例对象时，[obj  class]中class是实例方法：- (Class)class，返回的obj对象中的isa指针；二是当obj为类对象（包括元类和根类以及根元类）时，调用的是类方法：+ (Class)class，返回的结果为其本身。

```



#### 126、在运行时创建类的方法`objc_allocateClassPair`的方法名尾部为什么是pair（成对的意思）？

```
另一半就是meta-class
```



#### 127、一个int变量被`__block`修饰与否的区别？

```
没有修饰，被block捕获，是值拷贝。
使用__block修饰,会生成一个结构体，复制int的引用地址。达到修改数据。
```

#### 128、AutoreleasePoolPage 结构体

```
AutoreleasePoolPage 是Autoreleasepool的实现方式，双向链表

```



#### 129、如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？

```
前面我们已经领教了KVO的实现，那如何取消系统的自动KVO呢

实现NSObject的方法，过滤我们需要过滤的key
+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {
    if ([key isEqualToString:@"name"]) {
        return NO;
    }
    return [super automaticallyNotifiesObserversForKey:key];
}

实现自己的KVO逻辑
- (void)setName:(NSString *)name {
    [self willChangeValueForKey:@"name"];
    _name = name;
    [self didChangeValueForKey:@"name"];
}
```

#### 130、什么是中间人攻击

```
攻击者在请求和响应传输途中，拦截并篡改内容。

SSL 证书欺骗攻击流程大概如下：

截获客户端与服务器通信的通道
然后在 SSL 建立连接的时候，进行中间人攻击
将自己伪装成客户端，获取到服务器真实有效的 CA 证书（非对称加密的公钥）
将自己伪装成服务器，获取到客服端的之后通信的密钥（对称加密的密钥）
有了证书和密钥就可以监听之后通信的内容了

```

#### 131、如何用Charles抓HTTPS的包？

```
前面说过，HTTPS 可以有效防止中间人攻击，那 Charles 是如何抓取 HTTPS 包的呢？

Charles 作为一个“中间人代理”，当浏览器和服务器通信时，Charles接收服务器的证书，但动态生成一张证书发送给浏览器，也就是说Charles作为中间代理在浏览器和服务器之间通信，所以通信的数据可以被Charles拦截并解密。由于Charles更改了证书，浏览器校验不通过会给出安全警告，必须安装Charles的证书后才能进行正常访问。

这里有个大前提，就是客户端信任了 Charles 自己制作的证书，然后导致 Charles 拿到 CA 证书和对称加密的公开密钥；这里我们简单总结下：

1、首先 Charles 假冒了客户端，拿到服务器的 CA 证书

2、然后 Charles 假冒了服务器，给客户端发送了一张自己制作的证书，客户端信任该证书

3、Charles 再次假冒服务器，拿到客户端的对称密钥

4、Charles 再次假冒客户端，将对称密钥加密发送给服务器，让服务器认为这次通信是没问题的，服务器发送成功响应

5、最后 Charles 假冒服务器将成功响应发给客户端

```

132、App 网络层有哪些优化策略？

```

```

133、了解内联函数么？

```
OC中使用inline，主要是为了提高函数调用的效率
使用例子：
static inline NSString * imageURLKeyForState(UIControlState state) {
    return [NSString stringWithFormat:@"image_%lu", (unsigned long)state];
}


我们通常会发现，inline 会有 static来修饰，表示在当前文件中应用,如 static b, 在其它文件中也可以出现static b.不会导致重名的错误.
inline和函数
1.inline函数避免了普通函数的,在汇编时必须调用call的缺点:取消了函数的参数压栈，减少了调用的开销,提高效率.所以执行速度确比一般函数的执行速度要快.
2.集成了宏的优点,使用时直接用代码替换(像宏一样)
inline和宏
1.避免了宏的缺点:需要预编译.因为inline内联函数也是函数,不需要预编译.
2.编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
3.可以使用所在类的保护成员及私有成员。
inline 说明
1.内联函数只是我们向编译器提供的申请,编译器不一定采取inline形式调用函数.
2.内联函数不能承载大量的代码.如果内联函数的函数体过大,编译器会自动放弃内联.
3.内联函数内不允许使用循环语句或开关语句
4.内联函数的定义须在调用之前。
```



134、列举你知道的线程同步策略？

```
wait notify 、synchronized代码块
```

135、iOS SDK中的那些设计模式的使用

```

KVO 观察者模式

单例模式 NSFileManager 、 UIApplication

代理委托模式：UITableViewDelegate

适配器模式：类似中间件的构建，当接入SDK的时候，适配器模式可以起到隔离并适配的作用

装饰模式： 比如 category

抽象工厂模式：让外部无需知道工厂内部的任何变动

```

136、面向对象的设计原则

面向对象设计的六个设计原则：

| 缩写 | 英文名称                                      | 中文名称                   |
| ---- | --------------------------------------------- | -------------------------- |
| SRP  | Single Responsibility Principle               | 单一职责原则               |
| OCP  | Open Close Principle                          | 开闭原则                   |
| LSP  | Liskov Substitution Principle                 | 里氏替换原则               |
| LoD  | Law of Demeter （ Least Knowledge Principle） | 迪米特法则（最少知道原则） |
| ISP  | Interface Segregation Principle               | 接口分离原则               |
| DIP  | Dependency Inversion Principle                | 依赖倒置原则               |

通常所说的`SOLID`（上方表格缩写的首字母，从上到下）设计原则没有包含本篇介绍的迪米特法则



137、链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？

```
数组是一段连续的内存地址，链表是无序的，根据指针来指向下一个内存地址

数组查询指定位置的元素很方便，但是插入和删除需要移动，不如链表方便，查找O(1) 添加删除 O(n)

链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难； 查找O(n), 添加删除O(1)
```

138、哈希表是如何实现的？如何解决地址冲突？

```
散列表（Hash table，也叫哈希表），是根据关键码值(Key-Value)而直接进行访问的数据结构。


通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。查询时间复杂度O(1)


地址冲突处理：

地址冲突是什么？ 
实际上是由数组和链表的方式组合实现的。我们哈希出来的key会放置在数组的某个位置，这个时候如果有其他元素哈希结果也是这个位置的时候，且两个key并不一样。这就是地址冲突。

1、再哈希，重新进行一次全部的哈希，常见于需要扩容的时候，翻倍扩容并重新哈希

2、当key相同的时候，会再数组后面链接一个链表并把值存入

```



139、RAC的运用

```

```



140、



141、NSCache 和 NSDictionary

```
如何选择存缓存数据结构

当系统资源将要耗尽时，它可以自动删减缓存。
NSCache还会先行删减“最久未使用的”(lease recently used)对象。
NSCache 并不会“拷贝”键，而是会“保留”它。NSCache对象不拷贝键的原因在于：很多时候，键都是有不支持拷贝操作的对象来充当的。因此，NSCache 不会自动拷贝键，所以说，在健不支持拷贝操作的情况下，该类用起来比字典更方便。
NSCache是线程安全的。而NSDictionary则绝不具备此优势，意思就是：在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache.

```

142、iOS图片内存占用由什么决定

```
图片显示占用内存大小 = 图片的宽度 乘以 图片的高度 乘以 颜色 RGBA 占用的4个字节;

还有色域等会影响
```

143、索引的作用、索引的优缺点

```
作用优点

因为索引可以大大提高的性能。

第1通过唯一性索引可以保证数据库表中每一行数据的唯一性。

第2可以大大加快数据的检索速度。这也是创建索引最主要的原因。

缺点

第1 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

第2 实际上索引也是一张表，该表保存了主键与索引字段.索引需要占物理空间，
```

144、NSMutableArray的实现原理

https://www.jianshu.com/p/3c77756a86ab

```
__NSArrayM 用了环形缓冲区 (circular buffer)。这个数据结构相当简单，只是比常规数组或缓冲区复杂点。环形缓冲区的内容能在到达任意一端时绕向另一端。环形缓冲区有一些非常酷的属性。尤其是，除非缓冲区满了，否则在任意一端插入或删除均不会要求移动任何内存。

__NSArrayM 从不减少它的缓冲区大小
```

145、编译链接

```
预处理、编译（词法分析、语法分析、静态分析、中间代码生成）、汇编、链接(生成 Executable 可执行文件)
```

146、NSProxy & NSObject

```
NSProxy是一个虚类，实现了NSObject协议，可以用于处理weakProxy问题
```



 大数字符串相加

 合并链表

整数数组的最大子数组

反转数组、 旋转数组

非递归二叉树

 快速排序

 反转二叉树

 Block怎么hook



block的实现原理  https://blog.csdn.net/abc649395594/article/details/47086751

block本身是一个结构体  



 block会编译成 _blockImpl 结构体 ，有对应的指针指向block的实现 func  __blockImpl 结构体会构造一个参数来承接需要截获的变量，所以一般基础类型变量，已经完全不是外部的的那个变量了

如果加了__block 修饰，会把变量封装在一个结构体中，结构体中保存了一个指针变量指向外部定义的变量，所以这个时候操作这个指针，是可以影响到原来变量的。











 fishHook原理

 Oc和Swift的消息派发的差异

动态派发都是一样的，注意 动态派发是不支持值类型的



4种派发机制，而不是两种(静态和动态):

1. 内联(inline) (最快)    内联是指在编译期把每一处方法调用替换为直接执行方法内部的代码，可以帮助你避免运行时方法调用的时间开销。
2. 静态派发 (Static Dispatch)
3. 函数表派发 (Virtual Dispatch)
4. 动态派发 (Dynamic Dispatch)(最慢)



OC默认支持动态派发，多态的形式为开发人员提供灵活性，例如重写，但是同样动态的查找需要运行时的开销

消息派发，KVO，runtime方法查找



swift 要通过 @objc 、 dynamic 桥接OC 的runtime，间接实现，可以通过SIL中间文件判断派发方式

Swift 中的动态派发和 OC 中的动态派发类似，在运行时程序会根据被调用的方法的名字去内存中的方法表中查表，找到方法的实现并执行。



swift的静态派发

要求方法内部代码对编译器透明，运行时不允许更改，这样编译器才可以保证我们运行的时候不需要查表可以直接跳转到方法代码执行。值类型满足静态派发的要求





 内存碎片、 内存对齐

内存碎片产生的原因：

内部碎片：当一个进程不能完全使用分给他的固定内存区域时产生内存碎片

比如多次内存分配后释放了 2  + 1 内存，但是两个内存块不连续，所以你没法申请一个 3 的内存



处理方案，内存页，比如：每两个连续内存组成一个内存页，进程申请的最小单位为页面 多页面一起申请组合使用，但是问题就是内存页会存在资源浪费



外部碎片：某些未分配的连续内存区域太小，不能满足进程的内存分配需求而不能被利用的内存区域





 Crash符号怎么查询，定位

https://blog.csdn.net/u010960265/article/details/82454436

#### 常见的Crash 原因

1. KVO问题
2. NSNotification线程问题
3. 数组越界
4. 野指针
5. 后台任务超时
6. 内存爆出
7. 主线程卡顿超阀值
8. 死锁



Signal 分析

SIGTRAP







 C++虚函数

 A，B并发执行，然后都执行完，C再执行







 死锁条件、 都有哪些锁、 读写锁适用于什么情况



 缓存淘汰算法、FIFO  LRU(最近最少使用，最近一段时间最少被访问的数据淘汰掉)   LFU(最不经常使用、基于最近访问频率来进行淘汰)   都适用于什么情况

LRU  这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。

LFU   最不经常使用、基于最近访问频率来进行淘汰

命中率高一些



 iOS渲染机制

render server

https://blog.csdn.net/u011342466/article/details/50918035





卡顿原理



 动画中的presationLayer



iOS   IPC  https://segmentfault.com/a/1190000002400329







 Swift的static与class区别



 layer的抛锚点



互斥量、信号量



 ARC都有哪些优化



weak原理，具体到函数



 比如class_ro_t与class_rw_t的区别

```
struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags

    class_rw_t *data() const {
        return bits.data();
    }
    
    
类结构中包含了class_data_bits_t结构，这个结构实际上上是由一个指针(class_rw_t *)和一些关于类初始化状态的的标识组成


而class_rw_t结构中又包含了一个const class_ro_t *类型的指针实现

对比变量定义发现，class_ro_t结构中与class_rw_t对应的的主要成员变量都使用了base做区分,说明class_ro_t的结构更加贴近类本身的结构,class_rw_t像是类拓展出来的.


在关于类的实现中,几乎所有引用到class_ro_t变量的地方都是使用了const关键字做修饰,更像是一个静态不愿意被外界修改的属性;而引用到class_rw_t变量就没有这样的限制.

所以可以理解为class_ro_t存储的是类在编译期就已经确定的特性,而class_rw_t则是提供在运行时进行类延展的能力.






```



- [Category的实现原理](https://www.jianshu.com/p/fa66c8be42a2)，以及Category为什么只能加方法不能加成员变量。

```
struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
    
    protocol_list_t *protocolsForMeta(bool isMeta) {
        if (isMeta) return nullptr;
        else return protocols;
    }
};
```

分类的结构体中没有成员变量，所以分类是不允许添加成员变量的。分类中添加的属性，并不会生成成员变量，只会有get set 方法声明，需要自己实现。 Category可以添加属性，编译并不会报错，但是并不会自动生成成员变量及set/get方法。

成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。

- 分类的方法，协议，属性等是存放在categroy结构体里面的，那么他又是如何存储在类对象中的呢？

分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。（runtime方法 attachLists   memmove，memcpy）

分类的对象方法存储在哪？ 类方法呢？

**分类中的对象方法依然是存储在类对象中的，同本类对象方法在同一个地方，调用步骤也同调用对象方法一样。如果是类方法的话，也同样是存储在元类对象中。**

```
rw->methods.attachLists(mlists, mcount),
rw->properties.attachLists(proplists, propcount),
rw->protocols.attachLists(protolists, protocount),
```



- 分类中load方法不会覆盖本类的load方法，load方法是直接方法地址调用，没有通过消息机制，本类更早调用：

> call_load_methods   里面在进行的  call_class_loads()  然后再是 call_category_loads()  
>
> (*load_method)(cls, **@selector**(load)); 就是使用指针方式直接调用load方法，不走 objc_msgSend方法

分类和本类都实现load方法，都会调用，但是本类更早。当子类没有实现load方法时，不会去调用父类的load方法。

- 多个分类时方法调用顺序，按编译顺序，最后编译的最先调用。

initialize就是如此，分类的initialize方法会覆盖本类的initialize方法

父类的initialize方法比子类先执行，子类没有实现initialize方法时，会调用父类的initialize方法；放子类实现initialize方法时会覆盖父类的initialize方法。

分类方法是运行时期间拷贝到类对象方法列表，isa指针找到方法列表先找到的就是分类的方法。所以分类会覆盖本类的方法。

```
load 源码调用路径

_objc_init   初始化

load_images

prepare_load_methods
- schedule_class_load
- add_class_load
- add_category_to_loadable_list

call_load_methods
- call_class_loads
- call_category_loads

(*load_method)(cls, **@selector**(load)); 
```



````
initialize 源码调用路径

objc-msg-arm64.s
objc_msgSend

objc-runtime-new.mm
class_getInstanceMethod
lookUpImpOrNil
lookUpImpOrForward
_class_initialize
callInitialize
objc_msgSend(cls,SEL_initialize)
````

-

class结构体：

```
struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */
```

分类的信息最后是添加到本类信息的前面的.**所以如果分类中有和本类相同的方法,会优先调用分类的方法实现**







拷贝分类方法到类对象，相同的方法怎么办





 OC向一个nil对象发送消息

objc_msgSend  第一个参数数self

```dart
objc_msgSend(id self, SEL op, ...)
  
会有指令直接判断测试  self是否为空
  
如果传递给 objc_msgSend 的 self 参数是 nil，该函数不会执行有意义的操作，直接返回。
  
```

















## Swift部分



#### 1.什么是函数式编程？

```
函数式编程其实是一种编程思想, 代码写出来只是它的表现形式

在面向对象的编程思想中, 我们将要解决的一个个问题, 抽象成一个个类, 通过给类定义属性和方法, 让类帮助我们解决需要处理的问题.(其实面向对象也叫命令式编程, 就像给对象下一个个命令)

而在函数式编程中, 我们则通过函数描述我们要解决的问题, 以及解决问题需要怎样的方案.

RxSwift
```



#### 2.swift相对于OC有哪些优点？

```
1、swift语法简单易读、代码更少，更加清晰、易于维护

2、更加安全，optional的使用更加考验程序员对代码安全的掌控

3、泛型、结构体、枚举都很强大

4、函数为一等公民，便捷的函数式编程

5、有命名空间 基于module

6、类型判断

缺点：

app体积变大 更多地动态库 swift扩展库 swift support files，新版本swiftSupport已被移到系统中

oc的优点、运行时
```



#### 3.什么是泛型,swift在哪些地方使用了泛型？

```
泛型（generic）可以使我们在程序代码中定义一些可变的部分，在运行的时候指定。使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能。

例如 optional 中的 map、flatMap 、?? (泛型加逃逸闭包的方式，做三目运算)
```



#### 4.defer、guard的作用？

```
defer 包体中的内容一定会在离开作用域的时候执行

guard 过滤器，拦截器

```



#### 5.swift语法糖 ？！的本质（实现原理）

```
？ 为optional的语法糖

Optional< T > 是一个包含了 nil 和 普通类型的枚举，确保使用者在变量为nil的情况下的处理

!  为optional 强制解包 的语法糖
```



#### 6.举例swift中模式匹配的作用？

```
模式匹配： 在switch中体现最明显

通配符模式： _

标识符模式：let i = 1

值绑定模式：case .Student(let name) 或者 case let .Student(name)

元祖模式：case (let code, _)

可选模式：if case let x？ = someOptional { }

类型转换模式：case is Int:  或者  case let n as String:

表达式模式：范围匹配 case (0..<2)  case(0...2, 2...4)

条件句中使用where： case (let age) where age > 30

if case let：if case let .Student(name) = xiaoming { }

for case let： for case let x in array where x > 10 {}  或者 for x in array where x > 10
```



#### 7.swift中closure与OC中block的区别？

```
1、closure是匿名函数、block是一个结构体对象

2、都能捕获变量

3、closure通过逃逸闭包来在block内部修改变量，block 通过 __block 修饰符
```



#### 8.什么是capture list，举例说明用处？

```
捕获列表

weak  unowned
```



#### 9.swift中private与fileprivate的区别？

```
private的作用域被约束与被定义的当前类作用域，fileprivate作用域是整个文件
```



#### 10.Set 独有的方法有哪些？

```
intersect（_:）// 根据两个集合中都包含的值创建的一个新的集合
exclusiveOr(_:) // 根据只在一个集合中但不在两个集合中的值创建一个新的集合
union(_:) // 根据两个集合的值创建一个新的集合
subtract(_:) //根据不在该集合中的值创建一个新的集合

isSubsetOf(_:) //判断一个集合中的值是否也被包含在另外一个集合中
isSupersetOf(_:) //判断一个集合中包含的值是否含有另一个集合中所有的值
isStrictSubsetOf(:) isStrictSupersetOf(:) //判断一个集合是否是另外一个集合的子集合或者父集合并且和特定集合不相等
isDisjointWith(_:) //判断两个集合是否不含有相同的值
```



#### 11.实现一个 min 函数，返回两个元素较小的元素

```
func minNum<T: Comparable>(a: T, b: T) -> T {
    return a > b ? a : b
}
```



#### 12.map、filter、reduce 的作用

```
1、map 是Array类的一个方法，我们可以使用它来对数组的每个元素进行转换
let intArray = [1, 3, 5]
let stringArr = intArray.map {
            return "\($0)"
        }
// ["1", "3", "5"]

2、filter 用于选择数组元素中满足某种条件的元素
let filterArr = intArray.filter {
    return $0 > 1
}
//[3, 5]

3、reduce 把数组元素组合计算为一个值
let result = intArray.reduce(0) {
    return $0 + $1
}
//9
```



#### 13.map 与 flatmap 的区别

```
1、map 可以对一个集合类型的所有元素做一个映射操作


2、和map 不同，flatmap 在之前版本有两个定义，分别是：
func flatMap(transform: (Self.Generator.Element) throws -> T?) -> [T]
func flatMap(transform: (Self.Generator.Element) -> S) -> [S.Generator.Element]

swift 4.1 废弃后改为

func flatMap(transform: (Self.Generator.Element) throws -> Sequence) -> [Sequence.Element]
func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U?


1) flatMap的第一个作用和map一样，对一个集合类型的所有元素做一个映射操作,但是可以过滤为nil的情况

例如：
let array = [1,2,5,6,7,nil]
let array_map = array.map { $0 }
//[Optional(1), Optional(2), Optional(5), Optional(6), Optional(7), nil]
let array_flatmap = array_map.flatMap { $0 }
//[1, 2, 5, 6, 7]


2) 第二种情况可以进行“降维”操作

let array = [["1", "2"],["3", "4"]]
let array_map = array.map { $0 }
//[["1", "2"], ["3", "4"]]
let array_flatmap = array_map.flatMap { $0 }
//["1", "2", "3", "4"]
```



#### 14.什么是 copy on write

```
copy on write, 写时复制，简称COW，它通过浅拷贝(shallow copy)只复制引用而避免复制值；当的确需要进行写入操作时，首先进行值拷贝，在对拷贝后的值执行写入操作，这样减少了无谓的复制耗时。
```



#### 15.如何获取当前代码的函数名和行号

```
#function
#line
#file
#column
```



#### 16.如何声明一个只能被类 conform 的 protocol

```
protocol：class
```



#### 17.String 与 NSString 的关系与区别

```
两者可以随意转换

String为值类型，拷贝赋值需要值拷贝

NSString 传递指针
```



#### 20.如何截取 String 的某段字符串

```
substring 已废弃

let star = str.index(str.startIndex, offsetBy: 0)

let end = str.index(str.startIndex, offsetBy: 4)

let substr = str[star..<end]
```



#### 21.throws 和 rethrows 的用法与作用

```
当闭包参数会抛出异常时 使用throws

同时外部方法体返回结果需要  rethrows 异常

rethrows 可以用 throws 替换, 反过来不行
```



#### 22.try？ 和 try！是什么意思

```
不处理错误，抛出异常函数时, 如果函数抛出异常, 则返回 nil, 否则返回函数返回值的可选值,


保证不会出现错误 强制解，抛出异常的时候崩溃, 否则则返会函数返回值
```



#### 23.associatedtype 的作用

```
关联类型，关联类型为协议中的某个类型提供了一个别名，其代表的真实类型在实现者中定义


//协议，使用关联类型
protocol TableViewCell {
    associatedtype T
    func updateCell(_ data: T)
}
 
//遵守TableViewCell
class MyTableViewCell: UITableViewCell, TableViewCell {
    typealias T = Model
    func updateCell(_ data: Model) {
        // do something ...
    }
}
```



#### 24.public 和 open 的区别

```
是否可以外部继承
```



#### 25.声明一个只有一个参数没有返回值闭包的别名

```
typealias MyBlock = (Int) -> (Void)
```



#### 26.Self 的使用场景

```
例如：协议定义的时候，如果需要使用到实现者的上下文怎么办？ 我们并不知道谁会实现自己

这个时候可以使用Self进行指代
```



#### 27.dynamic 的作用

```
swift中的函数是静态调用，静态调用的方式会更快，但是静态调用的时候没救不能从字符串查找到对于的方法地址，这样 与OC交互的时候，OC动态查找方法就会找不到，这个时候就可以通过使用 dynamic 标记来告诉编译器，这个方法要被动态调用的

swift中如果KVO监听属性，那么属性就需要 dynamic 来标记

```



#### 28.什么时候使用 @objc

```
与OC 的交互部分

KOV 监听、动态方法查找等都需要

协议可选方法等
```



#### 29.Optional（可选型） 是用什么实现的

```
枚举 一个 为nil，一个为属性值
```



#### 30.如何自定义下标获取

```
extension Demo {
   subscript(index: Int) -> Int {
      get {
        // 返回一个适当的 Int 类型的值
      }
      set(newValue) {
        // 执行适当的赋值操作
      }
	}
}
```



#### 31.inout 的作用

```
让输入参数可变 类似__block 的作用
```



#### 32.Error 如果要兼容 NSError 需要做什么操作

```
Error是一个协议, swift中的Error 都是enum， 可以转 NSError

如果需要Error有NSError的功能，实现 LocalizedError CustomNSError 协议
```



#### 33.下面的代码都用了哪些语法糖

```
[1, 2, 3].map{ $0 * 2 }

array语法糖

尾部闭包语法糖

$0
```



#### 34.什么是高阶函数

```
map、flatMap、filter、reduce？
```



#### 35.下面的代码会不会崩溃，说出原因

```
var mutableArray = [1,2,3]
for _ in mutableArray {
    mutableArray.removeLast()
}

不会，值类型
```



#### 36.给集合中元素是字符串的类型增加一个扩展方法，应该怎么声明

```
extension Array where Element == String { }
```



#### 37.定义静态方法时关键字 static 和 class 有什么区别

```
非class类型 一般 统一用 static  例如  枚举 结构体

protocol中 使用 static ,实现协议的 枚举 结构体 用 static

class 中使用  class static 都可以
```



#### 38.一个 Sequence 的索引是不是一定从 0 开始？

```
不是。
ArraySlice是Sequence的子类，ArraySlice就不是
```



#### 39.数组都实现了哪些协议

```
Decodable Encodable Equatable Hashable  CustomStringConvertible, CustomDebugStringConvertible RandomAccessCollection, MutableCollection RangeReplaceableCollection CustomReflectable ExpressibleByArrayLiteral
```



#### 40.如何自定义模式匹配

```
infix operator =~

func =~ (str: String, pattern: String) -> Bool {
    
}

infix、  prefix、  postfix  用于自定义表达式的声明， 分别表示 中缀、前缀、后缀  
```



#### 41.autoclosure 的作用

```
自动闭包，将参数自动封装为闭包参数
```



#### 42.下面代码中 mutating 的作用是什么

```
struct Person {

    var name: String {
        mutating get {
            return store
        }
    }
}

结构体中的 属性可能发生改变
```

#### 43.如何让自定义对象支持字面量初始化

```
ExpressibleByArrayLiteral


ExpressibleByStringLiteral
```



#### 44.为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃。

```
struct Array<Element> {
    subscript(index: Int) -> Element
}

struct Dictionary<Key: Hashable, Value> {
    subscript(key: Key) -> Value?
}

字典是无序的，数组是有序的，所以字典查询做的 键值对查询返回的是一个可选值
```



#### 45.一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。

```
Int、Float 都有一个协议

func myMethod<T>(_ value: T) where T: Numeric {
    print(value + 1)
} 

或者 ExpressibleByIntegerLiteral 协议也行
```



#### 46.Swift的静态派发

```
很显然静态派发是一种更高效的方法，因为静态派发免去了查表操作。

不过静态派发是有条件的，方法内部的代码必须对编译器透明，并且在运行时不能被更改，这样编译器才能帮助我们。

Swift 中的值类型不能被继承，也就是说值类型的方法实现不能被修改或者被复写，因此值类型的方法满足静态派发的要求。

默认静态派发，如果需要满足动态派发，需要 dynamic修饰


动态派发 

在运行时程序会根据被调用的方法的名字去内存中的方法表中查表，找到方法的实现并执行

OC中的消息机制就是动态派发
```



#### 47.Swift有哪些修饰符

```
open、public 、internal、fileprivate、private
```



#### 48、实现一个函数，输入是任一整数，输出要返回输入的整数 + 2

```
func plusTwo(one: Int) -> (Int) -> Int {
    return { (two: Int) in return two + one }
}

plusTwo(one: 4)(2)
```



#### 49、Swift 到底是面向对象还是函数式的编程语言？

```
Swift 既是面向对象的，又是函数式的编程语言。
说 Swift 是 Object-oriented，是因为 Swift 支持类的封装、继承、和多态，从这点上来看与 Java 这类纯面向对象的语言几乎毫无差别。
说 Swift 是函数式编程语言，是因为 Swift 支持 map, reduce, filter, flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。

```



#### 50、class 和 struct 的区别

```
class 引用类型，可以继承、多态，通过引用计数来管理

struct 是值类型，不通过引用计数来管理
```



