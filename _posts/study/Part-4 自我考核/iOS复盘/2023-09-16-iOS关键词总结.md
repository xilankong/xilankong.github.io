---
0layout: post
category: iOS学习总结
title : "iOS关键词总结"
tags: iOS
---

> 如果你不知道你接下来需要补充学习哪一部分知识，梳理一下自己认识的关键词吧。




#### 一、App启动

1、启动种类
```
- 热启动
- 冷启动
- 后台回前台
- 预热（iOS 15）


一般启动度量都用冷启动的耗时，premain + postmain的方式



```

2、启动流程
```

- 细分从点击AppIcon到App启动：

1、 SpringBoad复制进程，loadMachine加载Mach-o(parse_machfile)

2、进行__TEXT，__DATA的映射，加载UUID，创建主线程，代码签名验证

3、加载动态链器（dyld2、dyld3（iOS13）、dyld4（iOS16））

3、dyld 加载过程的三个阶段（system interface -> Runtime Initializer -> main）

4、main后阶段

```

3、dyld流程 

```
第一阶段：system interface

1- 设置环境变量

2- loadDyldCache 共享库缓存
    比如UIKit等系统动态库 都是通过dyld从共享缓存载入

3- 实例化主程序 instantiateFromLoadedImage
    加载可执行文件并生成一个ImageLoader实例对象（读取可执行文件头信息 ）

4- 加载插入的动态库 （耗时）

5- 链接主程序

6- 链接插入的动态库 （耗时）
    按从主程序根节点的依赖关系递归Bind
    ImageLoader::link - recursiveRebase、recursiveBind

7- 弱符号绑定（优先非懒加载、弱符号，懒加载符号在第一次调用后再绑定）
    __attribute__ ((weak))
    ImageLoader::link - weakBind


8 - 主程序初始化 initializeMainExecutable 

    递归初始化，先初始化依赖的动态库，再初始化主程序。深度遍历直到对应的image没有依赖时也就是libsystem.dylib的时候，第一次初始化里面触发dyld注册函数回调

    doModInitFunctions - libsystem_initializer - libdispatch_init - _objc_init - _dyld_objc_callbacks_v1(dyld注册回调函数)
    
    dyld注册回调函数其中包含（map_images,load_images,unmap_image）

- map_image() 将类、分类，协议，方法都映射加载进内存

核心函数 _read_images

    - readClass 读取类进内存、修复没有映射的部分类
    - readProtocol 读取协议进内存、修复没有映射的部分协议
    - sel_init  将所有的方法SEL注册到namedSelectors表 修复预编译阶段的SEL的混乱问题
    - AutoreleasePoolPage init  新版本没有了
    - SideTablesMap init 引用计数、weak表等
    - _objc_associations init - AssociationsManager init 关联对象表

- load_image() 

    - loadAllCategories()

    loadAllCategories 读取mach-o中的categories，跟主类建立关系，读取主类的ro，分配内存创建rwe，将ro赋值到rwe，最后遍历categories将所有的方法，属性，协议以倒序的方式添加到主类的rwe的3个list表中。
    
    - class_ro_t 不可变原始空间，原类的方法、属性、协议列表等
    - class_rw_t 运行时脏内存 有ro 也有 rwe
    - class_rwe_t category里的额外内容，方法

    -> call_load_methods -> call_class_loads（会先检查父级） -> call_category_loads

9 - doModInitFunctions - static initializer 初始化C&C++的静态化变量，然后调用 __attribute__((contrutor)) 函数

10 - getEntryFromLC_MAIN 返回main函数入口

```


4、dyld不同版本差异
```
dyld2（步骤都是在进程内完成的）

- dyld_start（rebaseDyld 数据重定位【ASLR原因】、其他配置）
- 解析 Mach-o Header文件 
- 根据头文件信息查找依赖项
- 映射Mach-o到内存
- 执行符号查找（比如用到的外部函数等需要重新指定地址）
- Bind & Rebase 符号绑定和地址重定位【ASLR原因】
- Run initializers  


dyld3 （通过启动闭包机制提高启动速度，包括进程内外三部分）

- 进程外的Mach-o解析器
    包括 解析Mach-o头文件、依赖项查找、符号查找，并把这部分结果封装为闭包写入磁盘
- 进程内的启动闭包运行器
    包括 解析验证启动闭包、映射Mach-o、Bind&Rebase、Run initializers
- 启动闭包缓存服务
    在App安装的时候就会尝试构建启动闭包缓存


dyld4: 采用pre-build + just-in-time 预构建/闭包+实时解析的双解析模式, 将根据缓存有效与否选择合适的模式进行解析, 同时也处理了闭包失效时候需要重建闭包的性能问题
```



5、ASLR
```
在iOS系统中打开一个App的时候是会将App的二进制数据从硬盘copy到内存里，那么这时候二进制数据就会对应一个内存地址，由于考虑安全等因素的问题，内存的地址都是由虚拟缓存地址替代，而且地址的起始位置都是动态的，每次启动的时候都会不一样，这个技术就是ASLR。所以当DYLD加载MachO的时候最先一步要做的就是对数据进行重定位

实际运行地址 = 静态的基地址 + ASLR偏移
```
6、Mach-o文件

```
Header 的最开始是 Magic Number，表示这是一个 Mach-O 文件，除此之外还包含一些 Flags，这些 flags 会影响 Mach-O 的解析。

Load Commands 存储 Mach-O 的布局信息，比如 Segment command 和 Data 中的 Segment/Section 是一一对应的。除了布局信息之外，还包含了依赖的动态库等启动 App 需要的信息。

Data 部分包含了实际的代码和数据，Data 被分割成很多个 Segment，每个 Segment 又被划分成很多个 Section，分别存放不同类型的数据。

标准的三个 Segment 是 TEXT，DATA，LINKEDIT，也支持自定义：
TEXT，代码段，只读可执行，存储函数的二进制代码(__text)，常量字符串(__cstring)，Objective C 的类/方法名等信息
DATA，数据段，读写，存储 Objective C 的字符串(__cfstring)，以及运行时的元数据：class/protocol/method…
LINKEDIT，启动 App 需要的信息，如 bind & rebase 的地址，代码签名，符号表…

```

7、Link Map File

```

```


8、Rebase & Bind


```
由于ASLR机制，Rebase 和 Bind的作用就是修正地址偏移

Rebase：修复内部指针。这是因为 Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。
Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向这个地址。



寄存器
```



9、二进制重排、Page In、虚拟内存

```
App使用内存时虚拟内存，一块虚拟内存会和一块物理内存在表上记录地址映射关系

当读取虚拟内存，对应的物理内存没有需要的数据的时候就会执行 Page In
1、系统阻塞该进程
2、将磁盘中对应Page的数据加载到内存
3、把虚拟内存指向物理内存

iOS ipone6S以上是 16K一页内存页，映射一页在1微秒到0.8毫秒之间。
iOS13 之前读Text段的页还需要解密、签名验证耗时，这个在iOS13系统之后优化了

减少Page In就可以减少耗时

低版本系统可以通过 ld 的-rename_section，把 TEXT 段中的内容，比如字符串移动到其他的段(启动路径上难免会读很多字符串)，从而规避这个解密的耗时

高版本尽量避免Page In，也就是进行二进制重排

```

10、Categories 方法合并
```
程序在编译完成之后，会将所有的Category转换成  struct category_t （含有属性列表、实例、类方法列表、协议列表）在 map_images 函数的类添加的时候 会合并到主类的rwe结构里的各自表中

ro主类方法 + category的分类方法
在 methodizeClass 的时候
都会拷贝 
rwe->methods.attachLists
rwe->protocols.attachLists
rwe->properties.attachLists

通过逆序遍历获取到的方法列表、属性列表和协议列表，最后会通过attachLists函数合并到对应的class中去

for (int i = oldCount - 1; i >= 0; i--)
    newArray->lists[i + addedCount] = array()->lists[i];
for (unsigned i = 0; i < addedCount; i++)
    newArray->lists[i] = addedLists[i];

1、分类的方法列表附加在列表前面，分类之间的顺序取决于分类文件编译顺序
（每个主类、每个分类的方法list顺序还是正常的）
2、其中方法列表在附加之前会进行排序，方便后续方法查询的时候使用二分查找加快速度
（fixupMethodList Sort by selector address.）
3、category里和主类的同名方法并不是覆盖，而是由于category中的方法因为附加到list是在前面，而主类的方法是被放在后面，而方法查找是从第一个方法开始查找，直到找到第一个同名的方法，则将该方法返回，所以会优先调用category的方法而忽略主类中的方法
（不同cateory中的同名方法则是看哪个category文件最后编译，最后编译的会被调用）

```

11、Hook 所有的+Load方法

```

```

12、引用计数

```
1、Tagged Pointer（64位系统中节约内存）
iOS结构：（TaggedPointer标识位 + 类标识 + 数据 + 数据类型）
- 64位下 一个指针8字节，指向一个NSNumber（值8 字节 + isa8字节）共24字节。
- TaggedPointer 直接把值放在指针中存放，共8字节

- Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
- Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。

- 要通过object_getClasss访问，避免直接访问，内部都做了兼容，包括objc_msgSend、weak等情况，避免直接使用isa，因为不是真对象，没有isa
- 在内存读取上有着3倍的效率，创建时比以前快106倍。

2、nonpointer isa （64位系统节约内存，isa除了类对象信息还包括其他）

isa_t
    - has_sidetable_rc 是否用sidetable存放引用计数
    - bits 存储对象使用过程中的其他信息
    - Class cls 指向类对象
    - extra_rc 不用sidetable的时候存放引用计数的地方（10以内）
    

3、存放引用计数的结构

SideTablesMap 哈希桶：所有对象，内存地址为key
    - SideTable 哈希表：内存地址为key，
        - 自旋锁 非公平 unfair 锁
        - RefcountMap 引用计数表
        - weak_table_t 弱引用表

```

13、weak

```
1、特点

- 不会增加指向对象的引用计数 （规避循环引用）
- 指向对象释放后，变量会自动置 nil （规避野指针访问错误）

2、关键数据结构认识

- weak_table_t （key由处理对象内存地址生成，value是weak_entry_t）
    - weak_entry_t *weak_entries; 
    - 其他辅助hash的变量

- weak_entry_t
    - referent 实际对象地址的包装对象，一个封装用于解决内存泄漏
    - 以下联合都是存放weak指针
        - referrers  大于4个用这个hash表
        - inline_referrers 小于4个用这个数组
3、关键流程认识
    - weak指针获取
        1、通过被指向对象的地址获取SideTables -> SideTable -> weak_table_t
        2、通过对象地址获取weak_table_t中的referrer（weak指针）
    - weak指针存放
        1、通过对象地址 + weak指针地址触发storeWeak
        2、检查指针是否有旧指向，检查对象是否支持weak、是否是Taggedgpoint、是否正在释放
        3、释放指针旧指向
        4、检查是否已存在对象的weak_entry
        5、插入已有weak_entry或新建weak_entry并插入weak_table
    - weak指针置空
        1、dealloc - object_dispose - clearDeallocating - weak_clear_no_lock 对象的销毁会触发weak清理
        2、检查释放对象是否存在weak引用
        3、遍历weak_entry -> referrers 中的所有weak指针并指向nil
        4、weak_entry_remove 从weak_table移除weak_entry

4、关键函数认识

- objc_initWeak
    - 参数1：location ：__weak指针的地址，存储指针的地址，这样便可以在最后将其指向的对象置为nil
    - 参数2：所引用的对象

- objc_storeWeak （置 nil 也是直接用的这个函数）
    - 除开上面init的参数，还多3个
    - 存放的这个weak指针是否存在旧指向
    - 存放的这个weak指针是否需要新指向
    - 被指向对象是否正在释放流程

- weak_register_no_lock 新对象注册
    - weak_entry_for_referent 是否已存在检查 weak_entry_t
        - 存在，append_referrer 到 entry
        - 不存在，newEntry -> weak_entry_insert 新建entry并插入 weak_entry_insert

- weak_unregister_no_lock 旧对象解除
    1、按referent在weak_table_t中找到entry
    2、移除对应referrer（weak指针）
    3、判断是否entry已经空了，没有weak指针了
    4、weak_entry_remove 在weak_table_t中移除entry

- weak_clear_no_lock
    - weak_entry_for_referent 是否已存在检查 weak_entry_t
    - 遍历weak_entry -> referrers 中的所有weak指针并指向nil
    - 如果weak指针数量为空，weak_entry_remove 移除实例
```


14、iOS内存分区

```
- 代码段
    代码段主要存储编译后的代码
- 数据段
    字符串常量
    初始化完成的全局变量和静态变量
    未初始化的全局变量和静态变量
- 堆区
    内存地址分配由低到高
    通过 alloc malloc calloc 进行内存分配
- 栈区
    内存地址分配由高到低
    函数调用开销,比如局部变量
- 内核区

```


15、内存对齐
```
内存对齐的目的：

1、处理器内存访问提效（cpu以块的方式读取内存，不对齐的开销大，得分两次读取）

64位系统下（CF requires all objects be at least 16 bytes.）
对象内存申请为8的倍数，最小16   if (size < 16) size = 16;

struct TTStruct1 {
    char a;     //1字节 -- 占据0字节
    double b;   //8字节 -- 占据8-15字节
    int c;      //4字节 -- 占据16-19字节
    short d;    //2字节 -- 占据20-22字节
} MyStruct1;    //共22字节，但22不是8的倍数，则+2，因为24是8的倍数

规则一：数据成员的对齐规则可以理解为min(m, n) 的公式, 其中 m表示当前成员的开始位置, n表示当前成员所需要的位数。如果满足条件 m 整除 n （即 m % n == 0）,  n 从 m 位置开始存储, 反之继续检查 m+1 能否整除 n, 直到可以整除, 从而就确定了当前成员的开始位置

规则二：如果⼀个结构⾥有某些结构体成员,则结构体成员要从其内部最⼤元素⼤⼩的整数倍地址开始存储

规则三：结构体的总体大小，即sizeof的結果，必须是其內部最大成員的整數倍，不足的需要补齐

系统在属性上会自动内存对齐优化 属性重排  iOS堆内存 16字节对齐
```

16、alloc、init
```
- alloc
    1、instanceSize 确定内存分配大小
    2、calloc分配内存 ->obj
    3、给obj 构建isa指针 绑定isa和对象

- init
    只是返回了对象


NSObject *obj = [[NSObject alloc] init]占有多少空间？

isa 8字节，但是最小16字节，所以返回16字节，其中8字节空的

new 相当于 alloc + init

```


17、assign

```
assign一般用来修饰值类型，存储在栈空间的属性，由系统管理其内存生命周期
assign引用对象编译不报错，但是可能出生野指针访问异常

assign没有强引用，当修饰对象被释放后，指针还在，访问指针可能出现野指针

weak只能修饰对象，修饰基础类型会编译错误
```


18、iOS关键词 访问控制

```
@private 作用范围只能在自身类
@protected 作用范围在自身类和继承自己的子类，什么都不写，默认是此属性。
@public 作用范围最大，在任何地方


```


#### block的本质
```
源码：libclosure 库

struct __main_block_impl_0 {
  struct __block_impl impl;
  __main_block_impl_0(void *fp, int flags=0) {
    impl.isa = 0/*&_NSConcreteStackBlock*/;
    impl.Size = sizeof(__main_block_impl_0);
    impl.Flags = flags;
    impl.FuncPtr = fp;
  }
};

struct __block_impl {
  void *isa;
  int Flags;
  int Size;
  void *FuncPtr;
};

总结：一个包装类，带一个block结构体属性和一个构造函数
从__main_block_impl_0构造函数分析

1、block 是对象，一个结构体对象，他有isa指针
2、FuncPtr 指向方法体的实现
3、isa为  _NSConcreteStackBlock 类型

可以通俗理解成 block是一个继承自_NSConcreteStackBlock的类

```
#### clang转译写的block
普通block
```
  // 声明一个 block 类型变量 myBlock，指向一个新定义的 Block
  void (^myBlock)(void) = ^{
    NSLog(@"Hello world!");
  };

  // 调用此 block
  myBlock();

------------------- 通过clang编译成c++ -------------------

   // 定义 Block
  void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));

  // 调用 Block
  ((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);


```

有外层变量访问的block，截获
```
// 定义局部变量 (为了测试的更完整，我增加了一个对象)
int a = 10;
id obj = [[NSObject alloc] init];

// 声明一个 block 类型变量 myBlock，指向一个新定义的 Block
void (^myBlock)(void) = ^{
  NSLog(@"Hello world! %d, %@", a, obj);
};

// 调用此 block
myBlock();

------------------- 通过clang编译成c++ -------------------
// 定义局部变量与生成对象
int a = 10;
id obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSObject"), sel_registerName("alloc")), sel_registerName("init"));

// 定义 Block
void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a, obj, 570425344));

// 调用 Block
((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);
```

#### block外层变量访问的实现

```
1、本质是编译器给处理了，往包装类中构造了两个成员变量，就是我们访问的局部变量
2、构造函数也增加了两个相应的参数
3、所以发生自动截取的问题，只有引用对象才不被截取

```

有外层变量访问的block，__block修饰不截获

```
  // 定义 block 变量
  __block id obj = [[NSObject alloc] init];
  __block int a = 10;

  // 声明一个 block 类型变量 myBlock，指向一个新定义的 Block
  void (^myBlock)(void) = ^{
    obj = [[NSObject alloc] init];
    a = 20;
  };

  // 调用此 block
  myBlock();
------------------- 通过clang编译成c++ -------------------
// 对应于：__block id obj = [[NSObject alloc] init];
__attribute__((__blocks__(byref))) __Block_byref_obj_0 obj =
{
  (void*)0,
  (__Block_byref_obj_0 *)&obj,
  33554432,
  sizeof(__Block_byref_obj_0),
  __Block_byref_id_object_copy_131,
  __Block_byref_id_object_dispose_131,
  ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSObject"), sel_registerName("alloc")), sel_registerName("init"))
};

// 对应于：__block int a = 10;
__attribute__((__blocks__(byref))) __Block_byref_a_1 a =
{
  (void*)0,
  (__Block_byref_a_1 *)&a,
  0,
  sizeof(__Block_byref_a_1),
  10
};

// Block 定义
void (*myBlock)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_obj_0 *)&obj, (__Block_byref_a_1 *)&a, 570425344));

// 调用 block 方法
((void (*)(__block_impl *))((__block_impl *)myBlock)->FuncPtr)((__block_impl *)myBlock);

```

#### __block的原理

```
__block的修饰，把原变量进行的包装，比如int a，包装为了 __Block_byref_a_1

struct __Block_byref_obj_0 {
  void *__isa;
  __Block_byref_obj_0 *__forwarding;
  int __flags;
  int __size;
  void (*__Block_byref_id_object_copy)(void*, void*);
  void (*__Block_byref_id_object_dispose)(void*);
  id obj; // 封装类中的
};

struct __Block_byref_a_1 {
  void *__isa;
  __Block_byref_a_1 *__forwarding;
  int __flags;
  int __size;
  int a;
};

源码结构如上，__Block_byref_a_1 中的forwarding指针指向的是原本的变量a的地址
所以内部修改也就修改的是原本变量a

对象类型的变量还多了一个copy 一个 dispose的方法

1、copy的作用涉及到block的拷贝

block根据所在内存可归为以下三种类型

NSConcreteStackBlock | 栈区 | （访问局部变量，离开方法作用域就会销毁）
NSConcreteGlobalBlock | 数据区 | （定义在全局 访问静态变量或者不访问外部变量的）
NSConcreteMallocBlock | 堆区 | （赋值操作会自动拷贝到堆）

// 定义一个全局 Block
void (^globalBlock)(void) = ^{ printf("globalBlock\n", ); };

int main(int argc, const char * argv[]) {
  int a = 1;
  static int b = 2;

  void(^localBlock)(void) = ^(void) {
      NSLog (@"访问局部变量 localBlock % d", a);
  };
  void(^staticBlock)(void) = ^(void) {
      NSLog (@"访问静态变量 staticBlock % d", b);
  };
  void(^paramBlock)(NSString *) = ^(NSString *inputStr) {
      NSLog (@"只访问入参 paramBlock %@", inputStr);
  };

  globalBlock();
  localBlock();
  staticBlock();
  paramBlock(@"c");

  NSLog(@"globalBlock:%@", globalBlock);
  NSLog(@"localBlock:%@", localBlock);
  NSLog(@"staticBlock:%@", staticBlock);
  NSLog(@"paramBlock:%@", paramBlock);
  NSLog(@"stackBlock:%@", ^{
      NSLog (@"访问局部变量 stackBlock % d", a);
  });
}

==> output:
globalBlock
访问局部变量 localBlock 1
访问静态变量 staticBlock 2
只访问入参 paramBlock hello
globalBlock:<__NSGlobalBlock__: 0x10b7f9138>
localBlock:<__NSMallocBlock__: 0x60000270e100>
staticBlock:<__NSGlobalBlock__: 0x10b7f9198>
paramBlock:<__NSGlobalBlock__: 0x10b7f91d8>
stackBlock:<__NSStackBlock__: 0x7ffee4406520>

堆拷贝的作用：Block 超出变量作用域后仍然可以使用

翻源码：_Block_copy

*dest = _Block_byref_copy(object);
block拷贝时，对应构造的成员变量也一起拷贝，forwarding指针的设计让指向依然正常


2、block对外部对象的持有 可能导致循环引用

由于block对对象的劫持是指针劫持，所以只要外部用的是weak，劫持到的指针也是weak修饰。就不会造成循环引用了

```

#### 1、block要如何hook？
```

1、消息转发

强行将block的函数指针（invoke）强行指向_objc_msgForward，启动它的消息转发

在 NSInvocation 层转发

2、fishhook 去hook _Block_copy 函数，更换 invoke指向

struct Block_layout {
    void * __ptrauth_objc_isa_pointer isa;
    volatile int32_t flags; // contains ref count
    int32_t reserved;
    BlockInvokeFunction invoke;
    struct Block_descriptor_1 *descriptor;
    // imported variables
};

https://cloud.tencent.com/developer/article/1411339
```


#### 4、OC Block 和 Swift闭包的区别

```
1、OC的block在编译的时候就执行了拷贝，swift 的闭包要到执行的时候才会发生拷贝，swift可以让他提前捕获

var i = 1
let closure = {
    [i] in
    print("closure \(i)")
}

加上[i] 就行


```


NSProxy
```

```


#### 关联对象 AssociationsManager

```

动态添加属性
objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);

- 关键结构
- AssociationsManager

- AssociationsHashMap  （装饰对象地址 - ObjectAssociationMap）
DenseMap<DisguisedPtr<objc_object>, ObjectAssociationMap>

- ObjectAssociationMap  （属性key - ObjcAssociation）
DenseMap<const void *, ObjcAssociation>

- ObjcAssociation
    - uintptr_t _policy;
    - id _value;

1、一个对象就对应一个ObjectAssociationMap
2、ObjectAssociationMap中存储着多个此对象的关联属性的key以及ObjcAssociation
3、ObjcAssociation中存储着所有关联属性的value和policy策略

关联属性并不是存放在对象中，而是AssociationsManager在全局维护了一张哈希表
dealloc的时候回调用 - objc_destructInstance - _object_remove_associations 移除关联属性 

```






#### runloop

```
哪些在用

1、检测卡顿
2、监听


/* Run Loop Observer Activities */
    typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
        kCFRunLoopEntry = (1UL << 0), // 进入RunLoop 
        kCFRunLoopBeforeTimers = (1UL << 1), // 即将开始Timer处理
        kCFRunLoopBeforeSources = (1UL << 2), // 即将开始Source处理
        kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
        kCFRunLoopAfterWaiting = (1UL << 6), //从休眠状态唤醒
        kCFRunLoopExit = (1UL << 7), //退出RunLoop
        kCFRunLoopAllActivities = 0x0FFFFFFFU
    };

1、线程和runloop 一一对应，除了主线程，其他线程runloop要自行启用

2、获取线程runloop的方式就时CFRunLoopGetCurrent、currentRunLoop

3、

```


#### @autorelease、autoreleasepool

```
源码：
class AutoreleasePoolPage;
struct AutoreleasePoolPageData
{
AutoreleasePoolPage * const parent;
AutoreleasePoolPage *child;

AutoreleasePoolPage 是个双向链表结构，每个Page是栈结构

- push
    - autoreleaseNewPage
-  popPage
    - page->releaseUntil(stop);

自动释放池工作原理：

1、与runloop挂钩，子线程如果没有开启runloop也无法生效
2、如果线程使用了自动释放池，会给runloop插入两个监听者
    - kCFRunLoopEntry 
    （最高优先级监听者，保证回调发生最早，调用push创建释放池）
    - kCFRunLoopBeforeWaiting | kCFRunLoopExit
    （休眠前pop释放池子，同时push创建一个新池子，退出runloop时pop释放池子）

3、游标：POOL_BOUNDARY
    - 区分不同的自动释放池，也就是不同的@autoreleasepool。调用push时，会传入POOL_BOUNDARY并返回一个地址，起到分割的作用
    - 调用pop时会传入end地址，由于page本身是栈结构，所以从end开始调用释放直到游标位
    - 如果是多个page，会从child page的最末尾开始调用释放，直到游标位置

3、多层嵌套@autoreleasepool 
    - 同一个池子，按不同@autoreleasepool 插入游标区分
```


20、iOS渲染

layoutifneed、setneedslayout



iOS响应链
```

CADisplayLink



NSCache 和 NSDictionary 的区别

1、NSDictionary

NSDictionary的key必须是支持NSCopying协议的对象
- key小而高效才能保证拷贝复制的时候没有太多负担
- 会保持对对象的强引用
- 没有自动释放逻辑
- 线程不安全

2、NSCache
- 收到系统内存告警时会自动释放对象 removeAllObject
- 线程安全
- 对key不是拷贝，只是强引用，没有拷贝消耗


3、NSMapTable 

- NSMapTable可以对其key和value弱引用
[[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];

- 可以包含任意指针对象


4、NSPointerArray

- 和可变数组一样，有下标操作修改数组内容
- 可以插入或者删除nil，nil参与count计算
- 可以使用weak修饰成员，能使用weak的自动置空优势，比如持有监听者，自动释放置空，避免循环引用
- 可以for in遍历

5、NSProxy

实现了NSObject协议的抽象基类，是根类 不继承NSObject

- 模拟多继承


- 避免循环引用
//NSProxy 弱引用self
SDWeakProxy *weakProxy = [SDWeakProxy proxyWithTarget:self];
//CAdisplayLink 强引用proxy
_displayLink = [CADisplayLink displayLinkWithTarget:weakProxy selector:@selector(displayLinkDidRefresh:)];
- 


原理是啥



```

```





https://www.jianshu.com/p/f141a368abb5
https://www.zhihu.com/pin/1661784546335944704?utm_id=0
https://medium.com/tokopedia-engineering/a-curious-case-of-mach-o-executable-26d5ecadd995
https://www.jianshu.com/p/47d03a2dea02

https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247486932&idx=1&sn=eb4d294e00375d506b93a00b535c6b05&chksm=e9d0c636dea74f20ec800af333d1ee94969b74a92f3f9a5a66a479380d1d9a4dbb8ffd4574ca&scene=21#wechat_redirect

https://juejin.cn/post/6936377886555242509


https://juejin.cn/post/6896728016953540621

https://juejin.cn/post/6953478561579663397

https://www.jianshu.com/p/50e88f9fbfa8

https://huang-libo.github.io/posts/App-Startup-Time-dyld/#dyld-2-的执行流程

weak、sidetable
https://blog.csdn.net/m0_52192682/article/details/125948436?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS5oay8%3D

taggedpoint
https://blog.devtang.com/2014/05/30/understand-tagged-pointer/


block

https://luochenxun.com/ios-mt-block3/