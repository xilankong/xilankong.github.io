---
0layout: post
category: iOS学习总结
title : "iOS关键词总结"
tags: iOS
---

> 如果你不知道你接下来需要补充学习哪一部分知识，梳理一下自己认识的关键词吧。




#### 一、App启动

1、启动种类
```
- 热启动
- 冷启动
- 后台回前台
- 预热
```

2、启动流程
```

- 细分从点击AppIcon到App启动：

1、 SpringBoad复制进程，loadMachine加载Mach-o(parse_machfile)

2、进行__TEXT，__DATA的映射，加载UUID，创建主线程，代码签名验证

3、加载动态链器（dyld2、dyld3（iOS13）、dyld4（iOS16））

3、dyld 加载过程的三个阶段（pre-main -> Runtime Initializer -> main）

4、main后阶段

```

3、dyld流程 - premain

https://www.jianshu.com/p/f141a368abb5

https://www.zhihu.com/pin/1661784546335944704?utm_id=0

https://medium.com/tokopedia-engineering/a-curious-case-of-mach-o-executable-26d5ecadd995

https://www.jianshu.com/p/47d03a2dea02

```
- 设置环境变量

- loadDyldCache 共享库缓存

- 实例化主程序（ImageLoader）

- 加载插入的动态库 （耗时）

- 链接主程序

- 链接插入的动态库 （耗时）
    通过image中的 registerInterposing 去遍历Mach-o的加载命令，为Bind做准备

- 执行符号绑定（优先非懒加载、弱符号）
    按从主程序根节点的依赖关系递归Bind
    recursiveBindWithAccounting

```

4、dyld流程 - Run initializer

```

- 主程序初始化 （递归初始化，先初始化动态库，再初始化主程序）
按主程序依赖关系递归初始化所有动态库，深度遍历直到对应的image没有依赖时会通过执行_dyld_objc_notify_register里注册的load_image方法进行初始化，进而进行category的加载，+load的方法的执行

- map_image() 将类，协议，方法都映射加载进内存
    - AutoreleasePoolPage init  新版本没有了

    - SideTablesMap init

    - _objc_associations init - AssociationsManager init


- load_image() 

    - loadAllCategories()

    loadAllCategories 读取mach-o中的categories，跟主类建立关系，读取主类的ro，分配内存创建rwe，将ro赋值到rwe，最后遍历categories将所有的方法，属性，协议以倒序的方式添加到主类的rwe的3个list表中。
    其中方法列表在附加之前会进行排序，方便后续方法查询的时候使用二分查找加快速度。category里和主类的同名方法并不是覆盖，而是由于category中的方法因为附加到list是在前面，而主类的方法是被放在后面，而方法查找是从第一个方法开始查找，直到找到第一个同名的方法，则将该方法返回，所以会优先调用category的方法而忽略主类中的方法。不同cateory中的同名方法则是看哪个category文件最后编译，最后编译的会被调用



    -> call_load_methods -> call_class_loads -> call_category_loads


- doInitialization 初始化C&C++的静态化变量，然后调用 __attribute__((contrutor)) 函数

- getEntryFromLC_MAIN 返回main函数入口
```



3、dyld
```
dyld2（步骤都是在进程内完成的）

- dyld_start（rebaseDyld 数据重定位【ASLR原因】、其他配置）

- 解析 Mach-o Header文件 

- 根据头文件信息查找依赖项

- 映射Mach-o到内存

- 执行符号查找（比如用到的外部函数等需要重新指定地址）

- Bind & Rebase 符号绑定和地址重定位【ASLR原因】

- Run initializers  


dyld3 （通过启动闭包机制提高启动速度，包括进程内外三部分）

- 进程外的Mach-o解析器
    包括 解析Mach-o头文件、依赖项查找、符号查找，并把这部分结果封装为闭包写入磁盘

- 进程内的启动闭包运行器
    包括 解析验证启动闭包、映射Mach-o、Bind&Rebase、Run initializers

- 启动闭包缓存服务
    在App安装的时候就会尝试构建启动闭包缓存


dyld4: 采用pre-build + just-in-time 预构建/闭包+实时解析的双解析模式, 将根据缓存有效与否选择合适的模式进行解析, 同时也处理了闭包失效时候需要重建闭包的性能问题
```



4、ASLR
```
在iOS系统中打开一个App的时候是会将App的二进制数据从硬盘copy到内存里，那么这时候二进制数据就会对应一个内存地址，由于考虑安全等因素的问题，内存的地址都是由虚拟缓存地址替代，而且地址的起始位置都是动态的，每次启动的时候都会不一样，这个技术就是ASLR。所以当DYLD加载MachO的时候最先一步要做的就是对数据进行重定位

实际运行地址 = 静态的基地址 + ASLR偏移
```
5、Mach-o文件
https://juejin.cn/post/6953478561579663397

```
Mach-O 头（Mach Header）：这里描述了 Mach-O 的 CPU 架构、文件类型以及加载命令等信息

加载命令（Load Command）：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示

数据区（Data）：Data 中每一个段（Segment）的数据都保存在此，段的概念和 ELF 文件中段的概念类似，都拥有一个或多个 Section ，用来存放数据和代码


```


Rebase & Bind

https://juejin.cn/post/6896728016953540621

```
由于ASLR机制，Rebase 和 Bind的作用就是修正地址偏移

```

寄存器


