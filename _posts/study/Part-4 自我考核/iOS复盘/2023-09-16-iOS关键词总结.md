---
0layout: post
category: iOS学习总结
title : "iOS关键词总结"
tags: iOS
---

> 如果你不知道你接下来需要补充学习哪一部分知识，梳理一下自己认识的关键词吧。




#### 一、App启动

1、启动种类
```
- 热启动
- 冷启动
- 后台回前台
- 预热
```

2、启动流程
```

- 细分从点击AppIcon到App启动：

1、 SpringBoad复制进程，loadMachine加载Mach-o(parse_machfile)

2、进行__TEXT，__DATA的映射，加载UUID，创建主线程，代码签名验证

3、加载动态链器（dyld2、dyld3（iOS13）、dyld4（iOS16））

3、dyld 加载过程的三个阶段（system interfeace -> Runtime Initializer -> main）

4、main后阶段

```

3、dyld流程 


```
1- 设置环境变量

2- loadDyldCache 共享库缓存

3- 实例化主程序 instantiateFromLoadedImage
    加载可执行文件并生成一个ImageLoader实例对象（读取可执行文件头信息 ）

4- 加载插入的动态库 （耗时）

5- 链接主程序

6- 链接插入的动态库 （耗时）
    按从主程序根节点的依赖关系递归Bind
    ImageLoader::link - recursiveRebase、recursiveBind

7- 弱符号绑定（优先非懒加载、弱符号，懒加载符号在第一次调用后再绑定）
    __attribute__ ((weak))
    ImageLoader::link - weakBind


8 - 主程序初始化 initializeMainExecutable 

    递归初始化，先初始化依赖的动态库，再初始化主程序。深度遍历直到对应的image没有依赖时也就是libsystem.dylib的时候

    doModInitFunctions - libsystem_initializer - libdispatch_init - _objc_init - _dyld_objc_callbacks_v1(dyld注册回调函数)
    
    dyld注册回调函数其中包含（map_images,load_images,unmap_image）

- map_image() 将类、分类，协议，方法都映射加载进内存

核心函数 _read_images

    - readClass 读取类进内存、修复没有映射的部分类
    
    - readProtocol 读取协议进内存、修复没有映射的部分协议

    - sel_init  将所有的方法SEL注册到namedSelectors表 修复预编译阶段的SEL的混乱问题

    - AutoreleasePoolPage init  新版本没有了

    - SideTablesMap init 引用计数、weak表等

    - _objc_associations init - AssociationsManager init 关联对象表

- load_image() 

    - loadAllCategories()

    loadAllCategories 读取mach-o中的categories，跟主类建立关系，读取主类的ro，分配内存创建rwe，将ro赋值到rwe，最后遍历categories将所有的方法，属性，协议以倒序的方式添加到主类的rwe的3个list表中。
    其中方法列表在附加之前会进行排序，方便后续方法查询的时候使用二分查找加快速度。category里和主类的同名方法并不是覆盖，而是由于category中的方法因为附加到list是在前面，而主类的方法是被放在后面，而方法查找是从第一个方法开始查找，直到找到第一个同名的方法，则将该方法返回，所以会优先调用category的方法而忽略主类中的方法。不同cateory中的同名方法则是看哪个category文件最后编译，最后编译的会被调用 
    
    - class_ro_t 不可变原始空间，原类的方法、属性、协议列表等
    - class_rw_t 运行时脏内存 有ro 也有 rwe
    - class_rwe_t category里的额外内容，方法

    -> call_load_methods -> call_class_loads（会先检查父级） -> call_category_loads

9 - doModInitFunctions - static initializer 初始化C&C++的静态化变量，然后调用 __attribute__((contrutor)) 函数

10 - getEntryFromLC_MAIN 返回main函数入口

```


4、dyld
```
dyld2（步骤都是在进程内完成的）

- dyld_start（rebaseDyld 数据重定位【ASLR原因】、其他配置）

- 解析 Mach-o Header文件 

- 根据头文件信息查找依赖项

- 映射Mach-o到内存

- 执行符号查找（比如用到的外部函数等需要重新指定地址）

- Bind & Rebase 符号绑定和地址重定位【ASLR原因】

- Run initializers  


dyld3 （通过启动闭包机制提高启动速度，包括进程内外三部分）

- 进程外的Mach-o解析器
    包括 解析Mach-o头文件、依赖项查找、符号查找，并把这部分结果封装为闭包写入磁盘

- 进程内的启动闭包运行器
    包括 解析验证启动闭包、映射Mach-o、Bind&Rebase、Run initializers

- 启动闭包缓存服务
    在App安装的时候就会尝试构建启动闭包缓存


dyld4: 采用pre-build + just-in-time 预构建/闭包+实时解析的双解析模式, 将根据缓存有效与否选择合适的模式进行解析, 同时也处理了闭包失效时候需要重建闭包的性能问题
```



5、ASLR
```
在iOS系统中打开一个App的时候是会将App的二进制数据从硬盘copy到内存里，那么这时候二进制数据就会对应一个内存地址，由于考虑安全等因素的问题，内存的地址都是由虚拟缓存地址替代，而且地址的起始位置都是动态的，每次启动的时候都会不一样，这个技术就是ASLR。所以当DYLD加载MachO的时候最先一步要做的就是对数据进行重定位

实际运行地址 = 静态的基地址 + ASLR偏移
```
6、Mach-o文件

```
Header 的最开始是 Magic Number，表示这是一个 Mach-O 文件，除此之外还包含一些 Flags，这些 flags 会影响 Mach-O 的解析。

Load Commands 存储 Mach-O 的布局信息，比如 Segment command 和 Data 中的 Segment/Section 是一一对应的。除了布局信息之外，还包含了依赖的动态库等启动 App 需要的信息。

Data 部分包含了实际的代码和数据，Data 被分割成很多个 Segment，每个 Segment 又被划分成很多个 Section，分别存放不同类型的数据。

标准的三个 Segment 是 TEXT，DATA，LINKEDIT，也支持自定义：
TEXT，代码段，只读可执行，存储函数的二进制代码(__text)，常量字符串(__cstring)，Objective C 的类/方法名等信息
DATA，数据段，读写，存储 Objective C 的字符串(__cfstring)，以及运行时的元数据：class/protocol/method…
LINKEDIT，启动 App 需要的信息，如 bind & rebase 的地址，代码签名，符号表…

```

7、Link Map File

```

```


8、Rebase & Bind


```
由于ASLR机制，Rebase 和 Bind的作用就是修正地址偏移

Rebase：修复内部指针。这是因为 Mach-O 在 mmap 到虚拟内存的时候，起始地址会有一个随机的偏移量 slide，需要把内部的指针指向加上这个 slide。
Bind：修复外部指针。这个比较好理解，因为像 printf 等外部函数，只有运行时才知道它的地址是什么，bind 就是把指针指向这个地址。



寄存器
```



9、二进制重排、Page In、虚拟内存

```
App使用内存时虚拟内存，一块虚拟内存会和一块物理内存在表上记录地址映射关系

当读取虚拟内存，对应的物理内存没有需要的数据的时候就会执行 Page In
1、系统阻塞该进程
2、将磁盘中对应Page的数据加载到内存
3、把虚拟内存指向物理内存

iOS ipone6S以上是 16K一页内存页，映射一页在1微秒到0.8毫秒之间。
iOS13 之前读Text段的页还需要解密、签名验证耗时，这个在iOS13系统之后优化了

减少Page In就可以减少耗时

低版本系统可以通过 ld 的-rename_section，把 TEXT 段中的内容，比如字符串移动到其他的段(启动路径上难免会读很多字符串)，从而规避这个解密的耗时

高版本尽量避免Page In，也就是进行二进制重排

```

10、Categories 方法合并
```
程序在编译完成之后，会将所有的Category转换成  struct category_t （含有属性列表、实例、类方法列表、协议列表）在 map_images 函数的类添加的时候 会合并到主类的rwe结构里的各自表中

ro主类方法 + category的分类方法
在 methodizeClass 的时候
都会拷贝 
rwe->methods.attachLists
rwe->protocols.attachLists
rwe->properties.attachLists

通过逆序遍历获取到的方法列表、属性列表和协议列表，最后会通过attachLists函数合并到对应的class中去

for (int i = oldCount - 1; i >= 0; i--)
    newArray->lists[i + addedCount] = array()->lists[i];
for (unsigned i = 0; i < addedCount; i++)
    newArray->lists[i] = addedLists[i];

原来后添加，现在新遍历的在前面（每个主类、每个分类的方法list顺序还是正常的）

```

11、Hook 所有的+Load方法

```

```


12、





















https://www.jianshu.com/p/f141a368abb5
https://www.zhihu.com/pin/1661784546335944704?utm_id=0
https://medium.com/tokopedia-engineering/a-curious-case-of-mach-o-executable-26d5ecadd995
https://www.jianshu.com/p/47d03a2dea02

https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247486932&idx=1&sn=eb4d294e00375d506b93a00b535c6b05&chksm=e9d0c636dea74f20ec800af333d1ee94969b74a92f3f9a5a66a479380d1d9a4dbb8ffd4574ca&scene=21#wechat_redirect

https://juejin.cn/post/6936377886555242509


https://juejin.cn/post/6896728016953540621

https://juejin.cn/post/6953478561579663397

https://www.jianshu.com/p/50e88f9fbfa8
