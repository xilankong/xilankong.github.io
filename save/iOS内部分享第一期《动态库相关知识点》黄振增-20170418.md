#动静态库相关知识
***

##索引

1. 常用术语

2. 静动态库特点

3. 财富App动态库步骤

4. 常见问题

5. 参考资料

   ​


### 1. 常用术语

##### 库（Library）
库是指一段编译好的二进制代码，并提供头文件供别人使用。

##### 动态库（Dynamic library）
动态库也称动态链接，是在程序编译时不会被链接到目标代码中，直到可执行文件被执行过程中才被加载调用，即按需加载。

#### 静态库（Static library）
静态库也称静态链接，是在链接阶段，将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。

#### 搜索路径（Search path）
搜索路径是指程序链接时，到哪个位置寻找库。
与静态库相关搜索路径：

与动态库相关搜索路径：
```
@executable_path：表示可执行程序所在的目录。
@loader_path：表示每一个被加载的 binary (包括App, dylib, framework, plugin等) 所在的目录。
@rpath：是一个保存着一个或多个路径的变量，告诉连接器到哪里找库。
```

金斧子财富设置runpath路径如下：

![设置子工程安装路径](./img/module_set_install_name.png)



![设置主工程runpath](./img/root_target_set_run_path.png)

#### Mach-O Type

Mach-O Type全称Mach Object Type，是一种用于存储可执行文件，目标代码，动态库，内核转储的文件格式。

#### 框架（Framework)
Framework是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。

***


### 2. 静动态库特点

#### 静态库形式
常见以.a或.framework结尾。

| 操作系统    | 扩展名           |
| ------- | ------------- |
| Windows | .lib          |
| Linux   | .a            |
| Mac     | .a或.framework |

#### 动态库形式
常见以.dylib或.framework结尾。

| 操作系统    | 扩展名                    |
| ------- | ---------------------- |
| Windows | .dll                   |
| Linux   | .so                    |
| Mac     | .tbd或.framework或.dylib |


**注意: **
**1) .tbd是一种存储跨平台模块映射的文本文件，**
**如：iOS自带的系统库:libz.tdb为例**


```
--- !tapi-tbd-v2
archs:           [ armv7, armv7s, arm64 ]
uuids:           [ 'armv7: 03C04F9E-1793-3007-AE51-EE222C3B1EB6', 'armv7s: 7FEDBE86-DFF0-35D4-8AB8-8546A22571DA',
                   'arm64: B3AB59FF-330F-3225-A53B-4E8E95440D77' ]
platform:        ios
install-name:    /usr/lib/libz.1.dylib
current-version: 1.2.8
objc-constraint: none
exports:         
  - archs:           [ armv7, armv7s, arm64 ]
    symbols:         [ _adler32, _adler32_combine, _compress, _compress2, _compressBound,
                       _crc32, _crc32_combine, _deflate, _deflateBound, _deflateCopy,
                       _deflateEnd, _deflateInit2_, _deflateInit_, _deflateParams,
                       _deflatePending, _deflatePrime, _deflateReset, _deflateResetKeep,
                       _deflateSetDictionary, _deflateSetHeader, _deflateTune, _get_crc_table,
                       _gzbuffer, _gzclearerr, _gzclose, _gzclose_r, _gzclose_w,
                       _gzdirect, _gzdopen, _gzeof, _gzerror, _gzflush, _gzgetc,
                       _gzgetc_, _gzgets, _gzoffset, _gzopen, _gzprintf, _gzputc,
                       _gzputs, _gzread, _gzrewind, _gzseek, _gzsetparams, _gztell,
                       _gzungetc, _gzvprintf, _gzwrite, _inflate, _inflateBack, _inflateBackEnd,
                       _inflateBackInit_, _inflateCopy, _inflateEnd, _inflateGetDictionary,
                       _inflateGetHeader, _inflateInit2_, _inflateInit_, _inflateMark,
                       _inflatePrime, _inflateReset, _inflateReset2, _inflateResetKeep,
                       _inflateSetDictionary, _inflateSync, _inflateSyncPoint, _inflateUndermine,
                       _uncompress, _zError, _zlibCompileFlags, _zlibVersion ]
...
```


**2) Xcode7以后，.dylib格式动态库替换为.tbd格式；**



#### 静态库存储结构 

当App依赖的第三方库采用静态库形式链接，编译器链接时，将收集编译好代码和第三方库，存储于App代码区域，即这些资源是App可执行文件的一部分。App启动时，存储于App代码区域的代码将加载到App寻址地址空间。其流程如下图：<br/>
![静态库存储结构](./img/static_lib_address_space1_2x.png)



#### 动态库存储结构

当App依赖的第三方库采用动态库形式链接，编译器链接时，将第三方库相对引用，存储于App代码区域，真实的依赖资源存储于操作系统或各个App共用路径下。App启动时，只加载需要的资源到App寻址地址空间，即按需索取。其流程如下图：<br/>
![动态库存储结构](./img/dynamic_lib_address_space2_2x.png)



**注意：目前，iOS仍然不允许进程间共享动态库，即iOS上的动态库只能是私有的，因为我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。**

**但iOS8之后，开放了`App Extension`功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。**



#### 静动态库优缺点

通过上述动静态库分析，可以得出如下结果：

| 指标               | 动态库  | 静态库  |
| :--------------- | :--- | :--- |
| 启动时间             | 少    | 多    |
| 占用内存             | 少    | 多    |
| App动态升级          | 可以   | 不可以  |
| App重新编译          | 不需要  | 需要   |
| 按需加载/卸载          | 可以   | 不可以  |
| App资源共享          | 可以   | 不可以  |
| App运行时，性能影响      | 影响   | 不影响  |
| 模块化，分工合作         | 可以   | 可以   |
| 闭源               | 是    | 是    |
| Object-C和Swift混编 | 可以   | 不可以  |



### 3. 财富App动态库步骤

####1）修改工程支持最低版本

动态库最低支持版本为**8.0**

#### 2）修改Podfile

在工程依赖配置文件，增加如下代码：

```
use_frameworks!
```

告诉Cocoapods，整个工程采用框架（Framework），而不是静态库方式。

#### 3）第三方库导入方式

当工程中，使用第三方库时，可以采用如下方式引入：

Swift中

```
import JFZShareSDK
```

Objective-C中

```
@import JFZShareSDK;
或
#import "JFZShareSDK/JFZShareSDK.h"
```

#### 4）第三方库中资源加载方式

为了方便动静态切换，库中资源文件统一放入一个bundle中。如果是静态库，资源bundle位于App的bundle；如果是动态库，资源bundle位于Framework中。

##### 程序中获取Framework

```
# in Objective-C
[NSBundle bundleForClass:<#ClassFromPodspec#>]

# or in swift
NSBundle(forClass: <#ClassFromPodspec#>)
```

##### 获取Framework的图片资源

```
UIImage *image;
if ([UIImage respondsToSelector:@selector(imageNamed:inBundle:compatibleWithTraitCollection:)]) {
    NSBundle *frameWorkBundle = [NSBundle bundleForClass:[self class]];
    image = [UIImage imageNamed:@"JFZFShareUI.bundle/homePage_footer_bg" inBundle:frameWorkBundle compatibleWithTraitCollection:nil];
}
else {
    image = [UIImage imageNamed:@"JFZFShareUI.bundle/homePage_footer_bg"];
}
```

##### 加载xib资源

直接使用xib所在的资源bundle，xib中使用的图片可以直接找到和使用。

```
let frameworkBundle = Bundle.init(for: self.classForCoder());
let frameworkBundlePath = frameworkBundle.bundlePath;
let resourceBundlePath = frameworkBundlePath + "/JFZFShareUI.bundle";
let resourceBundle = Bundle.init(path:resourceBundlePath);
if (isLandscape) {
    return JFZShareViewController.init(nibName: "JFZShareSimpleViewController", bundle: resourceBundle)
}
else {
    return JFZShareViewController.init(nibName: "JFZShareViewController", bundle: resourceBundle)
}
```

#### 5）第三方库中依赖其它第三方库

##### 场景一

第三方库公用头文件，尽量少引入其它第三方库头文件，即尽量在.m中引入头文件。

##### 场景二

第三方库公用头文件，定义的类继承于其它第三方库的类。以JFZFRefresh的`JFZBrandFooter.h`为例：

##### 静态库方式公有头文件，引入MJRefresh库

```
#import "JFZFooterBrandModel.h"
#import "MJRefresh/MJRefresh.h"

@interface JFZBrandFooter : MJRefreshAutoFooter

+ (instancetype)footerWithSlogenList:(NSArray <JFZFooterBrandModel *> *)modelList RefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;

@end
```

##### 动态库方式公有头文件，引入MJRefresh库

```
#import "JFZFooterBrandModel.h"
@import MJRefresh;

@interface JFZBrandFooter : MJRefreshAutoFooter

+ (instancetype)footerWithSlogenList:(NSArray <JFZFooterBrandModel *> *)modelList RefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;

@end
```



**注意：基于cocoapods管理，静态库方式的头文件是否采用@import方式？**



include of non-modular header inside framework module

#### 6）第三方库伞形头文件（***-umbrella.h）

编译好的动态库（Dynamic Frameworks），通过`tree`查看其目录结构：

```
JFZShareSDK.framework
.
├── Headers
│   ├── JFZShareButtonContainerView.h
│   ├── JFZShareButtonSimpleContainerView.h
│   ├── JFZShareButtonView.h
│   ├── JFZShareDefaultModel.h
│   ├── JFZShareDefines.h
│   ├── JFZShareManager.h
│   ├── JFZShareSDK-Swift.h
│   ├── JFZShareSDK-umbrella.h
│   ├── JFZShareSDK.h
│   └── JFZSocialShare.h
├── Info.plist
├── JFZFShareUI.bundle
│   ├── Info.plist
│   ├── JFZShareSimpleViewController.nib
│   ├── JFZShareViewController.nib
│   ├── ico-circle@2x.png
│   ├── ico-circle@3x.png
│   ├── ico-qq@2x.png
│   ├── ico-qq@3x.png
│   ├── ico-wechat@2x.png
│   ├── ico-wechat@3x.png
│   ├── ico-weibo@2x.png
│   ├── ico-weibo@3x.png
│   ├── share_cancel_btn_normal@2x.png
│   ├── share_cancel_btn_normal@3x.png
│   ├── share_cancel_btn_press@2x.png
│   └── share_cancel_btn_press@3x.png
├── JFZShareSDK
├── Modules
│   ├── JFZShareSDK.swiftmodule
│   │   ├── arm.swiftdoc
│   │   ├── arm.swiftmodule
│   │   ├── arm64.swiftdoc
│   │   └── arm64.swiftmodule
│   └── module.modulemap
└── PrivateHeaders
    ├── GlobalConstDefinition.h
    ├── JFZShareQQProvider.h
    ├── JFZShareSinaProvider.h
    ├── JFZShareWeChatProvider.h
    ├── WBAuthorize.h
    ├── WBAuthorizeViewController.h
    ├── WBAuthorizeWebView.h
    ├── WBEngine.h
    ├── WBLogInAlertView.h
    ├── WBRequest.h
    ├── WBSDKGlobal.h
    ├── WBSendView.h
    ├── WBUtil.h
    ├── WXApi.h
    ├── WXApiObject.h
    └── WeiboPublishViewController.h
```

上述中，

##### **Headers：存放公共头文件，包括swift激发的头文件，如：`JFZShareSDK-Swift.h`和伞头文件：`JFZShareSDK-umbrella.h`**

##### **PrivateHeaders：存放私有头文件，对外发布时，可以从Framework删除**

##### **Info.plist：标识作者、版权、版本等信息**

##### ***.bundle：存放Framework使用的相关资源文件**

##### **JFZShareSDK：编译好的二进制文件**

##### **Modules：说明API或头文件可见性、Framework链接哪些库**



`***-umbrella.h`文件包含所有对外公开的头文件，方便引入一个头文件，就能使用框架的所有公有类和方法。如：

```
@import JFZShareSDK
or
#import "JFZShareSDK/JFZShareSDK-umbrella.h"
#import "JFZShareSDK/JFZShareSDK-swift.h"
```

`module.modulemap` 文件就是对一个框架，一个库的所有头文件的结构化描述。

```
1.framework module JFZShareSDK {
2.  umbrella header "JFZShareSDK-umbrella.h"

3.  export *
4.  module * { export * }
}
```

上述文件中，

第一句，申明一个模块名：JFZShareSDK

第二句，申明一个框架的伞形头文件

第三句，申明自动导入当前模块的依赖

第四句，为每一个头文件创建子模块（Submodule）





#### 7）工程动静态方式切换

为了满足各个pod工程兼容动静态库，如上述5，在公共头文件中，添加如下宏`if JFZ_DYNAMIC_LIB`来区分动静态库的头文件引入，如下示例。

```
#import "JFZFooterBrandModel.h"

#if JFZ_DYNAMIC_LIB
@import MJRefresh;
#else
#import "MJRefresh/MJRefresh.h"
#endif

@interface JFZBrandFooter : MJRefreshAutoFooter

+ (instancetype)footerWithSlogenList:(NSArray <JFZFooterBrandModel *> *)modelList RefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;

@end
```



同时，通过在Podfile中设置Hook回调，为工程各个target添加预编译宏`JFZ_DYNAMIC_LIB=0`或`JFZ_DYNAMIC_LIB`=1

```
post_install do |installer|
    
    #判断podfile是用动态还是静态库
    use_framework = false;
    target_definitions = installer.podfile.root_target_definitions;
    target_definitions.each do |target_definition|
        puts "target definition use dynamic framework:#{target_definition.uses_frameworks?}"
        use_framework = target_definition.uses_frameworks?;
    end
    
    installer.pods_project.targets.each do |target|
        target.build_configurations.each do |config|
            config.build_settings['ENABLE_BITCODE'] = 'NO'
            config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'
            config.build_settings['SWIFT_VERSION'] = '3.0'
            #JFZ_DYNAMIC_LIB 1：动态库 0：静态库
            if use_framework
                config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] = "$(inherited) JFZ_DYNAMIC_LIB=1"
                else
                config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] = "$(inherited) JFZ_DYNAMIC_LIB=0"
            end
        end
    end
    
    #如果引入growingIO库，需要加上-ObjC
    analytics = installer.pods_project.targets.find { |target| target.name == 'JFZAnalytics' }
    if analytics
        analytics.build_configurations.each do |config|
            config.build_settings['OTHER_LDFLAGS'] = "$(inherited) -ObjC"
        end
    end
    
    #工程主target添加预编译宏
    updateConfigurationBuild(installer, "JFZShareSDK_Example", use_framework);
end

def updateConfigurationBuild(installer, user_target_name, use_framework = false)
    pod_target_name = "Pods-" + user_target_name;
    aggregate_target = installer.aggregate_targets.find { |target| target.name == pod_target_name }
    root_path = aggregate_target.client_root;
    puts "target root:#{root_path}";
    
    user_targets = aggregate_target.user_targets;
    user_target = user_targets.find { |target| target.name == user_target_name };
    puts "user_target:#{user_target}"
    
    user_target.build_configurations.each do |config|
        puts "config name:#{config.name}"
        config_path = root_path + aggregate_target.xcconfig_relative_path(config.name);
        puts "config_path:#{config_path}"
        
        xcconfig = Xcodeproj::Config.new(config_path);
        #puts "xcconfig:#{xcconfig}"
        
        gcc_preprocessor_definitions = xcconfig.attributes['GCC_PREPROCESSOR_DEFINITIONS'];
        if use_framework
            new_gcc_preprocessor_definitions = gcc_preprocessor_definitions + " JFZ_DYNAMIC_LIB=1 USE_JFZ_COMMON_WEBVIEW=1";
            else
            new_gcc_preprocessor_definitions = gcc_preprocessor_definitions + " JFZ_DYNAMIC_LIB=0 USE_JFZ_COMMON_WEBVIEW=1";
        end
        xcconfig.attributes['GCC_PREPROCESSOR_DEFINITIONS'] = new_gcc_preprocessor_definitions;
        puts "xcconfig new gcc preprocessor define:#{xcconfig.attributes['GCC_PREPROCESSOR_DEFINITIONS']}";
        
        #禁止bitcode
        xcconfig.attributes['ENABLE_BITCODE'] = 'NO'
        
        xcconfig.save_as(config_path);
    end
end

```



##### **注意：#import和@import的区别**？

***

### 5.常见问题

####当加入JFZAnalytics模块，打开GrowingIO统计库，App启动时，会崩溃

原因：GrowingIO库中，扩展了UIApplication，而JFZAnalytics动态模块，没有包含先关扩展

解决方式：对JFZAnalytics模块添加-ObjC标志即可。

***

### 6.参考资料
1. [module-map-file](http://clang.llvm.org/docs/Modules.html#module-map-file)
2. [module介绍](http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf)
3. [Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html)
4. [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1)


***
